% Minimal Runtime System Virtual Assembly Language
%
% File:         minval.tex
% Author:       Bob Walton (walton@acm.org)
% Date:		See \date below.
  
\documentclass[12pt]{article}

\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{makeidx}
% \usepackage{pictex} (obsolete? not available under CentOS 7)
\usepackage{upquote} % (imported to local directory
                     % ; not available under CentOS 7)
    % Modifies \verb and \verbatim to print ' with
    % the Computer Modern Typewrite font.
    % Also includes the textcomp package.
    % Modifies \verb and \verbatim to print ' with
    % the Computer Modern Typewrite font.
    % Also includes the textcomp package.

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\setlength{\textheight}{8.5in}
\raggedbottom

\setlength{\unitlength}{1in}

% The following attempt to eliminate headers at the bottom of a page.
\widowpenalty=300
\clubpenalty=300
\setlength{\parskip}{3ex plus 2ex minus 2ex}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{0.8in}%
	      \setlength{\rightmargin}{0.8in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\TILDE}{\textasciitilde}

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\TT}[1]{{\tt \bfseries #1}}
\newcommand{\TTALL}{\tt \bfseries}

\newcommand{\STAR}{{\Large $^\star$}}
\newcommand{\PLUS}[1][]{{$^{+#1}$}}
\newcommand{\QMARK}{{$^{\,\mbox{\footnotesize ?}}$}}
\newcommand{\OPEN}{{$\{$}}
\newcommand{\CLOSE}{{$\}$}}

\newcommand{\ABV}{-{}-{}->}
\newcommand{\MA}{{\em ma}\QMARK}
\newcommand{\TS}{\hspace*{0in}\tt}

\newcommand{\key}[1]{{\rm \bfseries #1}}
\newcommand{\ttkey}[1]{{\tt \bfseries #1}}
\newcommand{\emkey}[1]{{\em \bfseries #1}}
\newcommand{\skey}[2]{{\rm \bfseries #1#2}}
\newcommand{\ikey}[2]{{\rm \bfseries #1}}
\newcommand{\tttkey}[1]{{\tt \bfseries <#1>}}
\newcommand{\ttakey}[1]{{\tt \bfseries *#1*}}
\newcommand{\ttdkey}[1]{{\tt \bfseries .#1}}

\newcommand{\itemref}[1]{\ref{#1}$\,^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}
\newcommand{\pagnote}[1]{$\,^{p\pageref{#1}}$}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}

	 \vspace*{-15ex}
	 \centering
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\newenvironment{itemlist}[1][1.2in]%
	{\begin{list}{}{\setlength{\labelwidth}{#1}%
		        \setlength{\leftmargin}{\labelwidth}%
		        \addtolength{\leftmargin}{+0.2in}%
		        \renewcommand{\makelabel}[1]{##1\hfill}}}%
	{\end{list}}

\begin{document}
        
\begin{center}
\Large \bf
Minimal Runtime System\\
Virtual Assembly Language\\[0.5ex]
\huge \bf
MINVAL
\end{center}
\begin{center}
\large \bf
(Draft 1a)
\\[0.5ex]
Robert L. Walton\\
April 25, 2020

\bigskip
 
Table of Contents
\end{center}

\bigskip

\tableofcontents 

\newpage

\section{Introduction}

This document describes \key{MINVAL}, the Minimal Runtime System Virtual
Assembly Language.

\section{Overview}

A typical MINVAL statement is:
\begin{center}
\tt int X = Y - C"0"
\end{center}
This allocates a new variable {\tt X} of type {\tt int}
to the current function frame within the stack,
and sets its value to the value of the
variable {\tt Y} minus the constant {\tt C"0"} (which is
the character code of the character {\tt 0}).

The statement:
\begin{center}
\tt fv uns @ Z = @ Gobbledeegook
\end{center}
makes the variable {\tt Z} synonymous with the
global variable {\tt Gobbledeegook} in the current
module memory.  It does not allocate any new memory.
Instead it sets the location of {\tt Z}
equal to the location of {\tt Gobbledeegook}.

Variables in function frames and module memory
have names, like {\tt X}, {\tt Y}, and {\tt Z},
and locations in memory where their values are stored.
These locations designate the
function frame or module memory containing the location,
and the offset of the location within that memory.
Variables most frequently
have a size equal to the natural
word size of the computer (typically 32 or 64 bits), or
several times that size: {\tt intd} is a two word (double) integer
and {\tt intq} is a four word (quad) integer.

According to its type,
`{\tt fv uns}', the value of {\tt Gobbledeegook} is a `field vector'
pointer that is a quad integer ({\tt intq}) containing:
\begin{itemize}
\item A `base pointer' {\tt int} holding the byte address
of an {\tt int} in memory
that contains the `base (byte) address' of the vector.
\item An `offset' {\tt int} whose high order bits contain
the signed bit offset of the field being pointed at and whose
low order bits contain the size of the field in bits.
The offset is relative to the base address.
The size is at most the size in bits of an {\tt int}
minus 8 (the size of a byte).
On a computer with 64 bit {\tt int} values, the offset is in the
high order 58 bits, the size is in the low order 6 bits,
and the range of sizes is 0 through 56.
\item A `lower bound' {\tt int} which is the minimum allowed
value of the offset {\tt int} (assuming the field size does not
change).
\item An `upper bound' {\tt int} which is the maximum allowed
value of the offset {\tt int} (assuming the field size does not
change).  Here the offset is allowed to point just beyond the
end of the vector data, but no futher.
\end{itemize}
Fields can be signed or unsigned integers, but cannot be
floating point numbers or pointers.  A field can also have
the {\tt bool} type, which is a 1-bit unsigned integer
interpreted as `true' or `false'.

There are other types of pointer.  An {\tt nv} is like a field
vector except that the offset is in bytes and the number type
must specify the size of the number (e.g., {\tt flt64}
for 64-bit IEEE floats).  The {\tt fp} and {\tt np} types are
similar but do not have the bounds and cannot be indexed.  Lastly
there is the direct pointer, {\tt dp}, that is just a single {\tt int}
containing the byte address; this is most useful for calling
C language functions.
New pointer types may be defined by the user.


Assuming that {\tt Gobbledeegook} points at a vector of fields
in the memory of some module or in the heap, the statement
\begin{center}
\tt uns @ Y = @ Gobbledeegook[W]
\end{center}
sets the location of {\tt Y} equal to the {\tt fv} value of
{\tt Gobbledeegook} indexed by the variable {\tt W}.
The value of {\tt W} must be an integer.
Then, more specifically, the location of {\tt Y} is an {\tt fp} pointer 
equal to the first two words of the value of {\tt Gobbledeegook}
with {\tt W} times the field size added to its offset.
It is a run-time error if the new offset is less than the lower
bound of {\tt Gobbledeegook} or greater than \underline{or equal to}
the upper bound.

Now there is a very important difference between {\tt X} on one
hand, and {\tt Y} and {\tt Z} on the other.  When we call an
out-of-line function and then return, we can expect the value of
{\tt X} to be the same as before the call, but the values of
{\tt Y} and {\tt Z} may have changed.  This is because the out-of-line
function and functions it calls can access the locations of {\tt Y} and
{\tt Z} in module memory, but not the location of {\tt X} in the calling
function frame memory.

MINVAL has a full set of number types:
{\tt int8}, {\tt uns8},
{\tt int16}, {\tt uns16}, {\tt flt16}, \ldots,
{\tt int128}, {\tt uns128}, {\tt flt128}.
The types {\tt int}, {\tt uns}, {\tt flt} are just these
types for the target machine word size, and the types
The types {\tt intd}, {\tt intq}, {\tt unsd}, {\tt unsq} are just integer
types for twice (double) or four times (quad) the target machine word size.
The {\tt bool} type is a single bit interpreted as {\tt true} if
1 and {\tt false} if 0: it is in essence a 1-bit unsigned integer.

User defined type values consist of a sequence of bytes containing fields.
Fields in turn can contain subfields.
An example is:

\begin{indpar}\begin{verbatim}
type my type:
             uns32                    // Container for:
    [0-7]    uns8 op_code             //   Operation
    [0]      bool has_constant        //   Format indicator
    [8-31]   int constant             //   Constant
    [8-15]   uns8 src1                //   Source Register
    [16-23]  uns8 src2                //   Source Register
    [24-31]  uns8 des                 //   Destination Register

. . . . . . . . . . . .

my type X = ...
uns op = X.op_code
int c = X.constant
uns8 @ Y = @ X.des
int @ Z = @ X.constant
\end{verbatim}\end{indpar}

In this example there is one field in a {\tt my type} value,
an unlabeled {\tt uns32} integer.
Inside this field there are 6 subfields, the first of which is
an {\tt uns8} integer occupying bits 0-7 of the one field,
where bits are numbered 0, 1, 2, \ldots{} from
low to high order.  The second subfield is a 1-bit {\tt bool}
value that occupies bit 0 of the unlabelled field.

Defined type values are aligned on byte boundaries when
they are stored in memory.  Therefore the {\tt des} subfield
is on a byte boundary, and
the location of {\tt Y} is an {\tt np} number pointer.  Although
the {\tt constant} subfield is on a byte boundary, it is
shorter than an {\tt uns} integer, and therefore the
location of {\tt Z} must be an {\tt fp} field pointer.
If {\tt des} where in bits 23-30 instead of 24-31, it would
not be on a byte boundary and the location of {\tt Y} would
also have to be an {\tt fp} field pointer.

Another example is:

\begin{indpar}\begin{verbatim}
type my type:
    pack
    uns8    kind             // Object Kind
        [0] bool animal      //   True if Animal
        [1] bool vegetable   //   True if Vegetable
    flt64   weight           // Object Weight
    align   64
    label   extension

type my type:
    origin  extension
    align
    flt64   height           // Object Height
    flt64   width            // Object Height

type my type:
    origin  extension
    align
    flt64   volume           // Object Volume

type your type:
    include my type   // Copy members of my type
    dp uns8 name      // Direct pointer to name
                      // character string

. . . . . . . . . . . .

my type X
X.kind = BOX
X.weight = 55
X.height = 1023
X.width = 572

your type Y
Y.kind = BEER
Y.weight = 0.45
Y.volume = 48
Y.name = "John Doe"
\end{verbatim}\end{indpar}

Here the fields are {\tt kind}, {\tt weight}, {\tt height}, etc.
Fields can be packed or aligned: here they are initially packed
so that since {\tt kind} has offset 0 bytes and size 1 byte,
{\tt weight} has offset 1 byte.  Subfields {\tt animal}
and {\tt vegetable} are 1-bit values inside {\tt kind}.

The {\tt align 64} substatement moves the current offset
forward to a 64-bit boundary and causes fields beyond it
to be aligned and not packed.  Alignment boundaries must
be multiples of 8.
A defined type has an
alignment in bits equal to the least common multiple of the
alignments of its members.
Such alignments must also be multiples of 8.

A {\tt label} is like a zero length member that has no value and
is used to associate a label with the current offset.
Here {\tt extension} has the offset value of 128 bits or
16 bytes.
The {\tt origin} substatement resets the current offset to the offset
of a given label.
The {\tt include} substatement copies all the substatements
from another user defined type.

Defined types can be extended
(as per the example), and members can overlay each other.
A defined type value has a size in bytes just large enough to
accommodate all its members.

By default, functions in MINVAL are inline.  For example,

\begin{indpar}\begin{verbatim}
function int r = max ( int x, int y ):
    if x < y:
        r = y
    else:
        r = x

int x = ...
int y = ...
int z = max ( x, y )
\end{verbatim}\end{indpar}

An assignment statement can contain a single function call
or a single operator, but not both, and not more than one.
For example, given the definition of {\tt max} above:

\begin{indpar}\begin{verbatim}
int x = ...
int y = ...
int z = ...
int w = max ( x, max ( y, z ) )    // Illegal
int w1 = max ( y, z )              // OK
int w2 = max ( x, w1 )             // OK
\end{verbatim}\end{indpar}

Although variables in assignment statement operands cannot be
replaced by expressions involving variables, they can be replaced
by expressions involving constants.  Constants are their own
type, {\tt const}, and named constants can be created by assignment
statements.  For example, using the definition of {\tt max} above:

\begin{indpar}\begin{verbatim}
const x = 5
const y = 1e8
const z = x + y
const w = z / x + y
int u = ...
int v = max ( u, z / x + w * y )
\end{verbatim}\end{indpar}

Constant arithemtic is in effect infinite precision with unbounded
integers and rational numbers that are ratios of such integers.
Constant numbers can be converted to any of the runtime
number types.  However it is a compiler error
if the result will not fit into the runtime number.
This happens, for example, if {\tt 1e20}
is converted to an {\tt int32}.

It is possible to define inline functions that execute at assembly
time:

\begin{indpar}\begin{verbatim}
function const r = max ( const x, const y ):
    if x < y:
        r = y
    else:
        r = x

const x = 2e5
const y = 3e6
const z = 9e4
const w = max ( x, max( y, z ) )  // Legal!
\end{verbatim}\end{indpar}

Inline function definitions may make use of type wildcards.
A name that consists of only an initial {\tt T\$}
followed by one or more decimal digits is a type wildcard, that denotes
an arbitary type.  Thus the example:

\begin{indpar}\begin{verbatim}
function T$1 r = max ( T$1 x, T$1 y ):
    if x < y:
        r = y
    else:
        r = x

const x = 2e5
int y = 27e4
int z = max ( x, y )      // Converts x to int.
const w = 34e4
const v = max ( x, w )    // All values are const.
\end{verbatim}\end{indpar}

A wildcard type of a result variable gets its value from the
type of the result variable in a function call.  The exception
is {\tt const}, which can be a wildcard type in a function
definition if and only if all type wildcards in the function definition
are assigned the value {\tt const} and doing so makes
all types in the function definition be {\tt const}
(except for types that are not used as types, but are used as
{\tt const} values, as in `{\tt sizeof ( int )}').

Pointer types can be wildcards which must have names consisting
of an initial {\tt P\$} followed by one or more decimal digits.
An example is:

\begin{indpar}\begin{verbatim}
function uns r = strlen ( P$1 uns8 s ):
    dp uns8 sdp = s
    r = LIBC strlen ( sdp )
\end{verbatim}\end{indpar}

which converts the point of type {\tt P\$1} to a pointer of
type {\tt dp} (direct pointer) and calls the C programming
language subroutine {\tt LIBC strlen} with the direct pointer.

MINVAL does not necessarily make any use of registers, other
than as temporaries during the execution of a single statement,
and a pair of registers that hold the current function
execution frame address and current module data address.
However, registers can be used to cache data that exists in
RAM memory, or that should exist in RAM memory but does not
due to optimization.  We call such registers software
caches.

Software caches of a RAM memory location are flushed when an out-of-line
function is called if (1) the location is not in the currently
executing function frame, or (2) the location is part of a
section of the currently executing function frame to which
a pointer (direct, indirect, offset, etc.) has been computed.

In addition to having a type and optionally a pointer type,
variables may have qualifiers.  The only qualifiers are
{\tt ro} and {\tt vo}.

{\tt ro} variables are read-only and
cannot be written.  However, they may be writable by
code located elsewhere, so it cannot be assumed they will
never change.  Therefore the {\tt ro} qualifier does not
affect software cacheing.

{\tt vo} variables are volatile, and may be changed asynchronously
between any two reads of the variable.  {\tt vo} variables are
\underline{not} cached in software registers.

A pointer type of a variable
has two places where a qualifier may appear, as in

\begin{indpar}\begin{verbatim}
ro np vo uns32 p = .....
\end{verbatim}\end{indpar}
in which {\tt p} is a read-only variable pointing at a volatile
{\tt uns32} location.

Pointer types cannot be cascaded, but there is a work-around
using defined types:
\begin{indpar}\begin{verbatim}
np np flt64 p = .....         // Illegal!

struct my pointer
    np flt64 p

. . . . . . . . . .

my pointer p = ...            // OK
flt64 v = p.p[0]              // OK
\end{verbatim}\end{indpar}


\section{Syntax}

In this section we describe the syntax of MINVAL programs
and briefly indicate the associated semantics, which are
described in detain in the next section.

\subsection{Lexemes}
\label{LEXEMES}

A MINVAL source file is a sequence of bytes that is a UTF-8 encoding
of a sequence of UNICODE characters.  This is scanned into a sequence
of \skey{lexeme}s.

Unless otherwise specified, the term `\key{character}' in this
document means a 32-bit UNICODE character.

Lexemes are defined in terms of
the following character classes:

\begin{indpar}
\emkey{horizontal-space-character}
    \begin{tabular}[t]{rl}
    :::= & characters in UNICODE category \TT{Zs} \\
         & (includes {\em ASCII-single-space}) \\
    $|$  & {\em horizontal-tab-character}
    \end{tabular}
\\
\emkey{vertical-space-character}
    \begin{tabular}[t]{rl}
    :::= & {\em line-feed} $|$ {\em carriage-return} \\
    $|$ & {\em form-feed} $|$ {\em vertical-tab}
    \end{tabular}
\\
\emkey{space-character} :::= {\em horizontal-space-character}
                        $|$ {\em vertical-space-character}
\\[1ex]
\emkey{graphic-character} :::= characters in UNICODE categories
                              \TT{L}, \TT{M}, \TT{N}, \TT{P}, and \TT{S}
\\
\emkey{control-character} :::=
	characters in UNICODE categories \TT{C} and \TT{Z}
\\[1ex]
\emkey{isolated-separating-character} :::= \\
\hspace*{0.5in}
    \begin{tabular}[t]{l}
    characters in UNICODE categories \TT{Ps}, \TT{Pi}, \TT{Pe},
    and \TT{Pf}; \\
    includes \TT{\{ ( [ << >> ] ) \}}
    \end{tabular}
\\
\emkey{separating-character} :::= \TT{|} $|$ {\em isolated-separating-character}
\\[1ex]
\emkey{leading-separator-character} :::=
	\TT{`} $|$ \TT{\textexclamdown} $|$ \TT{\textquestiondown}
\\
\emkey{trailing-separator-character} :::=
	\TT{'} $|$ \TT{!} $|$ \TT{?} $|$ \TT{.} $|$ \TT{:}
	       $|$ \TT{,} $|$ \TT{;}
\\[1ex]
\emkey{quoting-character} :::= \TT{"}
\\[1ex]
\emkey{letter} :::=
    characters in UNICODE category \TT{L}
\\
\emkey{ASCII-digit} :::= \TT{0} $|$ \TT{1} $|$ \TT{2} $|$ \TT{3} $|$ \TT{4}
                     $|$ \TT{5} $|$ \TT{6} $|$ \TT{7} $|$ \TT{8} $|$ \TT{9}
\\
\emkey{digit} :::=
    characters in UNICODE category \TT{Nd}
    (includes {\em ASCII-digits})
\\
\emkey{lexical-item-character} :::=
	\begin{tabular}[t]{l}
        {\em graphic-character} other than \\
	{\em separating-character} or \TT{"}
	\end{tabular}
\end{indpar}

Comments may be placed at the ends of lines:
\begin{indpar}
\emkey{comment}\label{COMMENT} :::=
    \TT{//} {\em comment-character}\,$^\star$
\\[1ex]
\emkey{comment-character} :::= {\em graphic-character}
                          $|$ {\em horizontal-space-character}
\end{indpar}

Lexemes may be separated by {\em white-space}, which
is a sequence of {\em space-characters},
but, with some exceptions mentioned just below, is not itself a lexeme:
\begin{indpar}
\emkey{white-space} :::= {\em space-character}\PLUS{}
\\[0.3ex]
\emkey{horizontal-space} :::= {\em horizontal-space-character}\PLUS{}
\\[0.3ex]
\emkey{vertical-space} :::= {\em vertical-space-character}\PLUS{}
\end{indpar}

The following is a special virtual lexeme:
\begin{indpar}
\emkey{indent}\label{INDENT} ::=
        virtual lexeme inserted just before the first
	{\em graphic} character on a line
\end{indpar}

\ikey{Indent lexemes}{indent lexeme} have no characters, but
do have an \key{indent}, which is the indent of
the graphic character after the indent lexeme.
The \key{indent} of a character is the number
of columns that precede the character in the character's physical line.
A single space takes 1 column, and tabs are set every 8 columns.
Indent lexemes are used to form logical lines and blocks
(\itemref{LOGICAL-LINES-BLOCKS-AND-STATEMENTS}).

One kind of {\em vertical-space} is given special distinction:
\begin{indpar}
\emkey{line-break}\label{LINE-BREAK} ::=
	\begin{tabular}[t]{l}
        {\em vertical-space} containing exactly one {\em line-feed}
	\end{tabular}
\end{indpar}

This is the {\em line-break} lexeme.

{\em Horizontal-\EOL space-\EOL characters}\label{ILLEGAL-CHARACTERS}
other than single
space are illegal inside {\em quoted-string} lexemes (defined below).
{\em Vertical-space} that has \underline{no} {\em line-feeds} is
illegal (see below).
{\em Control-characters} not in {\em white-space} are illegal.
Characters that have no UNICODE category are {\em unrecognized-characters}
and are illegal:
\begin{indpar}
\emkey{misplaced-horizontal-space-character} :::= \\
\hspace*{0.5in}
    {\em horizontal-space-character}, other than ASCII-single-space
\\[0.3ex]
\emkey{misplaced-vertical-space-character} :::= \\
\hspace*{0.5in}{\em vertical-space-character} other than {\em line-feed}
\\[0.3ex]
\emkey{illegal-control-character} :::= \\
\hspace*{0.5in}
    \begin{tabular}[t]{l}
    {\em control-character},
    but \underline{not} a {\em horizontal-space-character} or \\
    {\em vertical-space-character}
    \end{tabular}
\\[0.3ex]
\emkey{unrecognized-character} :::= \\
\hspace*{0.5in}
    \begin{tabular}[t]{l}
    character with no UNICODE category or \\
    with a category other than
    \TT{L}, \TT{M}, \TT{N}, \TT{P}, \TT{S}, \TT{C}, or \TT{Z}
    \end{tabular}
\end{indpar}

Sequences of these characters generate warning messages,
but are otherwise like {\em horizontal-space}:
\begin{indpar}
\emkey{misplaced-horizontal} :::=
    {\em misplaced-horizontal-space-character}\PLUS{}
\\[0.3ex]
\emkey{misplaced-vertical} :::=
    {\em misplaced-vertical-space-character}\PLUS{}
\\[0.3ex]
\emkey{illegal-control} :::= {\em illegal-control-character}\PLUS{}
\\[0.3ex]
\emkey{unrecognized} :::= {\em unrecognized-character}\PLUS{}
\end{indpar}

{\em Misplaced-horizontal} only exists inside a {\em quoted-string},
but the other three sequences can appear anywhere.  When they occur,
these sequences generate warning messages, but otherwise they behave
like {\em horizontal-space}.  Specifically, outside {\em quoted-strings}
and {\em comments} these sequences can be used to separate other lexemes,
just as {\em horizontal-space} can be used,
whereas inside {\em quoted-strings} and
{\em comments} these sequences do nothing aside from generating
warning messages.

\begin{boxedfigure}[!p]
\begin{indpar}

\emkey{lexeme}
        \begin{tabular}[t]{rl}
	::= & {\em word} $|$ {\em mark} $|$ {\em number} $|$
	      {\em separator} $|$ {\em quoted-string} $|$ {\em indent} \\
	$|$ & {\em line-break} $|$
	      {\em comment} $|$ {\em end-of-file}
	\end{tabular}
\label{LEXEME}
\\[1ex]
\emkey{strict-separator} :::= {\em isolated-separating-character} $|$
                              \TT{|}\PLUS{}
\\[0.5ex]
\emkey{leading-separator} :::=
	\TT{`}\PLUS{} $|$ 
	\TT{\textexclamdown}\PLUS{} $|$ \TT{\textquestiondown}\PLUS{}
\\[0.5ex]
\emkey{trailing-separator} :::= \TT{'}\PLUS{} $|$
				   \TT{!}\PLUS{} $|$
				   \TT{?}\PLUS{} $|$
				   \TT{.}\PLUS{} $|$
				   \TT{:}\PLUS{} $|$
				   \TT{;} $|$
				   \TT{,}
\\[0.5ex]
\emkey{separator}
    ::= {\em strict-separator} 
    $|$ {\em leading-separator}
    $|$ {\em trailing-separator}
\\[1ex]
\emkey{quoted-string}\label{QUOTED-STRING} :::=
    \TT{"} {\em character-representative}\,\STAR{} \TT{"}
\\[0.3ex]
\emkey{character-representative}\label{CHARACTER-REPRESENTATIVE}
	\begin{tabular}[t]{@{}rl@{}}
	::= & {\em graphic-character} other than \TT{"} \\
	$|$ & {\em ASCII-single-space-character} \\
	$|$ & {\em special-character-representative} \\
	\end{tabular}
\\[0.3ex]
\emkey{special-character-representative} :::= \\
\hspace*{0.5in}
    \TT{<} \{ {\em ASCII-upper-case-letter} $|$ {\em ASCII-digit}
            \}\PLUS{} \TT{>}
\\[1ex]
\emkey{lexical-item} :::= {\em lexical-item-character}\PLUS{}
                       not beginning with \TT{//}
\\[0.5ex]
\emkey{lexical-item} :::= {\em leading-separator}\STAR{}
			  {\em middle-lexeme}\QMARK{}
                          {\em trailing-separator}\STAR{}
\\[0.5ex]
\emkey{middle-lexeme} :::= 
	{\em lexical-item}
	\begin{tabular}[t]{@{}l@{}}
	not beginning with a \\
	{\em leading-separator-character} \\
	or ending with a \\
	{\em trailing-separator-character} \\
	\end{tabular}
\\[0.5ex]
\emkey{number}
    ::= {\em middle-lexeme} with a {\em digit} before any {\em letter}
\\[0.5ex]
\emkey{natural-number}\label{NATURAL-NUMBER}
	:::= {\em ASCII-digit}\PLUS{} not beginning with \TT{0} $|$ \TT{0}
\\[0.5ex]
\emkey{word} :::= {\em middle-lexeme} containing a {\em letter} that is not
                  a {\em number}
\\[0.5ex]
\emkey{mark} :::= {\em middle-lexeme} that is not a {\em word} or
		  {\em number}
\\[0.5ex]
{\em indent} ::= see \pagref{INDENT}
\\[0.5ex]
{\em line-break} ::= see \pagref{LINE-BREAK}
\\[0.5ex]
{\em comment} ::= see \pagref{COMMENT}
\\[0.5ex]
{\em end-of-file} ::= see \pagref{END-OF-FILE}

\end{indpar}
\caption{MINVAL Program Lexemes}
\label{MINVAL-PROGRAM-LEXEMES}
\end{boxedfigure}

The lexemes in a MINVAL program are specified in
Figure~\itemref{MINVAL-PROGRAM-LEXEMES}.  This specification assumes there
are no illegal characters in the input; see page \pageref{ILLEGAL-CHARACTERS}
above to account for such characters.

The symbol `\ttkey{:::=}' is used in syntax equations
that define lexemes or parts of lexemes whose syntactic elements are
character sequences that must \underline{not} be separated by {\em white-space}.
The symbol `\ttkey{::=}'
is used in syntax equations that define sequences of lexemes that may
and sometimes must be separated by {\em white-space}.

There is a special \emkey{end-of-file}\label{END-OF-FILE}
lexeme that occurs only at the end of a file.

Files are scanned into sequences of lexemes which are then divided
into logical lines as per \itemref{LOGICAL-LINES-BLOCKS-AND-STATEMENTS}.
After each logical line is formed,
{\em indent}, {\em comment},
{\em line-break}, and {\em end-of-file} lexemes are deleted
from the logical line.

\ikey{Quoted string lexemes}{quoted strings!concatenated}
\label{QUOTED-STRING-CONCATENATION}
separated by the `\TT{\#}' mark
are glued together if they are in the
same logical line.  Thus
\begin{indpar}\begin{verbatim}
"This is a longer sentence" #
    " than we would like."
"And this is a second sentence."
\end{verbatim}\end{indpar}
is equivalent to
\begin{indpar}\begin{verbatim}
"This is a longer sentence than we would like."
"And this is a second sentence."
\end{verbatim}\end{indpar}
This is useful for
breaking long quoted string lexemes across line continuations.
But there is an important case where there is not an exact equivalence
between the glued and unglued versions.  \TT{"<" \# "LF" \# ">"} is
\underline{not} equivalent to \TT{"<LF>"}.  The former is a 4-character
quoted string, the characters being \TT{<}, \TT{L}, \TT{F},
and \TT{>}.  The latter is a 1-character quoted string, the character
being a line feed.

\ikey{Middle lexemes}{middle lexemes!glued}
in the same logical line are glued together if the first
ends with `\TT{\#}' and the second begins with `\TT{\#}'.
Thus
\begin{indpar}\begin{verbatim}
This is a continued-#
    #middle# #-lexeme.
\end{verbatim}\end{indpar}
is equivalent to
\begin{indpar}\begin{verbatim}
This is a continued-middle-lexeme.
\end{verbatim}\end{indpar}
For compatibility, two consequtive `\TT{\#}' marks may be used
to glue together two quoted strings, as in
\begin{indpar}\begin{verbatim}
"This is a continued-"#
    #"quoted"# #"-string".
\end{verbatim}\end{indpar}
which is equivalent to
\begin{indpar}\begin{verbatim}
"This is a continued-quoted-string".
\end{verbatim}\end{indpar}


A \emkey{special-character-representative} can consist of
a UNICODE character name surrounded by angle brackets.  Examples are
\TT{<NUL>}, \TT{<LF>}, \TT{<SP>}, \TT{<NBSP>}.  There are three other cases:
\tttkey{Q} represents the doublequote \TT{"}, \tttkey{NL} (new line)
represents a line feed (same as \TT{<LF>}), and \tttkey{UUC} represents
the `\key{unknown UNICODE character}' which in turn is used to represent
illegal UTF-8 character encodings.

A {\em special-character-representative} can also consist of
a hexadecimal UNICODE character code, which must begin with a digit.
Thus \TT{<0FF>} represents \TT{\"y} whereas \TT{<FF>} represents
a form feed.

The definition of a {\em middle-lexeme} is unusual: it is what is left over
after removing {\em leading-separators} and {\em trailing-separators}
from a {\em lexical-item}.  The lexical scan first scans a
{\em lexical-item}, and then removes
{\em leading-separators} and {\em trailing-separators} from it.
Also {\em trailing-separators} are removed
from the end of a {\em lexical-item} by a right-to-left scan, and not
the usual left-to-right scan which is used for everything else.
Thus the {\em lexical-item}
`\TT{\textquestiondown 4,987?,{},::}' yields the
{\em leading-separator} `\TT{\textquestiondown}',
the {\em middle-lexeme} `\TT{4,987}',
and the four {\em trailing-separators} `\TT{?}',
`\TT{,}' `\TT{,}' and `\TT{::}'.

\subsection{Logical Lines, Blocks, and Statements}
\label{LOGICAL-LINES-BLOCKS-AND-STATEMENTS}

Each non-blank physical line begins with an {\em indent} lexeme
that is followed by a
lexeme that is not an {\em indent}, {\em line-break}, or
{\em end-of-file}.

Lexemes are organized into \skey{logical line}s.  A logical line
begins immediately after an {\em indent} lexeme, and the
\key{indent} of the logical line is the
indent of this {\em indent} lexeme (i.e., the indent of the
first graphic character of the logical line).

A logical line ends with the next {\em indent} lexeme whose indent
is not greater than the indent of the logical line, or with an
{\em end-of-file}.  Thus physical
lines with indent greater than that of the current logical line
are \skey{continuation line}s for that logical line.

A code file is a sequence of `\key{top level}' logical lines that
are required to have indent \TT{0}.

A logical line may end with a \key{block} that is itself a sequence of
logical lines that have indents greater than the indent of the
logical line containing the block.
The block is introduced by a `\TT{:}' at the end
of a physical line, provided the `\TT{:}' is not inside brackets
or quotes
(e.g., not inside \TT{(~)} or \TT{`~'}).
If the first {\em indent} lexeme after the
`\TT{:}' has an indent that is \underline{not} greater than the indent
of the logical line containing the `\TT{:}', the block is empty.
Otherwise the indent of this {\em indent} lexeme becomes the
\key{indent} of the block and the indent of all the
logical lines in the block.  The first logical line of the block
starts immediately after this {\em indent} lexeme.
The block ends just before the first
logical line with lesser indent than the block indent, or the end of file.
More specifically, the last logical line of the block ends with an
{\em indent} whose indent is less than the block indent, or with an
{\em end-of-file}.

Examples are:
\begin{indpar}\begin{verbatim}
this is a top level logical line ending with a block:
    this is the first line of the block
    this is the
         second line of the block
    this is the third line of the block:
        this is the first line of a subblock
        this is the second line
                of the subblock:
            this is the only line of a sub-subblock
        this is the third line of the subblock
    this is the fourth line
            of the block:
        this is the only line of the second subblock
    this is the fifth line of the block
         and it ends with an empty subblock:
this is the second top level
     logical line
\end{verbatim}\end{indpar}

A warning message is output if two indents that are being compared
differ by more than \TT{0} and
less than \TT{2} columns, in order to better detect
indentation mistakes.

{\em Line-break} lexemes are effectively ignored.  A sequence
of {\em line-break} lexemes is followed by an {\em indent}
or {\em end-of-file} which is not ignored.
Blank physical lines are represented by sequences of
more than one {\em line-break} lexeme, and are effectively
ignored.

A logical line that contains {\em comments}, but no
lexemes other than {\em comments}, {\em line-breaks}, {\em indents}
and a possible {\em end-of-file}, is
a `\key{comment line}'.

It is an error to begin non-comment logical lines with
a {\em comment}.
{\em Comments} can be used freely in the middle of or at the
end of any logical line, or at the beginning of a comment line.

It is an error for the first logical line of a file
to have an indent that is greater than \TT{0}, the top level
indent.

It is an error for a block to be in the middle of a logical
line.  This means that the first {\em indent} following the
block must have an indent no greater than that of the logical
line containing the block.

Examples are:
\begin{indpar}\begin{verbatim}
// this is a logical line that is a single comment

// this is a logical line that has two
    // comments

this is a logical line // with a comment
     // and another comment
     with three comments // and a last comment

this is a logical line ending with a block:
     First line of the block
     Second line of the block
// Comment that ends block
// Comment that is in error because
    it begins a logical line that this continues

this is a logical line with a block:
     First line of the block
     Second line of the block
  but the block is in error because it is before
  this continuation of the logical line that contains
  the block

this is a logical line ending with a block:
        First line of the block
        Second line of the block
  // comments that end the block, but are in error,
  // because they continue the logical line
  // containing the block
\end{verbatim}\end{indpar}

After a logical line
has been formed, any {\em indent},
{\em comment}, {\em line-break}, and {\em end-of-file}
lexemes in the logical line
are removed from the logical line.  If the result is
empty, e.g., the logical line is a comment line, it is discarded.
Otherwise the
modified logical line becomes a MINVAL `\emkey{statement}'.

Therefore a file is a sequence of top-level statements.

Since a logical line can end with a block that itself consists
of a sequence of logical lines, a statement can end with
a block that itself consists of a sequence of statements.


\subsection{Expressions}

Expressions are built from operators, such as \TT{+} and \TT{*},
and primaries, such as variable names and function calls.

Operators are characterized by fixity, precedence, and format.
The MINVAL operators are listed in Table~\itemref{MINVAL-OPERATORS}.

\begin{boxedfigure}[!p]
\begin{center}
\begin{tabular}{|llllr|}
\hline
Operator & Meaning & Fixity & Format & Precedence \\
\hline
\ttkey{=} & assignment & infix & binary & L = 1 \\
\ttkey{+=} & increment & infix & binary & 1 \\
\ttkey{-=} & decrement & infix & binary & 1 \\
\hline
\ttkey{,} & separator & nofix & separating & 2 \\
\hline
\ttkey{else} & selection & infix & nomix & 3 \\
\hline
\ttkey{if} & condition & infix & binary & 4 \\
\hline
\ttkey{BUT NOT} & logical and not & infix & binary & 5 \\
\hline
\ttkey{AND} & logical and & infix & nomix & 6 \\
\ttkey{OR} & logical or & infix & nomix & 6 \\
\hline
\ttkey{NOT} & logical not & nofix & unary & 7 \\
\hline
\ttkey{==} & equal & infix & left associative & 8 \\
\ttkey{!=} & not equal & infix & left associative & 8 \\
\ttkey{<} & less than & infix & left associative & 8 \\
\ttkey{<=} & less than or equal & infix & left associative & 8 \\
\ttkey{>} & greater than & infix & left associative & 8 \\
\ttkey{>=} & greater than or equal & infix & left associative & 8 \\
\hline
\ttkey{+} & addition & infix & sum & 9 \\
\ttkey{-} & subtraction & infix & sum & 9 \\
\ttkey{|} & bitwise or & infix & nomix & 9 \\
\ttkey{\&} & bitwise and & infix & nomix & 9 \\
\ttkey{xor} & bitwise exclusive or & infix & nomix & 9 \\
\ttkey{<{}<} & left shift & infix & left associative & 9 \\
\ttkey{>{}>} & right shift & infix & left associative & 9 \\
\hline
\ttkey{/} & division & infix & binary & 10 \\
\ttkey{mod} & modulo & infix & binary & 10 \\
\ttkey{div} & divide and round toward zero & infix & binary & 10 \\
\ttkey{rem} & remainder of \TT{div} & infix & binary & 10 \\
\hline
\ttkey{*} & multiplication & infix & nomix & 11 \\
\hline
\ttkey{\textasciicircum} & exponentiation & infix & binary & H = 12 \\
\hline
\ttkey{+} & no operation & prefix & unary & \\
\ttkey{-} & sign change & prefix & unary & \\
\ttkey{!} & bitwise complement & prefix & unary & \\
\hline

\end{tabular}
\end{center}

\caption{MINVAL OPERATORS}
\label{MINVAL-OPERATORS}
\end{boxedfigure}

Given this, expressions have the following syntax,
where an {\em P-expression}
is an expression all of whose operators that are outside brackets
have precedence equal to or greater than P:

\begin{indpar}\begin{minipage}{6in}
\emkey{expression}\label{EXPRESSION} ::= {\em L-expression}
\\[0.5ex]
\emkey{N-expression}
    \begin{tabular}[t]{@{}rl}
    ::= & \{ {\em (N+1)-expression} $|$ {\em N-operator)} \}\PLUS{} \\
        & where no two {\em (N+1)-expressions} may be adjacent \\ 
        & and each {\em infix-N-operator} must be surrounded by \\
	& {\em (N+1)-expressions} \\
    \end{tabular}
\\[0.5ex]
\emkey{N-operator} ::= {\em nofix-N-operator} $|$ {\em infix-N-operator}
\\[0.5ex]
\emkey{nofix-N-operator} ::= nofix operator of precedence N
\\[0.5ex]
\emkey{infix-N-operator} ::= infix operator of precedence N
\\[0.5ex]
\emkey{(H+2)-expression}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em primary} \\
    $|$ & {\em prefix-operator} {\em (H+2)-expression} \\
    \end{tabular}
\\[0.5ex]
\emkey{primary} ::= {\em non-operator}\PLUS{}
\\[2.0ex]
\hspace*{3em}\begin{tabular}{l}
where N is any precedence in the range [L,H+1]
\end{tabular}
\end{minipage}\end{indpar}

Generally
a {\em P-expression} consists of a sequence of {\em (P+1)-expressions}
and operators of precedence $P$.

The operators in Figure \itemref{MINVAL-OPERATORS} have precedences in
the range {\em [L,H]}.
Precedence {\em (H+1)} is reserved for the `error operator' which is a
nofix operator inserted by the parser to `fix up' parsing errors
so parsing can continue.
An {\em (H+2)-expression}, while it can be thought of as a sequence
of zero or more prefix operators followed by a single {\em primary},
is parsed so as to execute the prefix operators from right to left, each
with a single operand.

An \key{infix} operator must be surrounded by operands,
but a \key{nofix} operator
may or may not have adjacent operands.  A \key{prefix} operator must be followed
by an operand, but must not be preceded by an operand.

A \key{binary} operator must be in an expression consisting of nothing
but two operands separated by an operator.
A \key{unary} operator must be in an expression consisting of nothing
but one operand preceded by an operator.
A \key{nomix} operator must be in an expression consisting of nothing
but operands and identical operators (e.g., \TT{AND} and \TT{OR}
cannot be outside parenthesized operands in the same expression).
The comparison operators are \key{left associative}, e.g.,
`\TT{x < y < z}' is the same as `\TT{(x < y) < z}'.
The \key{separating} format for the comma operator (`\TT{,}')
inserts special \TT{no-operand} primaries
into the expression so the separating operator becomes an infix
operator.  The \key{sum} format allows \TT{+} and \TT{-} to be mixed
in the same expression, but not other operators of the same
precedence.

The \TT{NOT} operator is odd in that it is nofix/unary instead of
prefix/unary.  This is done so it can have lower precedence than
the comparison operators, as prefix operators effectively have highest
precedence.

A statement that executes at run-time
can have only one non-prefix
operator that performs a computation on run-time values.
However arbitrary expressions computing with assembly-time {\tt const} values
may occur in any statement.

The following elaborates the meaning of some of the operators
that are used in these expressions:

\begin{indpar}
\begin{tabular}{rp{5.0in}}
\tt x \TT{if} y & evaluates to {\tt x} if {\tt y} evaluates to {\tt true},
                  and to {\tt no-operand} otherwise
\\[0.5ex]
\tt x \TT{else} y & evaluates to {\tt x} if that is not {\tt no-operand}
                  and to {\tt y} otherwise
\\[0.5ex]
\tt x \TT{<} y \TT{<} z & evaluates to {\tt (x < y) AND (y < z)} where
                  {\tt y} is evaluated only once, and similarly for
		  all comparison operators
\\[0.5ex]
\tt \TT{!} x & evaluates on signed integers as if they were represented
               in two's complement by binary values of unbounded size,
	       and similarly for other bitwise operators
\\[0.5ex]
\tt x \TT{\textasciicircum} y
	& becomes the function call {\tt x~"\textasciicircum"~y}; the
	  user has to provide the function called
\end{tabular}
\end{indpar}

Also the {\tt no-operand} value as if the operand did not exist
by nomix and sum operators.  I.e., it is treated as
0 by {\tt +}, {\tt -}, {\tt |}, {\tt xor},
as 1 by {\tt *},
as -1 by {\tt \&},
as {\tt true} by \TT{AND},
as {\tt false} by \TT{OR},
and as indicated above by {\tt else}.
Unary operators return {\tt no-operand} when their operand
has this value.

\subsection{Primaries}

A \key{primary} is an {\em expression} that has no operators:
\begin{indpar}
\emkey{primary}
    \begin{tabular}[t]{@{}rll}
    ::= & {\em constant}		& [\pagref{CONSTANTS}] \\
    $|$ & \TT{@}\QMARK{} {\em reference-expression}
                                        & [\pagref{REFERENCE-EXPRESSIONS}] \\
    $|$ & {\em function-call}		& [\pagref{FUNCTION-CALLS}] \\
    \end{tabular}
\end{indpar}

\subsubsection{Names}
\label{NAMES}

A \key{name} is a sequence of lexemes used to name things like
variables and functions.  Names are building blocks of primaries.

\begin{indpar}
\emkey{name}\label{NAME} ::=
    {\em initial-name-item} {\em continuing-name-item}\STAR{} \\
\emkey{initial-name-item} ::= {\em name-item} other than {\em natural-number} \\
\emkey{continuing-name-item} ::= {\em name-item} not containing `\TT{.}' \\
\emkey{name-item}\label{NAME-ITEM}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em word} containing no `\TT{.}' following a character
                     that is not a `\TT{.}' \\
        & [i.e., `\TT{.}'s can only be at the \underline{beginning}
	   of the {\em word}] \\
        & [see text about splitting words with embedded `\TT{.}'s] \\
    $|$ & {\em natural-number} \\
    $|$ & {\em quoted-mark} not containing `\TT{.}'s \\
    $|$ & {\em quoted-separator} not containing `\TT{.}'s \\
    \end{tabular} \\
\emkey{quoted-mark} :::= \TT{"} {\em mark} \TT{"} \\
\emkey{quoted-separator} :::= \TT{"} {\em separator} \TT{"}
\end{indpar}

{\em Words} containing embedded `\TT{.}'s are split into
{\em name-items} which contain `\TT{.}'s only at their beginning.
Thus
\begin{center}
\TT{bills.wife.1.weight..size}
\end{center}
is split into
\begin{center}
\TT{bills~~~.wife~~~.1~~~.weight~~~~..size}
\end{center}
However, `\TT{.1}' is not a legal {\em name-item} and so cannot
be part of a legal {\em name}.

Name items beginning with more than one `\TT{.}' are reserved
for use by systems and compilers (e.g., \TT{..size} in the example).
Name items that are words containing `\TT{\$}' or
beginning and ending with `\TT{*}' are
similarly reserved.  For example, words of the form `\TT{T\$$n$}'
for a natural number $n$ are reserved for use as type wildcards.

A name can abbreviate another name, using the statement:
\begin{indpar}
\emkey{abbreviation-statement} ::=
    {\em abbreviated-name} ~ \ABV{} ~ {\em abbreviation-name}
\end{indpar}
For example:
\begin{center}
\tt std bool \ABV{} bool
\end{center}

A name may begin with a {\em word} that is a {\em module-abbreviation}
that designates a code module: see~\itemref{MODULES}.
For example {\tt std} abbreviates the builtin standard module.

The MINVAL uses several kinds of names:

\begin{indpar}
\emkey{simple-name} ::= \TT{word} not containing any `\TT{.}'s \\
\emkey{module-abbreviation} ::= {\em simple-name} \\
\emkey{pointer-type-name}\label{POINTER-TYPE-NAME} ::=
    {\em simple-name}
\\[1ex]
\emkey{basic-name}
	::= \begin{tabular}[t]{@{}l@{}}
	    {\em name} not containing a `\TT{.}', {\em quoted-mark}, or
	    {\em quoted-separator}
	    \end{tabular} \\
\emkey{type-name}\label{TYPE-NAME} ::=
    {\em basic-name} \\
\emkey{variable-name}\label{VARIABLE-NAME} ::=
    {\em basic-name} \\
\emkey{statement-label} ::= {\em basic-name}
    \label{STATEMENT-LABEL} \\
\\[1ex]
\emkey{member-name}\label{MEMBER-NAME}
	::= \begin{tabular}[t]{@{}l@{}}
                        {\em name} beginning with a `\TT{.}', \\
			but not containing a {\em quoted-mark} or
			    {\em quoted-separator} \\
			(note: all `\TT{.}'s in a {\em name} must be at
			 the beginning of the {\em name})
			\end{tabular} \\
\emkey{label}\label{LABEL} ::=
    {\em basic-name} $|$ {\em member-name}
\\[1ex]
\emkey{function-term-name} ::= {\em name}
    \label{FUNCTION-TERM-NAME}
\\[1ex]
\emkey{qualifier-name}\label{QUALIFIER-NAME} ::=
    \ttkey{ro} $|$ \ttkey{vo}
\\[1ex]
\emkey{operator-name}
    \begin{tabular}[t]{rl}
    ::= & \TT{if} $|$ \TT{else}
                  $|$ \TT{xor} $|$ \TT{AND} $|$ \TT{OR}
		  $|$ \TT{NOT} $|$ \TT{BUT}  \\
    $|$ & \TT{mod} $|$ \TT{div} $|$ \TT{rem}
    \end{tabular}
\\[1ex]
\emkey{function-keyword}
    \begin{tabular}[t]{rl}
    ::= & \TT{no} $|$ \TT{not} $|$ \TT{function} $|$ \TT{generic} \\
    $|$ & \TT{"="} $|$ \TT{","} $|$ \TT{"("} $|$ \TT{")"} $|$
          \TT{"["} $|$ \TT{"]"}
    \end{tabular}
\\[1ex]
where the following rules should be followed, least there be
various confusing syntax or semantic errors:
\begin{enumerate}
\item
A {\em type-name} should not begin with a {\em module-abbreviation},
{\em qualifier-name}, or {\em pointer-type-name}.
\item
A {\em variable-name} should not begin with a {\em module-abbreviation},
{\em qualifier-name}, {\em pointer-type-name}, or {\em type-name}.
\item
A {\em function-term-name} should not begin with a {\em module-abbreviation}
or contain {\em function-keywords}.
\item
{\em Names} not used as operators should not contain {\em operator-names}.
\end{enumerate}
\end{indpar}

For example,
the parser treats a sequence of
names in certain contexts as having the form:
\begin{center}
\{\MA {\em pointer-type-name}\}\QMARK{}
\{\MA {\em type-name}\}\QMARK{}
\MA {\em variable-name}
\end{center}
where \MA denotes an optional {\em module-abbreviation},
and the parser does \underline{not} back up after idenfifying
one of the components of this sequence.

\subsubsection{Constants}
\label{CONSTANTS}

A \key{constant} is a value of type {\tt const} computed at
assembly time.  There are three kinds of constants:

\begin{indpar}
\emkey{constant}
    \begin{tabular}[t]{rl}
    ::= & {\em number-constant} \\
    $|$ & {\em string-constant} \\
    $|$ & {\em object-constant} \\
    \end{tabular} \\
\emkey{string-constant} ::= {\em quoted-string}
\end{indpar}

A \emkey{number-constant} is a {\em number} lexeme or sequence of
lexemes with specific syntax
that is used to denote a number.  Numbers are stored either
as unbounded integers, or as rational numbers whose numerator
and denominator are unbounded integers that have no common divisor
with the denominator being equal to or greater that 2.  The syntax is:

\begin{indpar}
\emkey{number-constant}\label{NUMBER-CONSTANT}
    \begin{tabular}[t]{@{}cl}
    ::= & {\em decimal-constant} \\
    $|$ & {\em binary-constant} \\
    $|$ & {\em hexadecimal-constant} \\
    $|$ & \TT{+Inf}\index{Inf@\TT{+Inf}}
          ~$|$~ \TT{-Inf}\index{Inf@\TT{-Inf}}
          ~$|$~ \ttkey{NaN}
    \end{tabular}
\\[0.5ex]
\emkey{sign} :::= \TT{+} $|$ \TT{-} \\
\emkey{exponent} :::=
	\{ \TT{e} $|$ \TT{E} \} {\em sign}\QMARK{} {\em dit}\PLUS{}
\\[0.5ex]
\emkey{decimal-constant} \begin{tabular}[t]{@{}rl@{}}
                         ::= & {\em decimal-lexeme} \\
			 $|$ & {\em decimal-constant-prefix} ~
			       {\em decimal-quoted-body} ~
			       {\em exponent}\QMARK{}
			 \end{tabular}
\\[0.5ex]
\emkey{decimal-lexeme} :::= {\em sign}\QMARK{} ~ {\em decimal-integer} ~
			    {\em decimal-fraction}\QMARK{} ~
                            {\em exponent}\QMARK{}
\\[0.5ex]
\emkey{decimal-constant-prefix} :::= {\em sign}\QMARK{} ~ \TT{D}
\\[0.5ex]
\emkey{decimal-quoted-body} :::= \TT{"} {\em decimal-integer} ~
				 {\em decimal-fraction}\QMARK{} \TT{"}
\\[0.5ex]
\emkey{decimal-integer}
    :::= {\em dit}\PLUS{} 
         \{ \TT{,} {\em dit} {\em dit} {\em dit} \}\STAR{} \\
\emkey{decimal-fraction} :::=
    \TT{.} \{ {\em dit} {\em dit} {\em dit} \TT{,} \}\STAR{}
           {\em dit}\PLUS{} \\
\emkey{dit}\label{DIT}
	:::= \TT{0} $|$ \TT{1} $|$ \TT{2} $|$ \TT{3} $|$ \TT{4}
                    $|$ \TT{5} $|$ \TT{6} $|$ \TT{7} $|$ \TT{8} $|$ \TT{9}
 \\[0.5ex]
\emkey{binary-constant} ::= {\em binary-constant-prefix} ~
                              {\em binary-quoted-body} ~
			      {\em exponent}\QMARK{}
\\[0.5ex]
\emkey{binary-constant-prefix} :::= {\em sign}\QMARK{} ~ \TT{B}
\\[0.5ex]
\emkey{binary-quoted-body} :::= \TT{"} {\em binary-integer} ~
				{\em binary-fraction}\QMARK{} \TT{"}
\\[0.5ex]
\emkey{binary-integer}
    :::= {\em bit}\PLUS{}
           \{ \TT{,} {\em bit} {\em bit} {\em bit} {\em bit} \}\STAR{} \\
\emkey{binary-fraction} :::=
    \TT{.} \{ {\em bit} {\em bit} {\em bit} {\em bit} \TT{,} \}\STAR{}
    {\em bit}\PLUS{} \\
\emkey{bit} :::= \TT{0} $|$ \TT{1}
 \\[0.5ex]
\emkey{hexadecimal-constant} ::= \\
\hspace*{0.5in}{\em hexadecimal-constant-prefix} ~
               {\em hexadecimal-quoted-body} ~
	       {\em exponent}\QMARK{}
\\[0.5ex]
\emkey{hexadecimal-constant-prefix} :::= {\em sign}\QMARK{} ~ \TT{X}
\\[0.5ex]
\emkey{hexadecimal-quoted-body} :::= \TT{"} {\em hexadecimal-integer} ~
				     {\em hexadecimal-fraction}\QMARK{} \TT{"}
\\[0.5ex]
\emkey{hexadecimal-integer}
    :::= {\em hit}\PLUS{}
           \{ \TT{,} {\em hit} {\em hit} \}\STAR{} \\
\emkey{hexadecimal-fraction} :::=
    \TT{.} \{ {\em hit} {\em hit} \TT{,} \}\STAR{}
    {\em hit}\PLUS{} \\
\emkey{hit} :::= \TT{0} $|$ \TT{1} $|$ \TT{2} $|$ \TT{3} $|$ \TT{4}
	     $|$ \TT{5} $|$ \TT{6} $|$ \TT{7} $|$ \TT{8} $|$ \TT{9}
	     $|$ \TT{a} $|$ \TT{b} $|$ \TT{c} $|$ \TT{d} $|$ \TT{e} $|$ \TT{f}
	     $|$ \TT{A} $|$ \TT{B} $|$ \TT{C} $|$ \TT{D} $|$ \TT{E} $|$ \TT{F}
\end{indpar}

The integer part of decimal constants may have commas
every 3 digits from the end and the fractional part may have
commas every 3 digits from the decimal point.
Similarly for binary integers and fractions with commas every 4 binary
digits,
and with hexa-decimal integers and fractions with commas every 2
hexa-decimal digits.
If there is a decimal point, there \underline{must}
be at least one integer digit and
one fraction digit.

\TT{NaN} denotes a canonical non-signaling NaN such
as that produced by hardware on the target machine
(\pagref{NAN}).
\TT{+Inf} denotes positive infinity; \TT{-Inf} denotes negative infinity.

A number constant may be converted to a run-time type such as {\tt int32}.
It is an assembly error to convert to an integer type that cannot
hold the exact value of the number constant.
Conversion to a run-time floating type, such as {\tt flt64}, is however
never an assembly error: if necessary the converted value is
{\tt +Inf} or {\tt -Inf}.

A \emkey{string-constant} is just a {\em quoted-string} lexeme
that denotes a character string: see
\pagref{QUOTED-STRING} and \pagref{QUOTED-STRING-CONCATENATION}.

String constants can be used to load run-time vectors
with {\tt uns8}, {\tt uns16}, or {\tt uns32} type elements.
UTf-8, UTF-16, or UTF-32 encodings are used according to element
size.

An \emkey{object-constant} has two parts, a list and a dictionary
(either or both can be empty).  Its syntax is:

\begin{indpar}
\emkey{object-constant}
    \begin{tabular}[t]{rl}
    ::= & \TT{\{} \TT{\}} \\
    $|$ & \TT{\{} {\em object-list} \TT{\}} \\
    $|$ & \TT{\{} {\em object-dictionary} \TT{\}} \\
    $|$ & \TT{\{} {\em object-list}\TT{,} {\em object-dictionary} \TT{\}} \\
    \end{tabular}
\\[0.5ex]
\emkey{object-list} ::= {\em constant} \{ \TT{,} {\em constant} \}\STAR{}
\\[0.5ex]
\emkey{object-dictionary} ::= {\em label-value-pair}
                              \{ \TT{,} {\em label-value-pair} \}\STAR{}
\\[0.5ex]
\emkey{label-value-pair} ::= {\em label} \TT{=>} {\em constant}
\\[0.5ex]
\emkey{label} ::= see \pagref{LABEL}
\end{indpar}

Objects \underline{cannot} be represented at run-time.

{\em Type-names} and {\em pointer-type-names} can be used at
assembly time as if they were variables of type {\tt const}
with object values.  These object values are partly read-only,
with the read-only part including elements with labels like
{\tt size} for the size in bits of run-time values of the type.
The user can add their own elements if these do not conflict
with the names of the read-only elements.  See \pagref{TYPE-OBJECTS}.

\subsubsection{Reference Expressions}
\label{REFERENCE-EXPRESSIONS}

A \emkey{reference-expression} names a location in memory.
The {\em reference-expression} by itself can be used to retrieve
the value of that location.  The {\em reference-expression}
preceeded by \TT{@} refers to the location, and not the value
at the location, and for run-time locations can be used to retrieve
a pointer to the location.  At assembly-time, only locations of
{\tt const} variables and object elements are defined, and there
are no pointers, but a {\tt const} variable can be given the
same location an object element with a given label.

The most basic {\em reference-expression} is the name of a variable
in the current function frame or current module memory.  Other
reference expressions are made by appending vector indices or structure
member names to more basic {\em reference-expressions}.  The syntax
is:

\begin{indpar}
\emkey{reference-expression}
    \begin{tabular}[t]{rl}
    ::= & {\em variable-name} \\
    $|$ & {\em reference-expression} \TT{[} {\em reference-index} \TT{]} \\
    $|$ & {\em reference-expression} {\em member-name} \\
    \end{tabular}
\\[0.5ex]
\emkey{reference-index}
    \begin{tabular}[t]{rl}
    ::= & {\em variable-name} \\
    $|$ & {\em expression} evaluating to a {\tt const} integer
    \end{tabular}
\\[0.5ex]
\emkey{variable-name} ::= see \pagref{VARIABLE-NAME}
\\[0.5ex]
\emkey{member-name} ::= see \pagref{MEMBER-NAME}
\\[0.5ex]
\emkey{expression} ::= see \pagref{EXPRESSION}
\end{indpar}

A {\em member-name} may be used to select a field or subfield
of a user defined type\pagnote{USER-DEFINED-TYPE} value referred
to by a {\em reference-expression}
to which the {\em member-name} is appended.

A {\em reference-index} may be used to select an element of a vector
pointed at by a pointer referred to by the
{\em reference-expression}
to which the {\em reference-index} is appended.  The index may be
positive or negative.  Bounds stored in the pointer are used to
check that the index is within range.

Inline functions may be defined that syntactically and semantically mimic
{\em reference-\EOL expres\-sions}, and calls to such functions
can be used as {\em reference-expressions}.  An example is:
\label{REFERENCE-EXPRESSION-FUNCTION-EXAMPLE}

\begin{indpar}\begin{verbatim}
// In my vector X, a vector with flt64 elements is located at
// X.offset from the address of X and allows index range
// from 0 through X.length-1.
//
type my vector:
    uns offset;
    uns length;
    . . . .
function flt64 @ x = ( my vector @ v ) [ uns index ]:
    np my vector vp = @ v
        // Get pointer to v.
    nv flt64 fp = *UNCHECKED* ( vp, 0, v.length )
        // Convert vp to a pointer to an flt64 vector fp.
        // The *UNCHECKED* function is a builtin function
        // that performs a variety of conversions which
        // violate type checking.
    @ x = @ fp[v.offset + index]
        // Return location of v.offset + index 'th element
        // of fp.
\end{verbatim}\end{indpar}

\subsubsection{Function Calls}
\label{FUNCTION-CALLS}

The syntax of function calls is:

\begin{indpar}
\emkey{function-call} ::= {\em module-abreviation}\QMARK{}
    	                  {\em call-argument-list}\STAR{}
                          {\em call-term} {\em call-term}\STAR{}
\\[0.5ex]
\emkey{call-term}
    \begin{tabular}[t]{rl}
    ::= & {\em call-term-name} {\em call-argument-list}\STAR{} \\
    $|$ & \ttkey{no} {\em call-term-name} \\
    $|$ & \ttkey{not} {\em call-term-name} \\
    \end{tabular}
\\[0.5ex]
\emkey{call-argument-list}
    \begin{tabular}[t]{rl}
    ::= & \TT{(} {\em actual-argument}
          \{ \TT{,} {\em actual-argument} \}\STAR{} \TT{)} \\
    $|$ & \TT{[} {\em actual-argument}
          \{ \TT{,} {\em actual-argument} \}\STAR{} \TT{]} \\
    $|$ & \TT{()} $|$ \TT{[]} \\
    $|$ & {\em unparenthesized-actual-argument} \\
    \end{tabular}
\\[0.5ex]
\emkey{actual-argument} ::= {\em expression}
\\[0.5ex]
\emkey{unparenthesized-actual-argument} ::=
    {\em constant} $|$ {\em reference-expression}
\\[0.5ex]
\emkey{call-term-name}\label{CALL-TERM-NAME} ::=
    \begin{tabular}[t]{@{}l}
    {\em function-term-name} with quotes removed from \\
    {\em quoted-marks} and {\em quoted-separators}
    \end{tabular}
\\[0.5ex]
\emkey{function-term-name} ::= see \pagref{FUNCTION-TERM-NAME}
\\[0.5ex]
\emkey{constant} ::= see \pagref{CONSTANTS}
\\[0.5ex]
\emkey{reference-expression} ::= see \pagref{REFERENCE-EXPRESSIONS}
\\[0.5ex]
\emkey{expression} ::= see \pagref{EXPRESSION}
\\[2.0ex]
NOTE: Two {\em unparenthesized-actual-arguments} cannot be consecutive.
\end{indpar}

Thus a {\em function-call} is a sequence of {\em function-term-names}
and {\em call-argument-lists}.

An {\em unparenthesized-actual-argument} is an {\em actual-argument}
{\tt X} that would normally be in parentheses as {\tt (X)} but the
parentheses have been omitted.  Thus given the example function definition
on page \pageref{REFERENCE-EXPRESSION-FUNCTION-EXAMPLE},
{\tt (v)[i]} may be written as {\tt v[i]}.  Only {\tt (~)}'s may be
omitted, and then only if they surround exactly one {\em actual-argument}
that is a {\em constant} or {\em reference-expression}.

{\em Call-terms} of the form `{\tt no x}' and `{\tt not x}' are
equivalent to `{x ( false )}'.

{\em Function-calls} are matched to function prototypes.  The
{\em call-term-names} in a match are identical to the
{\em function-term-names} taken from the prototype being matched.  The first
step in matching is to scan the {\em function-call} to identify the
{\em call-term-names}.  There is no parser backing up after this is
done: if the results of this initial scan do not lead to a satisfying
match, the entire call/prototype match fails.  Therefore caution
is necessary in omitting parentheses around
{\em unparenthesized-actual-arguments} when these share lexemes with
{\em function-term-names} in some function prototypes.

\subsection{Assembly Time}
\label{ASSEMBLY-TIME}

Variables and values that exist during assembly are called
\key{assembly-time}, while variables and values that exist during
program execution are called {\em run-time}.  Assembly-time
is actually an important syntactic concept, as run-time
{\em expressions} cannot contain more than one non-prefix operator
and are only allowed prefix operators with limitations.

Syntactically \key{assembly-time} is defined as follows:

\begin{itemize}
\item A variable (i.e., {\em variable-name})
is assembly-time if and only if it is of type {\tt const}.
(Assembly-time variables do \underline{not} exist at run-time.)
\item A {\em constant} is assembly-time.
\item A {\em type-name} and a {\em pointer-type-name} are assembly-time
and denote object constants describing the type or pointer type.
(At run-time these are {\tt int} values used to distinguish types.)
\item An {\em expression} with a lowest precedence operator is
      assembly-time if this operator and its operands are assembly-time.
      All the standard operators are assembly-time except exponentiation
      ({\tt \textasciicircum}) which denotes a function call.
\item A {\em function-call} is assembly-time if and only if all its
      arguments are assembly-time and the function called is
      assembly-time.
\item A user-defined function is assembly-time if and only if all its
      result and argument variables are assembly-time (i.e., have
      {\tt const} type) and all its
      {\em statements} are assembly-time.
\item Some builtin functions are specified as being assembly-time.
\item A {\em statement} is assembly-time if and only if all its
      variables and expressions are assem\-bly-time.
\end{itemize}

A \key{run-time} {\em expression} or {\em statement}
is an {\em expression} or {\em statement} that is
\underline{not} assembly-time.

\subsection{Statements}
\label{STATEMENTS}

The following is a complete list of the kinds of statements:
\begin{indpar}
\emkey{statement}\label{STATEMENT}
    \begin{tabular}[t]{@{}rll}
    ::= & {\em assignment-statement}
        & [\pagref{ASSIGNMENT-STATEMENTS}] \\
    $|$ & {\em declaration}
        & [\pagref{DECLARATIONS}] \\
    $|$ & {\em include-statement}
        & [\pagref{INCLUDE-STATEMENTS}] \\
    \end{tabular}
\end{indpar}

\subsubsection{Assignment Statements}
\label{ASSIGNMENT-STATEMENTS}

{\em Assignment-statements} have a list of variables on the
left side which receive values from a list of expressions or
a block of code on the right side.  The left-side variables
may be omitted if the values are not needed and the right side
is just a {\em function-call}.  In some cases
the right side produces no values, though the right side is never omitted.

The general form of an {\em assignment-statement} is:
\begin{indpar}
\emkey{assignment-statement} ::= \\
\hspace*{0.5in} \{ {\em assignment-left-side} \TT{=} \}\QMARK{}
	      {\em assignment-right-side}
\\[0.5ex]
\emkey{assignment-left-side} ::= \\
\hspace*{0.5in}
    \{ {\em assignment-secondary-result} \TT{,} \}\STAR{}
    {\em assignment-primary-result}
\\[0.5ex]
\emkey{assignment-secondary-result} ::= {\em assignment-result} \\
\emkey{assignment-primary-result} ::= {\em assignment-result}
\\[0.5ex]
\emkey{assignment-result}
    \begin{tabular}[t]{@{}rll}
    ::= & {\em result-variable-declaration} \\
    $|$ & {\em next-variable-declaration} \\
    $|$ & {\em reference-expression}
    		& [see \pagref{REFERENCE-EXPRESSIONS}] \\
    $|$ & {\em deferred-variable}
    		& [see \pagref{DEFERRED-VARIABLE}] \\
    $|$ & {\em iteration-variable}
    		& [see \pagref{ITERATION-VARIABLE}] \\
    \end{tabular}
\\[0.5ex]
\emkey{result-variable-declaration}\label{RESULT-VARIABLE-DECLARATION} ::= \\
\hspace*{0.5in}
        \{ {\em qualifier-name}\STAR{} {\em pointer-type-name} \}\QMARK{} \\
\hspace*{1.0in}
        {\em qualifier-name}\STAR{} {\em type-name}
        \TT{@}\QMARK{} {\em variable-name}
\\[0.5ex]
\emkey{next-variable-declaration}\label{NEXT-VARIABLE-DECLARATION}
    ::= \ttkey{next} \TT{@}\QMARK{} {\em variable-name}
\\[0.5ex]
\emkey{qualifier-name} ::= see \pagref{QUALIFIER-NAME}
\\[0.5ex]
\emkey{pointer-type-name} ::= see \pagref{POINTER-TYPE-NAME}
\\[0.5ex]
\emkey{type-name} ::= see \pagref{TYPE-NAME}
\\[0.5ex]
\emkey{variable-name} ::= see \pagref{VARIABLE-NAME}
\\[0.5ex]
\emkey{assignment-right-side}\label{ASSIGNMENT-RIGHT-SIDE} ::= \\
\hspace*{1in}
    \begin{tabular}[t]{@{}rll}
        & {\em expression-list}
    		& [see \pagref{EXPRESSION-LIST}] \\
    $|$ & {\em function-call}
    		& [see \pagref{FUNCTION-CALLS}] \\
    $|$ & {\em block}
	        & [see kinds of assignment statement below] \\
    \end{tabular}
\end{indpar}

The following are the different kinds of {\em assignment-statements}:
\begin{indpar}
\emkey{assignment-statement}
    \begin{tabular}[t]{@{}rll}
    ::= & {\em expression-assignment-statement}
    	& [\pagref{EXPRESSION-ASSIGNMENT-STATEMENTS}] \\
    $|$ & {\em block-assignment-statement}
        & [\pagref{BLOCK-ASSIGNMENT-STATEMENTS}] \\
    $|$ & {\em conditional-assignment-statement}
        & [\pagref{CONDITIONAL-ASSIGNMENT-STATEMENTS}] \\
    $|$ & {\em loop-assignment-statement}
        & [\pagref{LOOP-ASSIGNMENT-STATEMENTS}] \\
    \end{tabular}
\end{indpar}


Given a variable {\tt x}, the variable name {\tt x} refers to the
value of the variable while {\tt @ x} refers to the location of
the value of {\tt x }.
Thus an example using {\em assignment-operators} is:
\begin{indpar}\begin{verbatim}
int x = 5
int @ y = @ x  // Now x and y have the same locations.
y = 6          // Now x and y both = 6.
np int z = @ x // Now z points at x.
int @ w = z    // Now location of w is that pointed at by z.
w = 7          // Now w, x, and y all = 7.
\end{verbatim}\end{indpar}

There are no assembly-time pointers, i.e., pointers to {\em const} values,
so if {\tt int} were replaced by {\tt const} in this example
it would not be possible to compute {\tt y}, {\tt z}, or {\tt w}.

\subsubsubsection{Expression Assignment Statements}
\label{EXPRESSION-ASSIGNMENT-STATEMENTS}

The syntax of an {\em expression-assign\-ment-statement} is:
\begin{indpar}
\emkey{expression-assignment-statement} ::=
    {\em assignment-left-side} ~\TT{=}~ {\em expression-list}
\\[0.5ex]
\emkey{expression-list}\label{EXPRESSION-LIST} ::=
	      {\em expression} \{ \TT{,} {\em expression} \}\STAR{}
\\[2.0ex]
where
\begin{itemize}
\item If there is more than one right-side {\em expression},
the number of right-side {\em expressions} must equal the number
of left-side {\em assignment-results}.
\item For run-time {\em expression-assignment-statements}, if
there is \underline{more than one} right-side {\em expression}, all these
{\em expressions} must be {\em reference-expressions} or
assembly-time {\em expressions} (i.e., operators and
{\em function-calls} are not allowed outside assem\-bly-time
{\em expressions}).
\item For run-time {\em expression-assignment-statements} with
a \underline{single} right-side {\em expression}, this {\em expression}
may be any run-time {\em expression}.
\end{itemize}
\end{indpar}

All the locations that are needed are evaluated first, then any right
side operators are evaluated, then the right-side values are stored
in the left-side locations.

If the right-side is a single {\em function-call},
this may return more than one result, and must return
at least as many results as there are {\em assignment-results}.

Note that you can assign to a variable location but not a
{\em reference-expression} location.  For example, `{\tt int @ x = \ldots}'
is allowed but `{\tt int @ x[2] = \ldots}' is not.



\subsubsubsection{Block Assignment Statements}
\label{BLOCK-ASSIGNMENT-STATEMENTS}

The syntax of {\em block-assignment-statements} is:

\begin{indpar}
\emkey{block-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em assignment-left-side} \TT{=} \}\QMARK{}
	~ \{ \ttkey{do} {\em block-label}\QMARK{} \}\QMARK{}
	\TT{:} \\
	\TT{~~~~}{\em statement}\STAR{} \\
	\TT{~~~~}{\em exit-subblock}\STAR{}
	\end{tabular} \\
\emkey{block-label} ::= {\em statement-label}
\\[0.5ex]
\emkey{exit-subblock} ::=
    \begin{tabular}[t]{l}
    {\em exit-label} \ttkey{exit}\TT{:} \\
    \TT{~~~~}{\em statement}\STAR{} \\
    \end{tabular} \\
\emkey{exit-label} ::= {\em statement-label}
\\[0.5ex]
\emkey{statement-label} ::= see \pagref{STATEMENT-LABEL} \\
\emkey{statement} ::= see \pagref{STATEMENT} \\
\\[1ex]
where
\begin{itemize}
\item The {\tt =} and {\tt do} cannot \underline{both} be omitted.
\item The {\em assignment-left-side} may \underline{not} contain
{\em reference-expressions}.
\end{itemize}
\end{indpar}

The result variables of a {\em block-assignment-statement}
are given values by the {\em statements} within the block
of the {\em block-assignment-statement} using {\em deferred-variable}
names:
\begin{indpar}
\emkey{deferred-variable}\label{DEFERRED-VARIABLE} ::=
    \TT{next}\QMARK{} \TT{next}\QMARK{} \TT{@}\QMARK{} {\em variable-name}
\end{indpar}
A {\em deferred-variable} is just a copy of one of the
block's {\em assignment-results} with any {\em qualifiers}
and {\em types} omitted (these are inferred within the block
from the associated {\em assignment-result}).  An example is:
\begin{indpar}\begin{verbatim}
int x = 5
int @ y, int z =:
    @ y = @x
    y = 6
    z = 7
    int k = 8
int w = x      // Now w = 6.
int u = z      // Now u = 7
// k is not visible here
\end{verbatim}\end{indpar}

There are scoping rules that prevent {\tt k} from being visible
outside the block in which it is defined, and would also
prevent the location of {\tt k} from being stored in {\tt @ y}.
see \itemref{SCOPING}.

A {\em go-to-exit-statement} within a block may exit the block or
enter an {\em exit-subblock} of the block:
\begin{indpar}
\emkey{go-to-exit-statement}\label{GO-TO-STATEMENT} ::=
    \{ \TT{if} {\em condition-expression} \}\QMARK{}
    \ttkey{go to} {\em go-to-label} \TT{exit}
\\[0.5ex]
\emkey{go-to-label} ::= {\em block-label} $|$ {\em exit-label}
\\[0.5ex]
{\em condition-expression} ::=
    \begin{tabular}[t]{@{}l}
    {\em expression} evaluating at run-time to a {\tt bool} \\
    or at assembly-time to the {\em const} value {\tt "TRUE"} or {\tt "FALSE"}
    \end{tabular}
\end{indpar}

Unless a {\em go-to-exit-statement} is executed,
a block exits after the last {\em statement} in the block,
and an {\em exit-subblock} exits its containing block after the last
{\em statement} in the {\em exit-subblock}.
A {\em go-to-exit-statement} in a subblock may only enter
a \underline{subsequent} {\em exit-subblock}.  There are
variable scoping requirements that must be met when using
{\em go-to-exit-statements}; roughly, a variable declared within
the block is only visible to statements that can be
arrived at only by execution paths that include the variable's
declaration.  See \itemref{SCOPING} for details.


\subsubsubsection{Conditional Assignment Statements}
\label{CONDITIONAL-ASSIGNMENT-STATEMENTS}

A {\em conditional-assignment-statement}
is syntactic sugar for a {\em block-assignment-statement}
with conditional {\em go-to-exit-statements}
and {\em exit-subblocks} (\itemref{BLOCK-ASSIGNMENT-STATEMENTS}).
{\em Conditional-assignment-statements} have the syntax:

\begin{indpar}
\emkey{conditional-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em assignment-left-side} \TT{=} \}\QMARK{} \ttkey{if}\TT{:} \\
	\TT{~~~~}{\em condition-expression}\TT{:} \\
	\TT{~~~~~~~~~}{\em statement}\STAR{} \\
	\TT{~~~~}{\em condition-expression}\TT{:} \\
	\TT{~~~~~~~~~}{\em statement}\STAR{} \\
	\TT{~~~~}\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots \\
	\TT{~~~~}\ttkey{else}\TT{:} \\
	\TT{~~~~~~~~~}{\em statement}\STAR{} \\
	\TT{~~~~}{\em exit subblock}\STAR{}
	\end{tabular}
\end{indpar}

An example is:
\begin{indpar}\begin{verbatim}
int x = 5
int y = 6
int z = if:
    x < y:
        z = y    // Sets z = 6
    else:
        z = x    // Is NOT executed
// Now z = 6
\end{verbatim}\end{indpar}
in which the {\em conditional-assignment-statement} is equivalent to:
\begin{indpar}\begin{verbatim}
int z =:
    if x < y go to E exit   // goes to E exit
    z = x        // Is NOT executed
    E exit:
        z = y    // Sets z = 6
// Now z = 6
\end{verbatim}\end{indpar}

\subsubsubsection{Loop Assignment Statements}
\label{LOOP-ASSIGNMENT-STATEMENTS}

A {\em loop-assignment-statement} has the syntax:

\begin{indpar}
\emkey{loop-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ {\em assignment-left-side} \TT{=} \}\QMARK{} \ttkey{loop}\TT{:} \\
	\TT{~~~~}{\em initialization-subblock}\QMARK{} \\
	\TT{~~~~}{\em iteration-subblock} \\
	\TT{~~~~}{\em finalization-subblock}\QMARK{} \\
	\end{tabular}
\\[0.5ex]
\emkey{initialization-subblock} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \ttkey{initially}\TT{:} \\
	\TT{~~~~}{\em iteration-variable-assignment-statement}\PLUS{} \\
	\end{tabular} \\
\emkey{iteration-variable-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
	{\em assignment-statement} with one or more \\
	{\em iteration-variable-declarations} and nothing else on its left-side
	\end{tabular} \\
\emkey{iteration-variable-declaration}
    \begin{tabular}[t]{rl}
    ::= & {\em result-variable-declaration} \\
    $|$ & \TT{next} \TT{@}\QMARK{} {\em variable-name} \\
    $|$ & \TT{next} \TT{next} \TT{@}\QMARK{} {\em variable-name} \\
    \end{tabular} \\
{\em result-variable-declaration} ::=
    see \pagref{RESULT-VARIABLE-DECLARATION}
\\[0.5ex]
\emkey{loop-variable} ::= variable declared by a
			{\em result-variable-declaration}
\\[0.5ex]
\emkey{iteration-variable}\label{ITERATION-VARIABLE} ::= 
    \TT{next} \TT{next}\QMARK{} \TT{@}\QMARK{} {\em variable-name}
\\[0.5ex]
\emkey{iteration-subblock} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \{ \ttkey{while} $|$ \ttkey{until} \}
	    {\em condition-expression} \TT{:} \\
	\TT{~~~~}{\em statement}\STAR{} \\
	\TT{~~~~}{\em exit-subblock}\STAR{} \\
	\end{tabular}
\\[0.5ex]
\emkey{finalization-subblock} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{l}
        \ttkey{finally}\TT{:} \\
	\TT{~~~~}{\em statement}\STAR{} \\
	\TT{~~~~}{\em exit-subblock}\STAR{} \\
	\end{tabular}
\end{indpar}

The {\em initialization-subblock} declares the \skey{loop variable}s
of the loop and gives them initial values.  The {\em iteration-block}
then executes repeatedly updating these loop variables.  The
{\em assignment-result} `{\tt next X}' can be used on the left-side of
an assignment statement to assign the value that loop variable
{\tt X} will have in the next iteration.
It can also be used in the {\em initialization-subblock}
to assign the value of {\tt X} in the second iteration, in which case
`{\tt next next X}' can be used in the {\em iteration-subblock}
to assign {\tt X}'s value in the second iteration after the current
iteration.  After the last iteration, the {\em finalization-subblock}
executes and must set the variables in the {\em loop-assignment-statement}'s
left-side.

An example is:
\begin{indpar}\begin{verbatim}
// Calculate the sum of i for i == 1 to i == n.
//
int64 n = . . .
int64 sum = loop:
    initially:
        int64 i = 1
        int64 partial sum = 0
    while i <= n:
        next partial sum = partial sum + i
        next i = i + 1
    finally:
        sum = partial sum
\end{verbatim}\end{indpar}

\subsubsection{Declarations}
\label{DECLARATIONS}

The following is a complete list of the kinds of declarations:
\begin{indpar}
\emkey{declaration}\label{DECLARATION}
    \begin{tabular}[t]{@{}rll}
    ::= & {\em type-declaration}
        & [\pagref{TYPE-DECLARATIONS}] \\
    $|$ & {\em inline-function-declaration}
        & [\pagref{INLINE-FUNCTION-DECLARATIONS}] \\
    $|$ & {\em out-of-line-function-declaration}
        & [\pagref{OUT-OF-LINE-FUNCTION-DECLARATIONS}] \\
    \end{tabular}
\end{indpar}

\subsubsubsection{Type Declarations}
\label{TYPE-DECLARATIONS}

The syntax of a type declaration is:

\begin{indpar}
\emkey{type-declaration}\label{TYPE-DECLARATION}
    ::= \begin{tabular}[t]{l}
        \ttkey{type} {\em defined-type-name} \TT{:} \\
	\TT{~~~~~}{\em type-subdeclaration}\STAR{}
	\end{tabular} \\
\emkey{defined-type-name} ::= {\em type-name} \\
\emkey{type-name} ::= see \pagref{TYPE-NAME}
\\[2ex]
\emkey{type-subdeclaration}
    \begin{tabular}[t]{@{}rl}
    ::= &  {\em field-declaration} \\
    $|$ &  \ttkey{align} {\em alignment}\QMARK{} \\
    $|$ &  \ttkey{pack} \\
    $|$ &  \ttkey{label} {\em field-label} \\
    $|$ &  \ttkey{origin} {\em field-label} \\
    $|$ &  \ttkey{include} {\em defined-type-name} \\
    \end{tabular}
\\[2ex]
\emkey{field-declaration}
    \begin{tabular}[t]{@{}rl}
    ::= &  {\em field-type-name} {\em field-label} \\
    $|$ &  {\em number-type-name} {\em field-label}\QMARK{} \\
	&  {\em subfield-declaration}\STAR{}
    \end{tabular}
\\[2ex]
\emkey{field-type-name} ::= {\em number-type-name}
                        $|$ {\em defined-type-name} \\
\emkey{number-type-name}
    \begin{tabular}[t]{@{}rl}
    ::= &  \ttkey{int} $|$ \ttkey{int8} $|$ \ttkey{int16} $|$ \ttkey{int32}
                       $|$ \ttkey{int64} $|$ \ttkey{int128} \\
    $|$ &  \ttkey{uns} $|$ \ttkey{uns8} $|$ \ttkey{uns16} $|$ \ttkey{uns32}
                       $|$ \ttkey{uns64} $|$ \ttkey{uns128} \\
    $|$ &  \ttkey{flt16} $|$ \ttkey{flt32} $|$ \ttkey{flt64}
                         $|$ \ttkey{flt128} \\
    $|$ &  \ttkey{bool}
    \end{tabular}
\\[2ex]
\emkey{field-label} ::=  {\em label} \\
\emkey{label} ::=  see \pagref{LABEL}
\\[2ex]
\emkey{subfield-declaration}
    ::= {\em bit-range} {\em number-type-name} {\em subfield-label} \\
\emkey{subfield-label} ::=  {\em label}
\\[2ex]
\emkey{bit-range}
    \begin{tabular}[t]{@{}rl}
    ::= &  \TT{[} {\em onlybit} \TT{]} \\
    $|$ &  \TT{[} {\em lowhighbits} \TT{]} \\
    $|$ &  \TT{[} {\em lowbit} \TT{-} {\em highbit} \TT{]}
    \end{tabular} \\
\emkey{onlybit} ::= assembly-time {\em expression} \\
\emkey{lowhighbits} :::= {\em dit}+ \TT{-} {\em dit}+
           ~~~~~ [this is a single lexeme] \\
\emkey{lowbit} ::= assembly-time {\em expression} \\
\emkey{highbit} ::= assembly-time {\em expression} \\
\emkey{dit} ::= see \pagref{DIT}
\end{indpar}

\subsubsubsection{Inline Function Declarations}
\label{INLINE-FUNCTION-DECLARATIONS}

The syntax of a function declaration is:

\begin{indpar}
\emkey{function-declaration}\label{FUNCTION-DECLARATION}
    ::= \begin{tabular}[t]{l}
        {\em function-prototype} \TT{:} \\
	\TT{~~~~~}{\em statement}\PLUS{}
	\end{tabular}
\\[2ex]
\emkey{function-prototype}\label{FUNCTION-PROTOTYPE}
    \begin{tabular}[t]{@{}rl}
    ::= & \ttkey{function} ~
          {\em prototype-result-list} ~ \TT{=} \\
        & \TT{~~~~~}{\em module-abbreviation}\QMARK{}
	                ~ {\em prototype-pattern} \\
    $|$ & \ttkey{function} ~ {\em module-abbreviation}\QMARK{}
                           ~ {\em prototype-pattern} \\
    $|$ & \ttkey{function} ~ {\em module-abbreviation}\QMARK{}
                           ~ {\em prototype-pattern} ~ \TT{=} \\
        & \TT{~~~~~}{\em input-variable-list} \\
    \end{tabular}
\\[0.5ex]
\emkey{prototype-result-list} ::= \\
\hspace*{0.5in}
    {\em prototype-result-declaration}
    \{ \TT{,} {\em prototype-result-declaration} \}\STAR{}
\\[0.5ex]
\emkey{prototype-result-declaration} \\
\hspace*{1in}\begin{tabular}[t]{rl}
    ::= & {\em qualifier-name}\STAR{} ~
          {\em type-name} ~ \TT{@}\QMARK{} ~ {\em variable-name} \\
    $|$ & \ttkey{next} \TT{@}\QMARK{} {\em variable-name} \\
    \end{tabular}
\\[0.5ex]
{\em module-abbreviation} ::= see \pagref{MODULE-ABBREVIATION}
\\[0.5ex]
\emkey{qualifier-name} ::= see \pagref{QUALIFIER-NAME}
\\[0.5ex]
{\em type-name} ::= see \pagref{TYPE-NAME}
\\[0.5ex]
{\em variable-name} ::= see \pagref{VARIABLE-NAME}
\\[0.5ex]
\emkey{input-variable-list}
    ::= {\em argument-declaration}
                 \{ \TT{,} {\em argument-declaration} \}\STAR{}
\\[0.5ex]
\emkey{argument-declaration}\label{ARGUMENT-DECLARATION} \\
\hspace*{1in}\begin{tabular}[t]{@{}rl@{}}
    ::= & {\em qualifier-name}\STAR{} {\em type-name}
          \TT{@}\QMARK{} {\em variable-name} \\
    $|$ & {\em qualifier-name}\STAR{} {\em type-name}
          \TT{@}\QMARK{} {\em variable-name}
          \TT{?=} {\em default-value} \\
    $|$ & {\em qualifier-name}\STAR{} \TT{bool}
          {\em variable-name} \\
    $|$ & {\em qualifier-name}\STAR{} \TT{bool}
          {\em variable-name}
          \TT{??} {\em default-value} \\
    $|$ & {\em qualifier-name}\STAR{} {\em type-name}
          \TT{@}\QMARK{} {\em variable-name}
          \TT{==} {\em required-value} \\
    \end{tabular}
\\[0.5ex]
\emkey{default-value} ::= {\em expression}
\\[0.5ex]
\emkey{required-value} ::= assembly-time {\em expression}
\\[0.5ex]
{\em expression} ::= see \pagref{EXPRESSION}
\\[0.5ex]
\emkey{prototype-pattern}\label{FUNCTION-PATTERN}
    \begin{tabular}[t]{rl}
    ::= & {\em first-pattern-term} ~ {\em pattern-term}\STAR{} \\
    ::= & {\em only-pattern-term} \\
    $|$ & {\em pattern-argument-list} {\em pattern-argument-list}\PLUS{}
    \end{tabular}
\\[0.5ex]
\emkey{first-pattern-term} ::= {\em pattern-argument-list}\STAR{} ~
				{\em pattern-term}
\\[0.5ex]
\emkey{only-pattern-term} ::= \\
\hspace*{1in}{\em pattern-argument-list}\STAR{} ~
				{\em pattern-term} ~
			      {\em pattern-argument-list}\STAR{}
\\[0.5ex]
\emkey{pattern-term}
    ::= {\em function-term-name} ~ {\em pattern-argument-list}\STAR{}
\\[0.5ex]
\emkey{function-term-name} ::= see \pagref{FUNCTION-TERM-NAME}
\\[0.5ex]
\emkey{function-variable-name}\label{FUNCTION-VARIABLE-NAME} ::= \\
\hspace*{1in}
    \begin{tabular}[t]{@{}p{5in}@{}}
    {\em function-term-name} $N$ that appears in a {\em function-prototype}
    of the form `{\tt function $N$ = \ldots}'
    \end{tabular}
\\[0.5ex]
\emkey{pattern-argument-list} \\
\hspace*{1in}
    \begin{tabular}[t]{@{}rl}
    ::= & \TT{(} {\em argument-declaration}
                 \{ \TT{,} {\em argument-declaration} \}\STAR{} \TT{)} \\
    $|$ & \TT{[} {\em argument-declaration}
                 \{ \TT{,} {\em argument-declaration} \}\STAR{} \TT{]} \\
    \end{tabular}
\begin{itemize}
\item
A {\em prototype-pattern} or {\em function-call}
must have either a {\em function-term-name}
or at least two {\em argu\-ment-lists}.
\item
A {\em prototype-pattern} {\em function-term-name} must not be
an initial segment of any other {\em function-term-name}
in the same {\em prototype-pattern}.
\item
A {\em function-variable-name} (\pagref{FUNCTION-VARIABLE-NAME})
should not have a {\em qualifier-name} or {\em type-name} as an initial segment.
See Rule \ref{TYPE-NAME-RULE}, \pagref{TYPE-NAME-RULE}.
\item
For a {\em prototype-result-declaration} of the form `\TT{next} $v$',
$v$ must be the {\em vari\-able-name} in an {\em argument-declaration}
of the form `{\em qualifier-name}\STAR{} {\em type-name} $v$', and
any actual argument associated to the {\em argument-declaration}
must be a {\em variable-name} $w$ for which `\TT{next} $w$' is a legal
{\em assignment-statement} {\em result-variable-declaration}.
Similarly if $v$ is replaced in this paragraph by `\TT{@} $v$'.
\item
\TT{"="} cannot be used as a {\em function-term-name}
in a {\em prototype-pattern}.
\item
The first {\em argument-declaration} in an {\em input-variable-list}
must not have a {\em default-value} or end in \TT{??}.
\item
All the result and argument {\em variable-names}
in a {\em function-prototype} must
be distinct.
\item
In a {\em pattern-argument-list} or {\em input-variable-list}
an {\em argument-declaration} with no {\em de\-fault-value} cannot
follow an {\em argument-declaration} with a {\em default-value}.
An {\em argument-declaration} that ends with `\TT{??}' is considered
to have a \TT{bool} {\em default-value}: see \pagref{BOOL-DEFAULT}.

\end{itemize}
\end{indpar}

An example of an inline function declaration and an inline function call is:
\begin{indpar}\begin{verbatim}
function F ( int x ?= 5 ) G ( int y ) H ( int z ):
    . . . . . . . . . .
F H ( 6 ) G ( 7 )    // Equivalent to F ( 5 ) G ( 7 ) H ( 6 )
\end{verbatim}\end{indpar}

The {\em function-term-names} in the declaration are matched to those
in the call, but need not have the same order in the call, except for
the first {\em function-term-name} which must be the same in the
declaration and the call.  Thus the {\em call-terms} of the call
are re-ordered to match the order of the {\em pattern-terms} of the
declaration.  If one of the {\em pattern-terms} is omitted in the
call, but its arguments have {\em default-values} (here {\tt 5}),
the {\em pattern-term} with its
{\em default-value} will be inserted into the call.

An example containing an {\em input-variable-list} is:
\begin{indpar}\begin{verbatim}
function F [ int x ] = int y,  int z ?= 5:
    . . . . . . . . . .
F[10] = 6
\end{verbatim}\end{indpar}
which is treated as if {\tt =} were a {\em function-term-name}
that must be the last such in the call, and the comma separated
values in the call and {\em argument-declarations} in the prototype
were surrounded by parentheses {\tt (~)}.  Note that for an argument
list in the prototype to match an argument list in the call, both
must be surrounded by the same brackets; either both have {\tt (~)}
or both have {\tt [~]}.

Note that {\em quoted-marks} and {\em quoted-separators}
in {\em function-term-names} appear without quotes in {\em call-term-names}
(see \pagref{CALL-TERM-NAME}).  Thus we have the example:
\begin{indpar}\begin{verbatim}
function int z = ( int x ) "@@" ( int y ):
    . . . . . . . . . .
int w = 5 @@ 6
\end{verbatim}\end{indpar}

A {\em pattern-term} with the syntax:
\begin{indpar}
\emkey{boolean-pattern-term}\label{BOOLEAN-PATTERN-TERM} ::=
    {\em function-term-name} \\
\hspace*{1in}\TT{(} {\em qualifier-name}\STAR{}
        \TT{bool} {\em variable-name}
	\{ \TT{??} {\em default-value} \}\QMARK{} \TT{)}
\end{indpar}

triggers special syntax in a call that matches the prototype.
In the call:
\begin{center}
\begin{tabular}{rcl}
{\em function-term-name} & is equivalent to
                         & {\em function-term-name} \tt ( true ) \\
\TT{no} {\em function-term-name} & is equivalent to
                         & {\em function-term-name} \tt ( false ) \\
\TT{not} {\em function-term-name} & is equivalent to
                         & {\em function-term-name} \tt ( false ) \\
omitted {\em function-term-name} & is equivalent to
                         & {\em function-term-name}
			   \TT{(} {\em default-value} \TT{)} \\
\end{tabular}
\end{center}
Thus the example:
\begin{indpar}\begin{verbatim}
function F ( int x ) OPTION ( bool y ?? true )
    . . . . . . . . . .
F ( 5 )            // Equivalent to F ( 5 ) OPTION ( true )
F ( 5 ) OPTION     // Equivalent to F ( 5 ) OPTION ( true )
F ( 5 ) no OPTION  // Equivalent to F ( 5 ) OPTION ( false )
\end{verbatim}\end{indpar}

If a {\em required-value} is given in a prototype, the call must
have an {\tt ==} assembly-time value in order for the call to match
the prototype.  Matches to prototypes with more {\em required-values}
are preferred over matches to prototypes with less {\em required-values}.
Thus the example:
\begin{indpar}\begin{verbatim}
function F ( int x ) G ( int y == 5 ):  // First F declaration
    . . . . . . . . . .
function F ( int x ) G ( int y ?= 5 ):  // Second F declaration
    . . . . . . . . . .
int z = 5
F ( 8 )            // Matches only second F declaration
F ( 8 ) G ( 5 )    // Matches preferred first F declaration
F ( 8 ) G ( 6 )    // Matches only second F declaration
F ( 8 ) G ( z )    // Matches only second F declaration
                   // (z is not assembly-time).
\end{verbatim}\end{indpar}

\subsubsubsection{Inline Call-Prototype Matching}
\label{INLINE-CALL-PROTOTYPE-MATCHING}

Function calls are matched to function prototypes.  It is
an assembly error if a function call fails to match any
prototype.  If the call matches more than one prototype, the
matches are ranked according to the number of {\em required-values}
in each prototype, and if there is just one with the maximum
number of {\em required-values}, that match is used; otherwise
it is an assembly error.

Call-prototype matching is done as follows:

\begin{enumerate}
\item The {\em function-term-names} in the prototype are matched to
{\em call-term-names} in the call.  To match, the names must be identical,
except that quotes in prototype
{\em quoted-marks} and {\em quoted-separators} are removed in the call
(thus prototype {\tt "+"} matches call {\tt +}).

If a {\em function-term-name} matches more than one {\em call-term-name},
the prototype-call match fails.

The first {\em function-term-name} in the prototype must match
the first {\em call-term-name} in the call, else
the prototype-call match fails.

\item
The {\em function-term-names} found in the call are used to determine
the extent of {\em call-terms} in the call.  A {\em call-term}
must match its corresponding prototype {\em pattern-term} according
the rules that follow.  Failure of any call-prototype term match
causes the prototype-call match to fail.

In the case where the prototype has no {\em pattern-terms}, and just
has two or more {\em pattern-argument-lists}, the situation is
treated as if both prototype and call began with identical virtual
{\em function-term-names}.

\item For a {\em call-term} to match its corresponding {\em pattern-term},
both must have the same number of {\em argument-lists}, the same
brackets (either {\tt (~)} or {\tt [~]}) for corresponding
{\em argument-lists}, and the same number of
arguments in corresponding {\em argument-lists}, \underline{after}
the {\em call-term} has been \key{adjusted}.  The following are
permited adjustments.

A {\em constant} or {\em reference-expression} in the {\em call-term}
is adjusted by placing {\tt (~)} parentheses around it.

If in a left-to-right scan
a {\em call-argument-list} with {\tt (~)} is expected but none
is found, the empty list {\tt ()} is inserted.
Note that {\em argument-lists} with {\tt [~]} brackets cannot
be omitted.

If a {\em call-argument-list} is shorter than the
corresponding {\em pattern-argument-list}, {\em default-values}
in the {\em pattern-argument-list} are inserted in to corresponding
positions in the {\em call-argument-list}.  If a position has
no {\em default-value}, the call-prototype term match fails.

A {\em pattern-term} that has no corresponding {\em call-term}
(because its {\em function-term-name} was not found in the call),
the {\em pattern-term} is treated as being matched to a
virtual {\em call-term} consisting of only the {\em function-term-name}
of the {\em pattern-term}.

Exceptions are made for
a {\em boolean-pattern-term}\pagnote{BOOLEAN-PATTERN-TERM}.
If its {\em call-term-name} is present and preceded by `\TT{no}' or `\TT{not}'
and not followed by an
{\em argument-list}, the {\em argument-list} `{\tt ( false )}' is appended
and the `\TT{no}' or `\TT{not}' is deleted.
Otherwise if its {\em call-term-name} is present but not followed by an
{\em argument-list}, the {\em argument-list} `{\tt ( true )}' is appended.

\item If all the above is successful, then {\em actual-arguments}
in the call are matched to corresponding {\em argument-declarations}
in the prototype according to the rules that follow.
Failure of any call-prototype argument match causes
the call-prototype match to fail.

\item An {\em argument-declaration} $AD$ matches an {\em actual-argument}
$AA$ if and only if the statement `$AD$ = $AA$' successfuly compiles
when the {\em variable-name} in $AD$ is replaced by a unique virtual
{\em variable-name}.

\item If the {\em function-call} is an
{\em assignment-right-side}\pagnote{ASSIGNMENT-RIGHT-SIDE},
the number of {\em assignment-results} on the
{\em assignment-left-side} must not be greater than the number of
{\em prototype-result-valuable-declarations}, else the call-prototype
match fails.

The {\em assignment-results} are matched to the
{\em prototype-result-declarations} going from left to
right according to the rules that follow.
Failure of any call-prototype result match causes
the call-prototype match to fail.

Any unmatched {\em prototype-result-declarations}
are ignored.  

\item An {\em argument-result} $AR$ matches a
{\em prototype-result-declaration}
$RD$ if and only if the statement `$AR$ = $RD$' successfuly compiles
when the {\em variable-name} in $RD$ is replaced by a unique virtual
{\em variable-name}.

\item A {\em function-call} that is \underline{not} an
{\em assignment-right-side}\pagnote{ASSIGNMENT-RIGHT-SIDE}
must be assembly-time\pagnote{ASSEMBLY-TIME} else the
call-prototype match fails.  This means all the
{\em argument-declaration} and {\em prototype-result-declaration}
types in the prototype must be {\tt const}.  The prototype must
have at least one {\em prototype-result-declaration} (which
will take on the value of the {\em expression} that consists of
just the {\em function-call}), else the
call-prototype match fails.

\end{enumerate}

\subsubsubsection{Out-of-Line Function Declarations}
\label{OUT-OF-LINE-FUNCTION-DECLARATIONS}

\section{Assembly Time}

Statements and functions, all of whose variables are of {\tt const}
type, execute solely during assembly, and never at run time
(when the assembled program is running).  Constants are all of
type {\tt const}.

\subsection{Assembly Time Data}

Assembly time data consists of {\tt const} values.
There are 4 types of {\tt const} values: integers, rationals, strings,
and maps.

\key{Integers} are unbounded and can be arbitrarily long.
Any sequence of lexemes that is a
number representative
that evaluates to an integer
can be used to represent an integer {\tt const}.

\key{Rationals} are pairs of unbounded integers, a numerator and a denominator.
The demoninator must be greater than or equal to 2.  The greatest common divisor
of the numerator and denominator must be 1.
Any sequence of lexemes that is a
number representative
that evaluates to a non-integer
can be used to represent an rational {\tt const}, but not all
rational {\tt const} value can be represented by lexeme sequences
that are not {\em expressions}.

\key{Strings} are character strings, represented by quoted string lexemes.

\key{Maps} have two parts.  The \key{vector} part maps small
natural numbers in the range $[0,n-1]$ to values, where $n$
is the length of the vector.  The \key{dictionary} part maps
character string \key{labels} to values.

Labels that begin with '{\tt .}' are \key{hidden} and do not
print.  Maps that have no non-hidden labels are called \key{lists}.

Maps are represented by comma separated lists of elements inside
{\tt [~]} brackets, with list elements being represented by
just their value, and dictionary elements being represented
by the syntax `label {\tt =>} value'.\pagnote{MAPS}

The parser translates an input text into nested lists.  These
lists have a {\tt .position} hidden label whose value specifies
the position in the input of the text that produced the list.
Some of the lists have an {\tt .operator} hidden label whose
value specifies the operator in the list, which has usually
been moved to the beginning of the list.  Logical lines,
indented paragraphs, and parenthesized subexpressions
are lists with {\tt .initiator} and {\tt .terminator}
hidden attributes.

There are special {\em const} values \ttkey{TRUE} and
\ttkey{FALSE}, which are used to denote boolean values.

There is also a special {\tt const} value \ttkey{UNDEF},
which denotes the `\key{undefined value}'.  Assembly time
{\em expressions} that have `no value' actually have the
value {\tt UNDEF}.

\subsubsection{Maps}
\label{MAPS}

A \key{map} is an assembly time {\tt const} value that, unlike
numbers and strings, is mutable.
A {\em map-expression} computes a map value:

\begin{indpar}
\emkey{map-expression} ::=
    \TT{[]} $|$
    \TT{[} {\em map-element} \{ \TT{,} {\em map-element} \}\STAR{} \TT{]}
\\[0.5ex]
\emkey{map-element} ::=
        {\em expression} $|$ {\em label} \TT{=>} {\em expression}
	                 $|$ \TT{[} {\em map-index} \TT{]}
			 	\TT{=>} {\em expression}
\\[0.5ex]
{\em label} ::= see \pagref{LABEL}
\\[0.5ex]
\emkey{map-index} ::=
    {\em expression} evaluating to a {\tt const} integer or string
\end{indpar}


Elements of a map can be accessed by {\em map-element-expressions}, which
are also {\em reference-expressions} (see \pagref{REFERENCE-EXPRESSIONS}):

\begin{indpar}
\emkey{map-element-expression}
    \begin{tabular}[t]{rl}
    ::= & {\em map-base} \TT{[} {\em map-index} \TT{]} \\
    ::= & {\em map-base} {\em map-member} \\
    \end{tabular}
\\[0.5ex]
\emkey{map-base} ::= {\em expression} evaluating to a map
\\[0.5ex]
\emkey{map-member} :::= \TT{.} {\em label} ~~~~[note :::= and not ::=]
\end{indpar}

A map is mutable in that its elements may be written as well as read.
Note that hidden labels turn into {\em map-members} beginning with
two dots: the {\tt .position} of {\tt x} is {\tt x..position}.

The {\em label} of a map element, when represented as a string, can
be used in a {\em map-index} to designate the element.  That is,
given a map {\tt x} and a label {\tt y}, {\tt x.y} and {\tt x["y"]}
are equivalent.

There is a virtual hidden element of a map, \ttdkey{length}, which is
the value of the largest integer index of any map element,
plus 1.  So {\tt ["A", "B", "C"].length == 3}.  If a map has no
integer indices, its {\tt .length} is 0.

Values may be stored into map elements as well as read from the
elements.  Storing into a non-existant element creates the element.

Storing {\tt UNDEF} in an element deletes the element, and reading
from a non-existant element returns {\tt UNDEF} without any other
indication of there being an error.  Storing an integer into the
{\tt .length} of a map deletes all elements with integer indices
greater than or equal to the integer stored (but this may make
the map {\tt .length} less than instead of equal to the integer stored).

A simple assignment {\tt x = y} where {\tt y} is a map makes
a copy of the map in {\tt x}, so that {\tt x} and {\tt y} hold
\underline{different} maps (but they are {\tt ==}).  These two different maps
can be alterred independently.

A simple assignment {\tt @ x = @ y} where {\tt y} is a map makes
{\tt x} and {\tt y} both designate the \underline{same} map.
Altering the map designated by {\tt x} will alter the map
designated by {\tt y} in the same way.

A simple assignment such as {\tt @ x = @ y[z]} makes {\tt x} and
{\tt y[z]} designate the \underline{same} element of the map {\tt y},
so that storing into {\tt x} is the same as storing into
{\tt y[z]}.

Locations can be compared using {\tt ==} and {\tt @}.  So if {\tt y}
is a map, {\tt @ x == @ y[z]} can be used to test whether {\tt x}
and {\tt y[z]} both reference the same map element.

There are no {\tt const} pointer values, so {\tt x = @ y[z]} is not
legal when {\tt y} is a map.

\subsection{Operators and Builtin Functions}

\subsection{Control Structures}

\subsubsection{Function Definitions}

\section{Run Time}

\subsection{Data Types}

\subsubsection{Memory Organization}

\subsubsection{Numeric Data Types}

\subsubsection{Builtin Pointer Data Types}

\subsubsection{Defined Data Types}

\subsection{The Symbol Table}

\subsection{Assignment Statements}

\subsubsection{Operators and Builtin Functions}

\subsection{Control Structures}

\subsubsection{Inline Functions}

\subsubsection{Out-of-Line Functions}




\printindex

\end{document}
