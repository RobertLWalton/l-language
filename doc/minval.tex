% Minimal Runtime System Virtual Assembly Language
%
% File:         minval.tex
% Author:       Bob Walton (walton@acm.org)
% Date:		See \date below.
  
\documentclass[12pt]{article}

\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{makeidx}
% \usepackage{pictex} (obsolete? not available under CentOS 7)
\usepackage{upquote} % (imported to local directory
                     % ; not available under CentOS 7)
    % Modifies \verb and \verbatim to print ' with
    % the Computer Modern Typewrite font.
    % Also includes the textcomp package.
    % Modifies \verb and \verbatim to print ' with
    % the Computer Modern Typewrite font.
    % Also includes the textcomp package.

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\setlength{\textheight}{8.5in}
\raggedbottom

\setlength{\unitlength}{1in}

% The following attempt to eliminate headers at the bottom of a page.
\widowpenalty=300
\clubpenalty=300
\setlength{\parskip}{3ex plus 2ex minus 2ex}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{0.8in}%
	      \setlength{\rightmargin}{0.8in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\TILDE}{\textasciitilde}

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\TT}[1]{{\tt \bfseries #1}}
\newcommand{\TTALL}{\tt \bfseries}

\newcommand{\STAR}{{\Large $^\star$}}
\newcommand{\PLUS}[1][]{{$^{+#1}$}}
\newcommand{\QMARK}{{$^{\,\mbox{\footnotesize ?}}$}}
\newcommand{\OPEN}{{$\{$}}
\newcommand{\CLOSE}{{$\}$}}

\newcommand{\key}[1]{{\rm \bfseries #1}}
\newcommand{\ttkey}[1]{{\tt \bfseries #1}}
\newcommand{\emkey}[1]{{\em \bfseries #1}}
\newcommand{\skey}[2]{{\rm \bfseries #1#2}}
\newcommand{\ikey}[2]{{\rm \bfseries #1}}
\newcommand{\tttkey}[1]{{\tt \bfseries <#1>}}

\newcommand{\itemref}[1]{\ref{#1}$\,^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}
\newcommand{\pagnote}[1]{$\,^{p\pageref{#1}}$}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}

	 \vspace*{-15ex}
	 \centering
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\newenvironment{itemlist}[1][1.2in]%
	{\begin{list}{}{\setlength{\labelwidth}{#1}%
		        \setlength{\leftmargin}{\labelwidth}%
		        \addtolength{\leftmargin}{+0.2in}%
		        \renewcommand{\makelabel}[1]{##1\hfill}}}%
	{\end{list}}

\begin{document}
        
\begin{center}
\Large \bf
Minimal Runtime System\\
Virtual Assembly Language\\[0.5ex]
\huge \bf
MINVAL
\end{center}
\begin{center}
\large \bf
(Draft 1a)
\\[0.5ex]
Robert L. Walton\\
November 28, 2019

\bigskip
 
Table of Contents
\end{center}

\bigskip

\tableofcontents 

\newpage

\section{Introduction}

This document describes \key{MINVAL}, the Minimal Runtime System Virtual
Assembly Language.

\section{Overview}

A typical MINVAL statement is:
\begin{center}
\tt int X = Y + Z
\end{center}
This allocates a new variable {\tt X} of type {\tt int}
to the stack, and sets its value to that value of the
variable {\tt Y} plus the value of the variable {\tt Z}.
Most variables in the stack have a size equal to the natural
word size of the computer (typically 32 or 64 bits), or
several times that size: {\tt intd} is a two word (double) integer
and {\tt intq} is a four word (quad) integer.

Variables have names, like {\tt X}, {\tt Y}, and {\tt Z},
and locations in memory where their values are stored.

Locations can be complicated.  The statement:
\begin{center}
\tt Y \TILDE{} Gobbledeegook
\end{center}
makes the variable {\tt Y} synonymous with the
global variable {\tt Gobbledeegook} in the current
module.  {\tt Gobbledeegook} will have a location that
is at a offset address in the current module global memory, and
a type, such as `{\tt dp uns8}', which says it is a
direct pointer to a one byte unsigned integer, a.k.a., a character.
Direct pointers are stored in words.

The location of {\tt X} is an address in
the frame of the current function execution.

The statement
\begin{center}
\tt Z \TILDE{} Gobbledeegook[W]
\end{center}
makes {\tt Z} synonymous with {\tt Gobbledeegook}
indexed by the variable {\tt W}.  If {\tt W} is an
integer, the address of {\tt Z} the address
of {\tt Gobbledeegook} plus the value of {\tt W}
times the size of {\tt uns8}.

Now suppose
\begin{center}
\tt W \TILDE{} Gook
\end{center}
where {\tt Gook} is a global variable of type {\tt int16},
a signed 16 bit integer.  Then to execute
\begin{center}
\tt int X = Y[4] + Z
\end{center}
the computer must:
\begin{enumerate}
\item read the value of {\tt Y} which is the location of {\tt Gobbledeegook}
\item add {\tt 4} to this location
\item read the value of {\tt Y[4]} from this location and convert it
      to an {\tt int}
\item read the value of {\tt W} from the location of {\tt Gook} and
      convert it to an {\tt int}
\item add the value of {\tt W} to the location of {\tt Gobbledeegook}
      to get the location of {\tt Z}
\item read the value of {\tt Z} from this location and convert
      it to an {\tt int}
\item store the sum of the converted values of {\tt Y[4]} and {\tt Z} into {\tt X}
\end{enumerate}

Now there is a very important difference between {\tt X} on one
hand, and {\tt W}, {\tt Y} and {\tt Z} on the other.  When we call an
out-of-line function and then return, we can expect the value of
{\tt X} to be the same as before the call, but the values of
{\tt W}, {\tt Y} and {\tt Z} may have changed.  This is because the out-of-line
function and functions it calls can access the locations of {\tt W}, {\tt Y}
and {\tt Z}, but not the location of {\tt X}.

The expressions that compute locations have a limited structure,
so that the operations used consists of reading variables or constants,
adding values, multiplying values by constants, and shifting values
left or right by a constant number of bits.  More specifically, a
location as follows:
\begin{indpar}\begin{tabular}{rcl}
{\em location} & ::= & {\em global} $|$ {\em local} $|$ {\em base}
                   $|$ {\em offset} $|$ {\em indexed}
\\[0.5ex]
{\em global} & ::= & constant location provided by loader \\
       &     & (e.g., of a string constant); \\
       &     & not used for variables
\\[0.5ex]
{\em local} & ::= & location at a constant offset from the
                  current frame pointer \\
          & $|$ & location at a constant offset from the
	          current \\
          &     & module memory pointer
\\[0.5ex]
{\em indirect} & ::= & {\tt int} byte address read from a {\em local} location
\\[0.5ex]
{\em double-indirect} & ::= &
    {\tt int} byte address read from an {\em indirect} location
\\[0.5ex]
{\em base} & ::= & {\em indirect} $|$ {\em double-indirect}
\\[0.5ex]
{\em offset} & ::= & {\em base} + constant
\\[0.5ex]
{\em index} & ::= & {\tt int} read from {\em local} location \\
      & $|$ & {\tt int} read from a {\em offset} location
\\[0.5ex]
{\em indexed} & ::= & {\em base} + constant + constant * {\em index} \\
        &     & where if the {\em index} is read from
	        an {\em offset} location \\
	&     & the {\em base} of that {\em offset} location
	        must be the \underline{same} \\
	&     & as the {\em base} of the {\em indexed} expression
\end{tabular}\end{indpar}

Lastly after the above have computed the byte address of a location,
a location can optionally be a field of a word stored at that
byte address, where the field is designated by specifying:

\begin{itemize}
\item a one word mask selecting the bits of the field
\item the number of bits to the left of the field in the word
\item the number of bits to the right of the field in the word
\end{itemize}

MINVAL has a full set of number types:
{\tt int8}, {\tt uns8},
{\tt int16}, {\tt uns16}, {\tt flt16}, \ldots,
{\tt int128}, {\tt uns128}, {\tt flt128}.
The types {\tt int}, {\tt uns}, {\tt flt} are just these
types for the target machine word size, and the types
The types {\tt intd}, {\tt intq}, {\tt unsd}, {\tt unsq} are just integer
types for twice (double) or four times (quad) the target machine word size.
The {\tt bool} type is a single bit interpreted as {\tt true} if
1 and {\tt false} if 0: it is in essence a 1-bit unsigned integer.

There are also two kinds of user defined types: packed numbers
and structures.

An example packed number is:

\begin{indpar}\begin{verbatim}
packed uns32 my_type:
    [0-7]    uns op_code              // Operation
    [0]      bool has_constant        // Format indicator
    [8-31]   int constant             // Constant
    [8-15]   uns src1                 // Source Register
    [16-23]  uns src2                 // Source Register
    [24-31]  uns des                  // Destination Register

. . . . . . . . . . . .

my_type X = ...
uns op = X.op_code
int c = X.constant
Y ~ X.des
\end{verbatim}\end{indpar}

A packed number is a number ({\tt uns32} in the example)
that contains fields.  Each field occupies a sequence of
bits in the number ({\tt op\_code} occupies bits 0 through 7
in the example), and this sequence is interpreted as a
number, {\tt int}, {\tt uns}, or {\tt flt}, or as a {\tt bool},
and is given
a name ({\tt op\_code}, {\tt has\_constant}, etc.~in the
example).

Notice that fields can overlap.

Examples of structures are:

\begin{indpar}\begin{verbatim}
struct my_type:
    pack
    uns8    kind                     // Object Kind
    flt64   weight                   // Object Weight
    align   64
    label   extension

struct my_type:
    origin  extension
    align
    flt64   height                   // Object height
    flt64   width                    // Object height

struct my_type:
    origin  extension
    align
    flt64   volume                   // Object volume

struct your_type:
    include my_type   // Copy members of my_type
    dp uns8 name      // Direct pointer to name
                      // character string

. . . . . . . . . . . .

my_type X = ...
X.kind = BOX
X.weight = 55
X.height = 1023
X.width = 572

struct your_type Y
Y.kind = BEER
Y.weight = 0.45
Y.volume = 48
Y.name = "John Doe"
\end{verbatim}\end{indpar}

A structure is a byte sequence that contains members
(e.g., {\tt kind}, {\tt weight}, {\tt height}, etc. in
the example).
Each member has an offset in bytes from the beginning of the
structure (e.g. {\tt kind} is offset 0 and because it is
packed, {\tt weight} has offset 1).  A {\tt label} is like
a zero length member that has no value, and is used to
position other members via the {\tt origin} statement.
The {\tt include} statement copies members from another
structure type.

In this case {\tt extension} is aligned on a 64 bit boundary.
A structure type has an
alignment equal to the greatest common multiple of the
alignments of its members.

Structure types can be extended
(as per the example), and members can overlay each other.
A structure has a size in bytes just large enough to
accommodate all its members.

Structure types per say cannot be used as variable values.
Instead, pointers to structure types must be used.  In the
example {\tt my\_type} and {\tt your\_type} are types of
direct pointers, which are {\tt int} values containing
addresses.  Similarly {\tt X} and {\tt Y} are pointers.
Here {\tt X} is allocated by an out-of-line function call
denoted by {\tt \ldots}, while {\tt Y} is placed into the
current function execution frame.  In spite of this last,
{\tt Y} is still a pointer.

MINVAL has multiple pointer types.  The builtin ones are:
\begin{itemize}
\item[{\bf dp}] Direct Pointer.  An {\tt int} value holding
the byte address of the bytes pointed at.
\item[{\bf ip}] Indirect Pointer.  An {\tt int} value holding
a byte address of a {\tt int} value holding the byte address
of the bytes pointed at.
\item[{\bf op}] Offset Pointer (a.k.a., indirect offset pointer).
An {\tt intd} value half of which holds an {\tt int} offset $O$ and
the other half of which holds and {\tt int}
byte address of an {\tt int} base value $B$.  $B+O$ is the byte
address of the bytes pointed at.
\item[{\bf fp}] Field Pointer.  An {\tt intq} value, half of
which is an offset pointer pointing at an {\tt int} in memory,
and the other half of which holds the following which defines a field in that
{\tt int}: (1) an {\tt int} mask for
the bits of the field in the field's containing {\tt int},
(2) the number of bits to the left (high order side) of the field in
its {\tt int}, and
(3) the number of bits to the right (low order side) of the field in
its {\tt int}.

\end{itemize}

In the example above, {\tt name} is a direct pointer to an unsigned
byte, allowing expressions such as {\tt Y.name[i]} for an index variable
{\tt i}.

Some pointer types can be converted to other pointer types.
All the builtin pointer values can be converted to direct
pointers, as is done when calling legacy library functions
written in the C programming language.  Direct pointer values
can be converted to offset pointer values by using a base ($B$)
equal to zero and setting the offset ($O$) equal to the
direct address.

The default pointer type of a structure is direct, but this
can be changed, e.g., to indirect.  The MIN runtime system
requires that pointers be indirect or indirect offset.

New pointer types may also be defined by the user.

By default, functions in MINVAL are inline.  For example,

\begin{indpar}\begin{verbatim}
function int r = max ( int x, int y ):
    if x < y:
        r = y
    else:
        r = x

int x = ...
int y = ...
int z = max ( x, y )
\end{verbatim}\end{indpar}

An assignment statement can contain a single function call
or a single operator, but not both, and not more than one.
For example, given the definition of {\tt max} above:

\begin{indpar}\begin{verbatim}
int x = ...
int y = ...
int z = ...
int w = max ( x, max ( y, z ) )    // Illegal
int w1 = max ( y, z )              // OK
int w2 = max ( x, w1 )             // OK
\end{verbatim}\end{indpar}

Although variables in assignment statement operands cannot be
replaced by expressions involving variables, they can be replaced
by expressions involving constants.  Constants are their own
type, {\tt const}, and named constants can be created by assignment
statements.  For example, using the definition of {\tt max} above:

\begin{indpar}\begin{verbatim}
const x = 5
const y = 1e8
const z = x + y
const w = z / x + y
int u = ...
int v = max ( u, z / x + w * y )
\end{verbatim}\end{indpar}

Constant arithemtic is in effect infinite precision with unbounded
numbers.  Constant numbers can be converted to any of the runtime
number types, but if the result will not fit in a runtime integer,
a compiler error occurs.  This happens, for example, if {\tt 1e20}
is converted to an {\tt int32}.

It is possible to define inline functions that execute at assembly
time:

\begin{indpar}\begin{verbatim}
function const r = max ( const x, const y ):
    if x < y:
        r = y
    else:
        r = x

const x = 2e5
const y = 3e6
const z = 9e4
const w = max ( x, max( y, z ) )  // Legal!
\end{verbatim}\end{indpar}

Inline function definitions may make use of type wildcards.
A name that consists of only an initial {\tt T}
followed by one or more decimal digits is a type wildcard, that denotes
an arbitary type.  Thus the example:

\begin{indpar}\begin{verbatim}
function T1 r = max ( T1 x, T1 y ):
    if x < y:
        r = y
    else:
        r = x

const x = 2e5
int y = 27e4;
int z = max ( x, y )      // Converts x to int.
const w = 34e4;
const v = max ( x, w )    // All values are const.
\end{verbatim}\end{indpar}

A wildcard type of a result variable gets its value from the
type of the result variable in a function call.  The exception
is {\tt const}, which can be a wildcard type in a function
definition if and only if all type wildcards in the function definition
are assigned the value {\tt const} and doing so makes
all types in the function definition be {\tt const}
(except for types that are not used as types, but are used as
{\tt const} values, as in `{\tt sizeof ( int )}').

Pointer types can be wildcards which must have names consisting
of an initial {\tt P} followed by one or more decimal digits.
An example is:

\begin{indpar}\begin{verbatim}
function int r = strlen ( P1 uns8 s ):
    r = (int) C::strlen ( (dp) s ) )
\end{verbatim}\end{indpar}

which converts the point of type {\tt P1} to a pointer of
type {\tt dp} (direct pointer) and calls the C programming
language subroutine {\tt C::strlen} with the direct pointer.

MINVAL does not necessarily make any use of registers, other
than as temporaries during the execution of a single statement,
and a pair of registers that hold the current function
execution frame address and current module data address.
However, registers can be used to cache data that exists in
RAM memory, or that should exist in RAM memory but does not
due to optimization.  We call such registers software
caches.

Software caches of a RAM memory location are flushed when an out-of-line
function is called if (1) the location is not in the currently
executing function frame, or (2) the location is part of a
section of the currently executing function frame to which
a pointer (direct, indirect, offset, etc.) has been computed.

In addition to having a type and optionally a pointer type,
variables may have qualifiers.  The only qualifiers are
{\tt ro} and {\tt vo}.

{\tt ro} variables are read-only and
cannot be written.  However, they may be writable by
code located elsewhere, so it cannot be assumed they will
never change.  Therefore the {\tt ro} qualifier does not
affect software cacheing.

{\tt vo} variables are volatile, and may be changed asynchronously
between any two reads of the variable.  {\tt vo} variables are
\underline{not} cached in software registers.


\section{Syntax}

\subsection{Lexemes}
\label{LEXEMES}

A MINVAL source file is a sequence of bytes that is a UTF-8 encoding
of a sequence of UNICODE characters.  This is scanned into a sequence
of \skey{lexeme}s.

Unless otherwise specified, the term `\key{character}' in this
document means a 32-bit UNICODE character.

Lexemes are defined in terms of
the following character classes:

\begin{indpar}
\emkey{horizontal-space-character}
    \begin{tabular}[t]{rl}
    :::= & characters in UNICODE category \TT{Zs} \\
         & (includes {\em ASCII-single-space}) \\
    $|$  & {\em horizontal-tab-character}
    \end{tabular}
\\
\emkey{vertical-space-character}
    \begin{tabular}[t]{rl}
    :::= & {\em line-feed} $|$ {\em carriage-return} \\
    $|$ & {\em form-feed} $|$ {\em vertical-tab}
    \end{tabular}
\\
\emkey{space-character} :::= {\em horizontal-space-character}
                        $|$ {\em vertical-space-character}
\\[1ex]
\emkey{graphic-character} :::= characters in UNICODE categories
                              \TT{L}, \TT{M}, \TT{N}, \TT{P}, and \TT{S}
\\
\emkey{control-character} :::=
	characters in UNICODE categories \TT{C} and \TT{Z}
\\[1ex]
\emkey{isolated-separating-character} :::= \\
\hspace*{0.5in}
    \begin{tabular}[t]{l}
    characters in UNICODE categories \TT{Ps}, \TT{Pi}, \TT{Pe},
    and \TT{Pf}; \\
    includes \TT{\{ ( [ << >> ] ) \}}
    \end{tabular}
\\
\emkey{separating-character} :::= \TT{|} $|$ {\em isolated-separating-character}
\\[1ex]
\emkey{leading-separator-character} :::=
	\TT{`} $|$ \TT{\textexclamdown} $|$ \TT{\textquestiondown}
\\
\emkey{trailing-separator-character} :::=
	\TT{'} $|$ \TT{!} $|$ \TT{?} $|$ \TT{.} $|$ \TT{:}
	       $|$ \TT{,} $|$ \TT{;}
\\[1ex]
\emkey{quoting-character} :::= \TT{"}
\\[1ex]
\emkey{letter} :::=
    characters in UNICODE category \TT{L}
\\
\emkey{ASCII-digit} :::= \TT{0} $|$ \TT{1} $|$ \TT{2} $|$ \TT{3} $|$ \TT{4}
                     $|$ \TT{5} $|$ \TT{6} $|$ \TT{7} $|$ \TT{8} $|$ \TT{9}
\\
\emkey{digit} :::=
    characters in UNICODE category \TT{Nd}
    (includes {\em ASCII-digits})
\\
\emkey{lexical-item-character} :::=
	\begin{tabular}[t]{l}
        {\em graphic-character} other than \\
	{\em separating-character} or \TT{"}
	\end{tabular}
\end{indpar}

Comments may be placed at the ends of lines:
\begin{indpar}
\emkey{comment}\label{COMMENT} :::=
    \TT{//} {\em comment-character}\,$^\star$
\\[1ex]
\emkey{comment-character} :::= {\em graphic-character}
                          $|$ {\em horizontal-space-character}
\end{indpar}

Lexemes may be separated by {\em white-space}, which
is a sequence of {\em space-characters},
but, with some exceptions mentioned just below, is not itself a lexeme:
\begin{indpar}
\emkey{white-space} :::= {\em space-character}\PLUS{}
\\[0.3ex]
\emkey{horizontal-space} :::= {\em horizontal-space-character}\PLUS{}
\\[0.3ex]
\emkey{vertical-space} :::= {\em vertical-space-character}\PLUS{}
\end{indpar}

The following is a special virtual lexeme:
\begin{indpar}
\emkey{indent}\label{INDENT} ::=
        virtual lexeme inserted just before the first
	{\em graphic} character on a line
\end{indpar}

\ikey{Indent lexemes}{indent lexeme} have no characters, but
do have an \key{indent}, which is the indent of
the graphic character after the indent lexeme.
The \key{indent} of a character is the number
of columns that precede the character in the character's physical line.
Indent lexemes are used to form logical lines and blocks
(\itemref{LOGICAL-LINES-BLOCKS-AND-STATEMENTS}).

One kind of {\em vertical-space} is given special distinction:
\begin{indpar}
\emkey{line-break}\label{LINE-BREAK} ::=
	\begin{tabular}[t]{l}
        {\em vertical-space} containing exactly one {\em line-feed}
	\end{tabular}
\end{indpar}

This is the {\em line-break} lexeme.

{\em Horizontal-\EOL space-\EOL characters}\label{ILLEGAL-CHARACTERS}
other than single
space are illegal inside {\em quoted-string} lexemes (defined below).
{\em Vertical-space} that has \underline{no} {\em line-feeds} is
illegal (see below).
{\em Control-characters} not in {\em white-space} are illegal.
Characters that have no UNICODE category are {\em unrecognized-characters}
and are illegal:
\begin{indpar}
\emkey{misplaced-horizontal-space-character} :::= \\
\hspace*{0.5in}
    {\em horizontal-space-character}, other than ASCII-single-space
\\[0.3ex]
\emkey{misplaced-vertical-space-character} :::= \\
\hspace*{0.5in}{\em vertical-space-character} other than {\em line-feed}
\\[0.3ex]
\emkey{illegal-control-character} :::= \\
\hspace*{0.5in}
    \begin{tabular}[t]{l}
    {\em control-character},
    but \underline{not} a {\em horizontal-space-character} or \\
    {\em vertical-space-character}
    \end{tabular}
\\[0.3ex]
\emkey{unrecognized-character} :::= \\
\hspace*{0.5in}
    \begin{tabular}[t]{l}
    character with no UNICODE category or \\
    with a category other than
    \TT{L}, \TT{M}, \TT{N}, \TT{P}, \TT{S}, \TT{C}, or \TT{Z}
    \end{tabular}
\end{indpar}

Sequences of these characters generate warning messages,
but are otherwise like {\em horizontal-space}:
\begin{indpar}
\emkey{misplaced-horizontal} :::=
    {\em misplaced-horizontal-space-character}\PLUS{}
\\[0.3ex]
\emkey{misplaced-vertical} :::=
    {\em misplaced-vertical-space-character}\PLUS{}
\\[0.3ex]
\emkey{illegal-control} :::= {\em illegal-control-character}\PLUS{}
\\[0.3ex]
\emkey{unrecognized} :::= {\em unrecognized-character}\PLUS{}
\end{indpar}

{\em Misplaced-horizontal} only exists inside a {\em quoted-string},
but the other three sequences can appear anywhere.  When they occur,
these sequences generate warning messages, but otherwise they behave
like {\em horizontal-space}.  Specifically, outside {\em quoted-strings}
and {\em comments} these sequences can be used to separate other lexemes,
just as {\em horizontal-space} can be used,
whereas inside {\em quoted-strings} and
{\em comments} these sequences do nothing aside from generating
warning messages.

\begin{boxedfigure}[!p]
\begin{indpar}

\emkey{lexeme}
        \begin{tabular}[t]{rl}
	::= & {\em word} $|$ {\em mark} $|$ {\em number} $|$
	      {\em separator} $|$ {\em quoted-string} $|$ {\em indent} \\
	$|$ & {\em line-break} $|$
	      {\em comment} $|$ {\em end-of-file}
	\end{tabular}
\label{LEXEME}
\\[1ex]
\emkey{strict-separator} :::= {\em isolated-separating-character} $|$
                              \TT{|}\PLUS{}
\\[0.5ex]
\emkey{leading-separator} :::=
	\TT{`}\PLUS{} $|$ 
	\TT{\textexclamdown}\PLUS{} $|$ \TT{\textquestiondown}\PLUS{}
\\[0.5ex]
\emkey{trailing-separator} :::= \TT{'}\PLUS{} $|$
				   \TT{!}\PLUS{} $|$
				   \TT{?}\PLUS{} $|$
				   \TT{.}\PLUS{} $|$
				   \TT{:}\PLUS{} $|$
				   \TT{;} $|$
				   \TT{,}
\\[0.5ex]
\emkey{separator}
    ::= {\em strict-separator} 
    $|$ {\em leading-separator}
    $|$ {\em trailing-separator}
\\[1ex]
\emkey{quoted-string} :::=
    \TT{"} {\em character-representative}\,\STAR{} \TT{"}
\\[0.3ex]
\emkey{character-representative}\label{CHARACTER-REPRESENTATIVE}
	\begin{tabular}[t]{@{}rl@{}}
	::= & {\em graphic-character} other than \TT{"} \\
	$|$ & {\em ASCII-single-space-character} \\
	$|$ & {\em special-character-representative} \\
	\end{tabular}
\\[0.3ex]
\emkey{special-character-representative} :::= \\
\hspace*{0.5in}
    \TT{<} \{ {\em ASCII-upper-case-letter} $|$ {\em ASCII-digit}
            \}\PLUS{} \TT{>}
\\[1ex]
\emkey{lexical-item} :::= {\em lexical-item-character}\PLUS{}
                       not beginning with \TT{//}
\\[0.5ex]
\emkey{lexical-item} :::= {\em leading-separator}\STAR{}
			  {\em middle-lexeme}\QMARK{}
                          {\em trailing-separator}\STAR{}
\\[0.5ex]
\emkey{middle-lexeme} :::= 
	{\em lexical-item}
	\begin{tabular}[t]{@{}l@{}}
	not beginning with a \\
	{\em leading-separator-character} \\
	or ending with a \\
	{\em trailing-separator-character} \\
	\end{tabular}
\\[0.5ex]
\emkey{number}
    ::= {\em middle-lexeme} with a {\em digit} before any {\em letter}
\\[0.5ex]
\emkey{natural-number}\label{NATURAL-NUMBER}
	:::= {\em ASCII-digit}\PLUS{} not beginning with \TT{0} $|$ \TT{0}
\\[0.5ex]
\emkey{word} :::= {\em middle-lexeme} containing a {\em letter} that is not
                  a {\em number}
\\[0.5ex]
\emkey{mark} :::= {\em middle-lexeme} that is not a {\em word} or
		  {\em number}
\\[0.5ex]
{\em indent} ::= see \pagref{INDENT}
\\[0.5ex]
{\em line-break} ::= see \pagref{LINE-BREAK}
\\[0.5ex]
{\em comment} ::= see \pagref{COMMENT}
\\[0.5ex]
{\em end-of-file} ::= see \pagref{END-OF-FILE}

\end{indpar}
\caption{L-Language Program Lexemes}
\label{MINVAL-PROGRAM-LEXEMES}
\end{boxedfigure}

The lexemes in a MINVAL program are specified in
Figure~\itemref{MINVAL-PROGRAM-LEXEMES}.  This specification assumes there
are no illegal characters in the input; see page \pageref{ILLEGAL-CHARACTERS}
above to account for such characters.

The symbol `\ttkey{:::=}' is used in syntax equations
that define lexemes or parts of lexemes whose syntactic elements are
character sequences that must \underline{not} be separated by {\em white-space}.
The symbol `\ttkey{::=}'
is used in syntax equations that define sequences of lexemes that may
and sometimes must be separated by {\em white-space}.

There is a special \emkey{end-of-file}\label{END-OF-FILE}
lexeme that occurs only at the end of a file.

Files are scanned into sequences of lexemes which are then divided
into logical lines as per \itemref{LOGICAL-LINES-BLOCKS-AND-STATEMENTS}.
After each logical line is formed,
{\em indent}, {\em comment},
{\em line-break}, and {\em end-of-file} lexemes are deleted
from the logical line.

\ikey{Quoted string lexemes}{quoted strings!concatenated}
separated by the `\TT{\#}' mark
are glued together if they are in the
same logical line.  Thus
\begin{indpar}\begin{verbatim}
"This is a longer sentence" #
    " than we would like."
"And this is a second sentence."
\end{verbatim}\end{indpar}
is equivalent to
\begin{indpar}\begin{verbatim}
"This is a longer sentence than we would like."
"And this is a second sentence."
\end{verbatim}\end{indpar}
This is useful for
breaking long quoted string lexemes across line continuations.
But there is an important case where there is not an exact equivalence
between the glued and unglued versions.  \TT{"<" \# "LF" \# ">"} is
\underline{not} equivalent to \TT{"<LF>"}.  The former is a 4-character
quoted string, the characters being \TT{<}, \TT{L}, \TT{F},
and \TT{>}.  The latter is a 1-character quoted string, the character
being a line feed.

\ikey{Middle lexemes}{middle lexemes!glued}
in the same logical line are glued together if the first
ends with `\TT{\#}' and the second begins with `\TT{\#}'.
Thus
\begin{indpar}\begin{verbatim}
This is a continued-#
    #middle# #-lexeme.
\end{verbatim}\end{indpar}
is equivalent to
\begin{indpar}\begin{verbatim}
This is a continued-middle-lexeme.
\end{verbatim}\end{indpar}
For compatibility, two consequtive `\TT{\#}' marks may be used
to glue together two quoted strings, as in
\begin{indpar}\begin{verbatim}
"This is a continued-"#
    #"quoted"# #"-string".
\end{verbatim}\end{indpar}
which is equivalent to
\begin{indpar}\begin{verbatim}
"This is a continued-quoted-string".
\end{verbatim}\end{indpar}


A \emkey{special-character-representative} can consist of
a UNICODE character name surrounded by angle brackets.  Examples are
\TT{<NUL>}, \TT{<LF>}, \TT{<SP>}, \TT{<NBSP>}.  There are three other cases:
\tttkey{Q} represents the doublequote \TT{"}, \tttkey{NL} (new line)
represents a line feed (same as \TT{<LF>}), and \tttkey{UUC} represents
the `\key{unknown UNICODE character}' which in turn is used to represent
illegal UTF-8 character encodings.

A {\em special-character-representative} can also consist of
a hexadecimal UNICODE character code, which must begin with a digit.
Thus \TT{<0FF>} represents \TT{\"y} whereas \TT{<FF>} represents
a form feed.

The definition of a {\em middle-lexeme} is unusual: it is what is left over
after removing {\em leading-separators} and {\em trailing-separators}
from a {\em lexical-item}.  The lexical scan first scans a
{\em lexical-item}, and then removes
{\em leading-separators} and {\em trailing-separators} from it.
Also {\em trailing-separators} are removed
from the end of a {\em lexical-item} by a right-to-left scan, and not
the usual left-to-right scan which is used for everything else.
Thus the {\em lexical-item}
`\TT{\textquestiondown 4,987?,{},::}' yields the
{\em leading-separator} `\TT{\textquestiondown}',
the {\em middle-lexeme} `\TT{4,987}',
and the four {\em trailing-separators} `\TT{?}',
`\TT{,}' `\TT{,}' and `\TT{::}'.

\subsection{Logical Lines, Blocks, and Statements}
\label{LOGICAL-LINES-BLOCKS-AND-STATEMENTS}

Each non-blank physical line begins with an {\em indent} lexeme
that is followed by a
lexeme that is not an {\em indent}, {\em line-break}, or
{\em end-of-file}.

Lexemes are organized into \skey{logical line}s.  A logical line
begins immediately after an {\em indent} lexeme, and the
\key{indent} of the logical line is the
indent of this {\em indent} lexeme (i.e., the indent of the
first graphic character of the logical line).

A logical line ends with the next {\em indent} lexeme whose indent
is not greater than the indent of the logical line, or with an
{\em end-of-file}.  Thus physical
lines with indent greater than that of the current logical line
are \skey{continuation line}s for that logical line.

A code file is a sequence of `\key{top level}' logical lines that
are required to have indent \TT{0}.

A logical line may end with a \key{block} that is itself a sequence of
logical lines that have indents greater than the indent of the
logical line containing the block.
The block is introduced by a `\TT{:}' at the end
of a physical line, provided the `\TT{:}' is not inside brackets
or quotes
(e.g., not inside \TT{(~)} or \TT{`~'}).
If the first {\em indent} lexeme after the
`\TT{:}' has an indent that is \underline{not} greater than the indent
of the logical line containing the `\TT{:}', the block is empty.
Otherwise the indent of this {\em indent} lexeme becomes the
\key{indent} of the block and the indent of all the
logical lines in the block.  The first logical line of the block
starts immediately after this {\em indent} lexeme.
The block ends just before the first
logical line with lesser indent than the block indent, or the end of file.
More specifically, the last logical line of the block ends with an
{\em indent} whose indent is less than the block indent, or with an
{\em end-of-file}.

Examples are:
\begin{indpar}\begin{verbatim}
this is a top level logical line ending with a block:
    this is the first line of the block
    this is the
         second line of the block
    this is the third line of the block:
        this is the first line of a subblock
        this is the second line
                of the subblock:
            this is the only line of a sub-subblock
        this is the third line of the subblock
    this is the fourth line
            of the block:
        this is the only line of the second subblock
    this is the fifth line of the block
         and it ends with an empty subblock:
this is the second top level
     logical line
\end{verbatim}\end{indpar}

A warning message is output if two indents that are being compared
differ by more than \TT{0} and
less than \TT{2} columns, in order to better detect
indentation mistakes.

{\em Line-break} lexemes are effectively ignored.  A sequence
of {\em line-break} lexemes is followed by an {\em indent}
or {\em end-of-file} which is not ignored.
Blank physical lines are represented by sequences of
more than one {\em line-break} lexeme, and are effectively
ignored.

A logical line that contains {\em comments}, but no
lexemes other than {\em comments}, {\em line-breaks}, {\em indents}
and a possible {\em end-of-file}, is
a `\key{comment line}', and is ignored.

It is an error to begin non-comment logical lines with
a {\em comment}.
{\em Comments} can be used freely in the middle of or at the
end of any logical line, or at the beginning of a comment line.

It is an error for the first logical line of a file
to have an indent that is greater than \TT{0}, the top level
indent.

It is an error for a block to be in the middle of a logical
line.  This means that the first {\em indent} following the
block must have an indent no greater than that of the logical
line containing the block.

Examples are:
\begin{indpar}\begin{verbatim}
// this is a logical line that is a single comment

// this is a logical line that has two
    // comments

this is a logical line // with a comment
     // and another comment
     with three comments // and a last comment

this is a logical line ending with a block:
     First line of the block
     Second line of the block
// Comment that ends block
// Comment that is in error because
    it begins a logical line that this continues

this is a logical line with a block:
     First line of the block
     Second line of the block
  but the block is in error because it is before
  this continuation of the logical line that contains
  the block

this is a logical line ending with a block:
        First line of the block
        Second line of the block
  // comments that end the block, but are in error,
  // because they continue the logical line
  // containing the block
\end{verbatim}\end{indpar}

After a logical line
has been formed, any {\em indent},
{\em comment}, {\em line-break}, and {\em end-of-file}
lexemes in the logical line
are removed from the logical line.  If the result is
empty, e.g., the logical line is a comment line, it is discarded.
Otherwise the
modified logical line becomes a L-Language `\emkey{statement}'.

Therefore a file is a sequence of top-level statements.

Since a logical line can end with a block that itself consists
of a sequence of logical lines, a statement can end with
a block that itself consists of a sequence of statements.


\subsection{Expressions}


\section{Assembly Time}

Statements and functions, all of whose varibles are of {\tt const}
type, execute solely during assembly, and never at run time
(when the assembled program is running).  Constants are all of
type {\tt const}.

\subsection{Assembly Time Data}

Assembly time data consists of {\tt const} values.
There are 4 types of {\tt const} values: integers, rationals, strings,
and maps.

\key{Integers} are unbounded and can be arbitrarily long.
Any sequence of lexemes that is a
number representative\pagnote{NUMBER-REPRESENTATIVES}
that evaluates to an integer
can be used to represent an integer {\tt const}.

\key{Rationals} are pairs of unbounded integers, a numerator and a denominator.
The later must be greater than zero.  The greatest common divisor
of the numerator and denominator must be 1.
Any sequence of lexemes that is a
number representative\pagnote{NUMBER-REPRESENTATIVES}
that evaluates to a non-integer
can be used to represent an rational {\tt const}.

\key{Strings} are character strings, represented by quoted string lexemes.

\key{Maps} have two parts.  The \key{vector} part maps small
natural numbers in the range $[0,n-1]$ to values, where $n$
is the length of the vector.  The \key{dictionary} part maps
character string \key{labels} to values.

Labels that begin with '{\tt .}' are \key{hidden} and do not
print.  Maps that have no non-hidden labels are called \key{lists}.

Maps are represented by comma separated lists of elements inside
{\tt [~]} brackets, with list elements being represented by
just their value, and dictionary elements being represented
by the syntax `label {\tt =>} value'.\pagnote{MAP-REPRESENTATIVES}

The parser translates an input text into nested lists.  These
lists have a {\tt .position} hidden label whose value specifies
the position in the input of the text that produced the list.
Some of the lists have an {\tt .operator} hidden label whose
value specifies the operator in the list, which has usually
been moved to the beginning of the list.  Logical lines,
indented paragraphs, and parenthesized subexpressions
are lists with {\tt .initiator} and {\tt .terminator}
hidden attributes.

\subsubsection{Number Representatives}
\label{NUMBER-REPRESENTATIVES}

\subsubsection{Map Representatives}
\label{MAP-REPRESENTATIVES}

\subsection{Operators and Builtin Functions}

\subsection{Control Structures}

\subsubsection{Function Definitions}

\section{Run Time}

\subsection{Data Types}

\subsubsection{Memory Organization}

\subsubsection{Numeric Data Types}

\subsubsection{Builtin Pointer Data Types}

\subsubsection{Defined Data Types}

\subsection{The Symbol Table}

\subsection{Assignment Statements}

\subsubsection{Operators and Builtin Functions}

\subsection{Control Structures}

\subsubsection{Inline Functions}

\subsubsection{Out-of-Line Functions}




\printindex

\end{document}
