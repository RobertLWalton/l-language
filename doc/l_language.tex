% Layered Languages Low Level Language (L-Language)
%
% File:         l_language.tex
% Author:       Bob Walton (walton@acm.org)
% Date:		See \date below.
  
\documentclass[12pt]{article}

\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{makeidx}
\usepackage{upquote}
\usepackage{needspace}
% \usepackage{hyperref}
     % interesting but no use for printed version

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\setlength{\textheight}{8.5in}
\raggedbottom

\setlength{\unitlength}{1in}

% The following attempt to eliminate headers at the bottom of a page.
\widowpenalty=300
\clubpenalty=300
\setlength{\parskip}{3ex plus 2ex minus 2ex}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{0.4in}%
	      \setlength{\rightmargin}{0.4in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{0.4in}%
	      \setlength{\rightmargin}{0.4in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\TILDE}{\textasciitilde}

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\TT}[1]{{\tt \bfseries #1}}
\newcommand{\TTALL}{\tt \bfseries}

\newcommand{\STAR}{{\Large $^\star$}}
\newcommand{\PLUS}[1][]{{$^{+#1}$}}
\newcommand{\QMARK}{{$^{\,\mbox{\footnotesize ?}}$}}
\newcommand{\OPEN}{{$\{$}}
\newcommand{\CLOSE}{{$\}$}}

\newcommand{\ABV}{-{}-{}->}
\newcommand{\MA}{{\em ma}\QMARK}
\newcommand{\TS}{\hspace*{0in}\tt}

\newcommand{\key}[1]{{\rm \bfseries #1}}
\newcommand{\ttkey}[1]{{\tt \bfseries #1}}
\newcommand{\emkey}[1]{{\em \bfseries #1}}
\newcommand{\skey}[2]{{\rm \bfseries #1#2}}
\newcommand{\tttkey}[1]{{\tt \bfseries <#1>}}
\newcommand{\ttakey}[1]{{\tt \bfseries *#1*}}
\newcommand{\ttdkey}[1]{{\tt \bfseries .#1}}

\newcommand{\itemref}[1]{\ref{#1}$\,^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}
\newcommand{\pagnote}[1]{$\,^{p\pageref{#1}}$}
\newcommand{\stack}[1]{\begin{tabular}[t]{@{}l@{}}#1\end{tabular}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}

	 \centering
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\newenvironment{itemlist}[1][1.2in]%
	{\begin{list}{}{\setlength{\labelwidth}{#1}%
		        \setlength{\leftmargin}{\labelwidth}%
		        \addtolength{\leftmargin}{+0.2in}%
		        \renewcommand{\makelabel}[1]{##1\hfill}}}%
	{\end{list}}

\begin{document}
        
\begin{center}
\Large \bf
Low Level Layered Language\\[0.5ex]
\huge \bf
L-LANGUAGE
\end{center}
\begin{center}
\large \bf
(Draft 1b)
\\[0.5ex]
Robert L. Walton\\
April 12, 2024

\bigskip
 
Table of Contents
\end{center}

\bigskip

\tableofcontents 

\newpage

\section{Introduction}

This document describes \key{L-Language}, the Layered Language
System Low Level Language.

The L-Language is a system programming language built on the
following two main ideas:

\begin{indpar}

\key{Type Checking Segregation Hypothesis}~~~~ A strongly typed-checked
general-purpose computer-efficient language is impossible.
What is possible is
to segregate non-type-checkable code into small inline
library functions and into macro functions,
with code that uses these functions being
strongly type-checked.

\key{Fully Capable Macro Sublanguage Hypothesis}~~~~ It is better for
a programming language to have a builtin macro language that
is a general purpose interpreted language than it is for the
programming language to build into itself
many more limited and specialized type declaration and
flow control features.

\end{indpar}

The author of this document does not plan to implement the L-Language.
However, a parser for the L-Language is being built on top of the
`layered' system for lexical analysis and parsing, and is being used
to debug the design of the `layered' system.

\section{Overview}

A typical L-Language statement is:
\begin{indpar}\begin{verbatim}
int X = Y - C#"0"
\end{verbatim}\end{indpar}
This allocates a new variable {\tt X} of type {\tt int}
and sets its value to the value of the
variable {\tt Y} minus the constant {\tt C\#"0"} (which is
the character code of the character {\tt 0}).
The `variable' {\tt X} is readable, but after it is
initialized it is not writable.

The following is another example:
\begin{indpar}\begin{verbatim}
av *READ-WRITE* uns8 @bp @= local[81]
av uns8 @cp = "Hello!"
int i = 0
while i < cp.upper:
    bp[i] = cp[i]
    next i = i + 1
bp[cp.upper] = 0
\end{verbatim}\end{indpar}

Here `{\tt local[81]}' creates an aligned vector of
81 {\tt uns8} (8-bit unsigned) numbers in the current function
frame and returns an aligned vector pointer, or {\tt av}, to
the vector, marking the vector elements as {\tt *READ-WRITE*}.
{\tt "Hello!"} is a constant vector of {\tt uns8} numbers
and is similar except that it marks the vector elements
{\tt co}, for `constant', which is the implied default qualifier
for {\tt @cp}, and therefore
is not explicitly given.
Vector pointers can be used with indices
to reference elements of their vectors, and have {\tt upper} and
{\tt lower} bounds on these indices.  Here the {\tt lower} bounds
are their defaults, which are {\tt 0}.

Here {\tt @bp} is a variable whose name begins with `{\tt @}' and
whose value is therefore a pointer.  Such a variable has an associated
indirect variable {\tt bp} whose name is missing the initial `{\tt @}'.
The expression {\tt @bp[i]} designates a pointer to the {\tt i}+1'st
element of the vector pointed at by {\tt @bp}, but the expression
{\tt bp[i]} designates the value of the element.  Similarly for
{\tt @cp[i]} and {\tt cp[i]}.\footnote{`{\tt @}' is analogous to
C++ `{\tt \&}' used in a variable declaration, but here `{\tt @}'
can be used with different types of pointers, can be used
without restrictions for structure members, and can be used
with mutable pointers.}

The qualifier {\tt *READ-WRITE*} says that a value can be read or written,
the default qualifier {\tt co}, or `constant',
says a value can be read but will \underline{never} be written no matter what,
the qualifier {\tt ro}, or read-only, says that
the value can be read but
cannot be written using the variable name given, though it might be
written by some other piece of code that accesses the value under another
name.  The qualifier {\tt *WRITE-ONLY*} says that the value cannot be
read but can be written using the variable name given,
but might be read by some other piece of code or other device.

There are also two qualifiers that specify the lifetime of the target
of a pointer: {\tt *GLOBAL*}, and {\tt *HEAP*}.  The
default is no lifetime qualifier,
which means, roughly, that the pointer is only known to be valid until
the code block in which the pointer was first calculated is no
longer executing.  Typically pointer variables are default-undeclared,
as in the example.  The {\tt "Hello!"} constant in the example is
a {\tt *GLOBAL*} pointer, meaning that the pointer is valid during the
entire program execution, but such pointers are implicitly convertable
to undeclared pointers, as in the example.  {\tt *HEAP*} pointers
point at garbage collectable values and obey special rules that we
shall not discuss here.

Variables in function frames and global memory
have names, like {\tt X}, {\tt Y}, and {\tt Z}, and values
that are constants.
These values most frequently
have a size equal to the natural
word size of the computer (typically 32 or 64 bits), or
several times that size: {\tt intd} is a two word (double) integer
and {\tt intq} is a four word (quad) integer.
Although the value of a variable is constant, the value may point
at a memory location that is read-write.

An aligned vector pointer {\tt av} is a
quad integer ({\tt intq}) containing:
\begin{itemize}
\item A `base pointer' {\tt int} holding the byte address
of an {\tt int} in memory
that contains the `base (byte) address' of the vector.
Note that the {\tt av} value does \underline{not} contain
the base address, but contains instead this pointer to where
the base address is stored in memory.  This scheme allows
the base address to be changed without changing the {\tt av} value.
\item An `offset' {\tt int} that is added to the base address
to form the byte address of the vector element
that has index {\tt 0} in the vector (this element does not
exist if {\tt 0} is not an allowed index).
\item A `lower bound' {\tt int} which is the minimum allowed
value of the index {\tt int}.
\item An `upper bound' {\tt int} which is the maximum allowed
value of the index {\tt int} plus 1.
\end{itemize}

There are other types of pointer.  An {\tt fv}, or `field vector',
is like an {\tt av} aligned
vector except that the offset {\tt int} has a bit address in its
high order part and a field size in bits in its low order part.
The {\tt ap} (`aligned pointer') and {\tt fp} (`field pointer')  types are
similar but do not have the bounds and cannot be indexed.  Lastly
there is the direct pointer, {\tt dp}, that is just a single {\tt int}
containing a byte address; this is most useful for calling
C language functions.
New pointer types may be defined by the user.

Variables whose names begin with `{\tt @}' take pointer values, and
the variable's name with the
initial `{\tt @}' removed is called the associated
target variable and names the value pointed at.
Thus {\tt @V} is a pointer valued variable and {\tt V} is the value
{\tt @V} points at.
For example:

\begin{indpar}\begin{verbatim}
int X = 5
ap *READ-WRITE* int @Y   // `@= local' is implied
Y = X + 2                // Now Y == 7
Y = Y - 4                // Now Y == 3
X = X + 1                // Illegal!  X is co
ap ro int @Z = @Y        // Copies pointer value @Y.
                         // Pointer conversion from *READ-WRITE*
                         // to ro is legal.
\end{verbatim}\end{indpar}

Here the implied `{\tt @= local}' allocates an {\tt int} to the current
function frame, zeros it, and returns an `{\tt ap *READ-WRITE* int}'
pointer to its location.

Instead of making a variable point at a {\tt *READ-WRITE*} location you
can update the constant variable using the {\tt next} construct:
\begin{indpar}\begin{verbatim}
int X = 5
int Y = X + 2           // Now Y == 7; Y is co
next Y = Y - 4          // Now Y == 3; Y is co
Y = Y + 1               // Illegal!  Y is co
\end{verbatim}\end{indpar}
Here `{\tt next Y}' is a new variable, distinct from {\tt Y},
but with the same type, pointer type, qualifiers, and name `{\tt Y}',
which hides the previous variable of the same name.
The advantage of doing this is that it makes compilation more
efficient by keeping variables constant (i.e., {\tt co}), and
it improves debuggability by retaining the different values of
the variable for inspection by a debugger.

Loops also use the `{\tt next \ldots}' construct.  For example:
\begin{indpar}\begin{verbatim}
// Compute sum of 4, 5, and 6.
//
int sum = 0
int i = 4
next sum, next i = while i <= 6:
    next sum = sum + i
    next i = i + 1
\end{verbatim}\end{indpar}
which is semantically equal to:
\begin{indpar}\begin{verbatim}
int sum = 0
int i = 4
next sum, next i:
    next sum = sum + i
    next i = i + 1
next sum, next i:
    next sum = sum + i
    next i = i + 1
next sum, next i:
    next sum = sum + i
    next i = i + 1
\end{verbatim}\end{indpar}
The `{\tt next sum}' and `{\tt next i}' before the `{\tt :}',
which are the output variables for the block of code containing
the two `{\tt +}' statements,
can also be implied as they appear as output variables
of the `{\tt +}' statements, so the above code can be written as:
\begin{indpar}\begin{verbatim}
int sum = 0
int i = 4
while i <= 6:
    next sum = sum + i
    next i = i + 1
\end{verbatim}\end{indpar}

L-Language has a full set of number types:
{\tt int8}, {\tt uns8},
{\tt int16}, {\tt uns16}, {\tt flt16}, \ldots,
{\tt int128}, {\tt uns128}, {\tt flt128}; for signed integer,
unsigned integer, and floating point respectively.
The types {\tt int}, {\tt uns}, {\tt flt} are just these
types for the target machine word size.
The types {\tt intd}, {\tt intq}, {\tt unsd}, {\tt unsq} are just integer
types for twice (double) or four times (quad) the target machine word size.
The {\tt bool} type is a single bit interpreted as true if
1 and false if 0: it is in essence a 1-bit unsigned integer, but it
is not considered to be a number type.

User defined types have values that
consist of a sequence of bytes containing fields.
Fields in turn can contain subfields.
An example is:

\begin{indpar}\begin{verbatim}
type my type:
    uns32                             // Container for:
    [31-24]  uns8 op code             //   Operation
    [31]     bool has constant        //   Format indicator
    [23-0]   int constant             //   Constant
    [23-16]  uns8 src1                //   Source Register
    [15-8]   uns8 src2                //   Source Register
    [7-0]    uns8 des                 //   Destination Register

. . . . . . . . . . . .

my type X:
    X.op code = 5       // This is an initialization block
    X.src1 = 2          // for X in which X is *INIT*.
    X.src2 = 3
    X.des = 3
uns op = X.op code      // Now op == 5
int d = X.des           // Now d == 3
ap *READ-WRITE* my type @Y    // `@= local' is implied
Y.op code = 129
fp *READ-WRITE* int @C = @Y.constant
ap *READ-WRITE* uns8 @OP = @Y.op code
next op = OP            // Now op == 129
bool B = Y.has constant // Now B == 1
C = -1234               // Now Y.constant = -1234
\end{verbatim}\end{indpar}

In this example the declaration `{\tt my type X}' is approximately the same as
`{\tt ap co my type @X}', but the pointer {\tt @X} is hidden.
In the subblock of code that initializes {\tt X}, the {\tt co} qualifier
of {\tt X} is implicitly changed to the {\tt *INIT*} pseudo-qualifier that
has the same effect as {\tt *WRITE-ONLY*}
except that it forces fields/subfields of {\tt X} to be {\tt *INIT*}
even if they are {\tt co} or {\tt ro}.  In code after the subblock,
{\tt X} is {\tt co}.

In this example there is one field in a {\tt my type} value,
an unlabeled {\tt uns32} integer.
Inside this unlabeled field there are 6 subfields, the first of which is
an {\tt uns8} integer occupying the highest order 8
bits of the unlabeled field, bits 31-24,
where bits are numbered 0, 1, 2, \ldots{} from
low to high order.  The second subfield is a 1-bit {\tt bool}
value that occupies the high order bit, bit 31, of the unlabeled field.
Note that subfields can overlap.

Defined type values are aligned on byte boundaries when
they are stored in memory.  Therefore the `{\tt op code}' subfield
is on a byte boundary, and
the location of {\tt OP} is an {\tt ap} aligned pointer.  Although
the {\tt constant} subfield is on a byte boundary, it is
shorter than an {\tt int}, and therefore the
location of {\tt C} must be an {\tt fp} field pointer.
If `{\tt op code}' were in bits 30-23 instead of 31-24, it would
not be on a byte boundary and the location of {\tt OP} would
also have to be an {\tt fp} field pointer.

Note that `{\tt Y.op code}' is a {\tt *READ-WRITE*}
{\tt uns8} while `{\tt @Y.op code}' is a {\tt co} pointer to
a {\tt *READ-WRITE*} {\tt uns8}.

Names in L-Language can have multiple lexemes, as in
the type name `{\tt my type}', the subfield name `{\tt op code}',
and what L-Language calls the
associated member name `{\tt .op code}' which can be used to access
the field.

Another example is:

\begin{indpar}\begin{verbatim}
type my type:
    pack
    uns8    kind             // Object Kind
    [7] bool animal          // True if Animal
    [6] bool vegetable       // True if Vegetable
    flt64   weight           // Object Weight
    align   64
    *LABEL*   extension
    ***                      // Enables type extension.

type my type:
    *OFFSET*  extension
    flt64   height           // Object Height
    flt64   width            // Object Width
    ***                      // Enables type extension.

type my type:
    *OFFSET*  extension
    flt64   volume           // Object Volume; overlays height.
                             // No further type extension allowed.

type your type:
    *INCLUDE* my type // Copy sub-declarations of my type
    *OFFSET* *SIZE*   // *SIZE* is max origin seen so far.
    av uns8 @name     // Aligned vector pointer to name
                      // character string

. . . . . . . . . . . .

my type X:
    X.kind = BOX
    X.weight = 55
    X.height = 1023
    X.width = 572

your type Y:
    Y.kind = BEER
    Y.weight = 0.45
    Y.volume = 48
    Y.@name = "John Doe's Lager"
\end{verbatim}\end{indpar}

Here {\tt my type} and {\tt your type} are defined by
statements called {\em type-declarations}.  Each of these
{\em type-declarations} contains a sequence of sub-declarations, e.g.,
for {\tt my type} the first two sub-declarations are
`{\tt pack}' and `{\tt uns8 kind}'.  There is a current
offset in bits that starts at {\tt 0} and is updated by each sub-declaration.
A sub-declaration such as `{\tt uns8 kind}' allocates a field
(i.e., {\tt kind})
at the current offset and adds the size of the field to the
current offset.

In the example the fields are {\tt kind}, {\tt weight}, {\tt height}, etc.
Fields can be packed or aligned; aligned is the default.  An aligned number has an offset
that is a multiple of the length of the number.
Here fields are initially packed
so that since {\tt kind} has offset 0 bytes and size 1 byte,
{\tt weight} has offset 1 byte.  Subfields {\tt animal}
and {\tt vegetable} are 1-bit values inside {\tt kind}.

The {\tt align 64} sub-declaration moves the current offset
forward to a 64-bit boundary and causes fields beyond it
to be aligned and not packed.  A number is aligned if
its offset is a multiple of its length.  Alignments must be powers of two.
A defined type has an
alignment equal to the least common multiple (in this case just the
largest) of the
alignments of its aligned fields.

A {\tt *LABEL*} is like a zero length field that has no value and
is used to associate an origin-label with the current offset.
Here {\tt extension} has the offset value of 128 bits (16 bytes).
The {\tt *OFFSET*} sub-declaration resets the current offset to the offset
of a given origin-label, or to {\tt *SIZE*}, which denotes the current
size of the type in bits (which may increase with later sub-declarations).

The `{\tt ***}' sub-declaration at the end of a
{\em type-declaration} defining a user defined type indicates
that the definition may be continued by a later {\em type-declaration},
as is done for {\tt my type} above.
The sub-declarations of the later {\em type-declaration} are
simply appended to those of previous {\em type-declarations}.

The {\tt *INCLUDE*} sub-declaration copies all the sub-declarations
from another user defined type.
If the user defined type is
defined by multiple {\em type-declarations}, only sub-declarations
from the {\em type-declarations} in the current scope (see \itemref{SCOPE})
are copied.

Defined types can be extended
(as per the example), and fields can overlay each other.
A defined type value has a size in bytes just large enough to
accommodate all its fields.  If a defined type has multiple
{\em type-declarations}, this size may not be known until load time.

Values of defined types are strictly run-time values.  In contrast,
values of {\tt const} type are compile-time values, and are
not available at run-time.  Number lexemes consisting of
digits and optional signs, decimal points, and exponents,
are converted to IEEE 64-bit floating point {\tt const} values, as are
special numeric-word lexemes such as {\tt inf}, {\tt +inf}, {\tt -inf}, and
{\tt nan}.  Other number constants represent
rational {\tt const} values with unbounded integral numerators
and denominators; for example,
{\tt D\#"1/3"} represents the precise rational one-third.
Number constants
can be converted to run-time numbers during compilation.
However it is a compile error
if the result will not fit into the runtime number.
This happens, for example, if {\tt 1.1}, {\tt 1e20}, or {\tt D\#"1/3"}
is converted to an {\tt int32}.

Quoted strings denote string {\tt const} values that can be
converted during compilation to run-time vectors
with {\tt co} unsigned integer elements that encode the
string in UTF-8, UTF-16, or UTF-32.

Lastly there are map {\tt const} values that can hold lists
and dictionaries.  Map values can be mutable at compile-time,
but cannot be converted to run-time values.

Expressions, statements, and functions that use only {\tt const} values
execute at compile-time and can be used to compute compile-time
{\tt const} values including maps that represent code.

By default, functions in L-Language are inline.  For example,

\begin{indpar}\begin{verbatim}
function int r = max ( int x, int y ):
    if x < y:
        r = y
    else:
        r = x

int x = ...
int y = ...
int z = max ( x, y )
\end{verbatim}\end{indpar}

L-Language does \underline{not} support implicit conversions of
run-time function results\footnote{In this matter L-Language follows ADA.},
but does support implicit conversion of variables\footnote{Unlike ADA.}
and constants.  Any number constant or rational constant may be
converted implicitly to any run-time number type as long as
the constant value can be stored exactly in a variable
of the run-time type or the run-time type is floating point
(in which case there may be loss of precision or conversion to
an infinity).
Any run-time numeric variable value may be implicitly converted
at run-time to a number type that will hold all the possible values of
the variable, or to any floating point type
(in which case the run-time conversion result
may be less precise or an infinity).

Language expressions have \skey{target type}s.
For a function call, the function result \underline{cannot}
be implicitly converted to the target type.
However a function call that returns a {\tt const}
result is replaced by its value at compile time, and this value
can be implicitly converted to the target type.  Also, variable values
may be implicitly converted to a target type.

Most builtin operators, such as `{\tt +}',
have operands of the same type as their result.

An example of all this, using the declaration of {\tt max} above, is:

\begin{indpar}\begin{verbatim}
flt w = 1.1                 // flt is target type of 1.1
int x = 123                 // int is target type of 123
int y = 2e5                 // int is target type of 2e5
int z = 1e100               // illegal; int is target type of 1e100
                            // which is too large to fit
flt r1 = x                  // implicit conversion is legal as x is a
                            // variable name and not a function call
int r2 = 5 + max ( x, y )   // int is target type of +, 5, max, x, y
int r3 = max ( y, w )       // illegal; int is target type of w and
                            // flt cannot implicitly convert to int
int r4 = max ( x, 123 )     // int is target type of max, x, 123
int r5 = max ( x, 123.4 )   // illegal; int is target type of 123.4
                            // which cannot be stored in a int
const c1 = 100
const c2 = 1000
int r6 = max ( x, c1 + c2 ) // legal; c1 + c2 is replaced by 1100
                            // which has int target type
\end{verbatim}\end{indpar}

For each type {\tt T}, a function:
\begin{center} \tt
\begin{tabular}{l}
function T r = T ( T v ): \\
~~~~r = v
\end{tabular}
\end{center}
is provided.  Such an `identity' function might seem useless,
but in fact it can be used in an expression `{\tt T($e$)}' to
force the target type of $e$ to be {\tt T}.  As an example
consider the following, where there are builtin functions:
\begin{center} \tt
\begin{tabular}{l}
function N r = N ( N v1 ) \\
function N r = ( N v1 ) "+" ( N v2 ) \\
function bool r = ( N v1 ) "<" ( N v2 ) \\
\end{tabular}
\end{center}
for every number type {\tt N}:

\begin{indpar}\begin{verbatim}
int x = ...
bool b1 = ( x + 3 < 5 )
    // Illegal: any target type N to which int is implicitly
    // convertible can be used as the target type of "+", so
    // this is ambiguous.
bool b2 = ( flt ( x + 3 ) < 5 )
    // Legal: the argument of flt must have type flt, so that
    // becomes the target type of "+".  Because flt (...) is
    // an explicit type conversion, flt is also the target
    // type of 5.
bool b3 = ( x + 3 < int ( 5 ) )
    // Legal: the argument of int must have type int, so that
    // becomes the target type of "5".  Because int (...) is
    // an explicit type conversion, int is also the target
    // type of x + 5.
    // 
\end{verbatim}\end{indpar}

Integer arithmetic ignores overflows (as in C and C++); for example,
if integer + produces a value too large for its
target, the result is undefined and may or may not cause program
termination.

There are conversion functions from a floating
point type {\tt F} to any integer type {\tt I} with prototypes:
\begin{center} \tt
\begin{tabular}{l}
function I r = floor ( F v ) \\
function I r = ceiling ( F v ) \\
function I r = truncate  ( F v ) \\
function I r = round ( F v ) \\
\end{tabular}
\end{center}
that take a floating point value and round it toward
negative infinity ({\tt floor}),
positive infinity ({\tt ceiling}),
zero ({\tt truncate}),
or nearest ({\tt round}).  If the value is too large to be stored
in {\tt I}, a floating point exception flag is set, and
the result is an indefinite integer, which is
a particular value of type {\tt I} analogous to {\tt NaN}
for floating point.

The {\tt ro} qualifier name can be used by itself as a
conversion function name to convert
{\tt co} or {\tt *READ-WRITE*} qualifiers to {\tt ro} qualifiers.
This can handle cases where a function returns a {\tt *READ-WRITE*}
pointer to set an {\tt ro} pointer.

\begin{indpar}\begin{verbatim}
function ap *READ-WRITE* int r = foo ( ... )
ap ro int @p = ro ( foo ( ... ) )
\end{verbatim}\end{indpar}

Although function results cannot be implicitly converted, variables
can be, and implicit conversion of {\tt co} or {\tt *READ-WRITE*} to
{\tt ro} is defined for pointer-valued variables.

In addition to using target types to select which overloaded
function is being called, the types of implicitly convertible
arguments, that is, variables and constants, can be used.
Specifically, a function definition at least one of whose arguments
does not require an implicit conversion is preferred.

Finding a target type for comparison operands is more complicated.
If one of the operands is a function call to an explicit type conversion
function (a function whose name is a type name), then the type of
that function is used.  Othersize if some operands are reference
expressions, their types are tried.  An example is:

\begin{indpar}\begin{verbatim}
int x = ...
bool b1 = ( x < 6 )
    // There is a separate "<" operator for every number type,
    // X is a reference expression, so its type int is tried and
    // succeeds.
bool b2 = ( x < 6.5 )
    // Again int is tried and succeeds, but this time 6.5 produces
    // a compiler error when converted to an int.  Inconveribility of
    // particular constant values is NOT considered in selecting
    // function definitions.
bool b3 = ( x <= floor ( 6.5 ) )
    // Again int is tried and succeeds, but this time 6.5 is replaced
    // by 6.0 by the compile-time execution of the floor function,
    // and 6.0 converts to an int without error.
bool b3 = ( x <= flt ( 6.5 ) )
    // As flt is here an explicit conversion function with type flt,
    // that type must be used, and it succeeds.
\end{verbatim}\end{indpar}

It is possible to define compile-time functions:

\begin{indpar}\begin{verbatim}
constant function const r = max ( const x, const y ):
    if x < y: r = y
    else:     r = x

const x = 2e5
const y = 3e6
const z = 9e4
const w = max ( x, max( y, z ) )
\end{verbatim}\end{indpar}

A `{\tt constant}' function is just an inline function that
is guarenteed to not generate any run-time code.
Thus it can be executed at compile time to compute with
{\tt const} values.

Inline function definitions may make use of type wildcards.
A name that is a single word beginning with {\tt T\$}
is a type wildcard that denotes
an arbitrary type.  Thus the example:

\begin{indpar}\begin{verbatim}
function T$r r = max ( T$r x, T$r y ):
    if x < y: r = y
    else:     r = x

const x = 2e5
int y = 27e4
int z = max ( x, y )      // T$r is int, x converts to int.
flt u = 3.1415
flt v = max ( x, u )      // T$r is flt, x converts to flt.
flt v = max ( x, y )      // T$r is flt, x and y convert to flt.
int v = max ( x, u )      // Illegal, T$r is int, u cannot
                          // implicitly convert to int.
\end{verbatim}\end{indpar}

A wildcard type of a result variable gets its value from the
target type of a function call.  A wildcard type of an argument
can get its value from the argument type, but only if the
later is a variable, or more generally, a reference expression
(e.g., {\tt x[i]}).
Typing is mostly done top-down using target types, but reference
expressions get types bottom up from the variable explicitly named
in the reference expression.

Pointer types can be wildcards which must have names that are
single words beginning with {\tt P\$}.  A list of qualifiers
can also be a wild card named by a single word beginning with
{\tt Q\$}.  An example is:

\begin{indpar}\begin{verbatim}
out-of-line function
    uns r = strlen ( dp Q$s uns8 @s ) : *DEFERED* "strlen"
    // External function in C library.
function uns r = strlen ( P$s Q$s uns8 @s ):
    // Inline wrapper.
    dp ro uns8 @sdp = *UNCHECKED* ( @s )
    r = strlen ( @sdp )
\end{verbatim}\end{indpar}

which converts the pointer of type {\tt P\$s} to a pointer of
type {\tt dp} (direct pointer) and calls the `foreign' C programming
language subroutine {\tt strlen} with the direct pointer.
The {\tt *UNCHECKED*} function is needed to produce a direct pointer
from other pointer types, though this function is undefined
for some argument pointer types (e.g., field pointer types).
Calling {\tt strlen} with a {\tt dp} pointer calls the external
function directly, bypassing the inline wrapper, because the
external call has fewer wildcards (only 1 instead of 2).

A pointer type
has two places where a qualifier may appear, as in
\begin{indpar}\begin{verbatim}
type my control block:
    *READ-WRITE* ap *GLOBAL* ro uns32 @cr
    ....
\end{verbatim}\end{indpar}
in which {\tt @cr} is a read-write pointer variable pointing at a global
read-only {\tt uns32} location {\tt cr}.

Pointer types can be cascades: e.g., one can have a pointer to a pointer
to a pointer.  If the cascade has $N$ pointer type names the pointer
variable name must begin with exactly $N$ `\TT{@}'s.  An example is:
\begin{indpar}\begin{verbatim}
ap ap *READ-WRITE* ap int @@@x = ...
    // Now @@@x is a pointer with 3 cascaded pointer type names.
    // Now @@x is @@@x dereferenced once.
    // Now @x is @@x dereferenced once or @@@x dereferenced twice.
    // Now x is @x dereferenced once or @@@x dereferenced three times.
\end{verbatim}\end{indpar}

An {\tt inclusion} function can create new code that replaces
the statement calling the {\tt inclu\-sion} function.  For example:
\begin{indpar}[0.1in]\begin{verbatim}
inclusion function const r = max add ( macro V, macro I, macro LIMIT ):
    r = *INCLUDE* (V, I, LIMIT):
        int V += I
        int V = max ( V, LIMIT )
max add ( my sum, my increment, z + 100 )
    // This statement is replaced by
    //     int my sum += my increment
    //     int my sum = max ( my sum, z + 100 )
    // or more specifically:
    //     V = { "my", "sum" }
    //     I = { "my", "increment" }
    //     LIMIT = { { "z" }, "+", { 100 } }
    //     r = { { { "int", "my", "sum" }, "+=", { "my", "increment" } },
    //           { { "int", "my", "sum" }, "="
    //             { "max", { { "my", "sum" }, { { "z" }, "+", { 100 } },
    //                        ".initiator" => "(",
    //                        ".terminator" => ")",
    //                        ".separator" => "," } } } }
\end{verbatim}\end{indpar}

\section{Lexemes}
\label{LEXEMES}

An L-Language source file is a sequence of bytes that is a UTF-8 encoding
of a sequence of UNICODE characters.  This is scanned into a sequence
of \skey{lexeme}s.\footnote{
L-Language lexemes are layered system standard
lexemes, which are a compromise between the needs of programming languages
and the needs of natural languages.}

Unless otherwise specified, the term `\key{character}' in this
document means a 32-bit UNICODE character.

Lexemes are defined in terms of
the following character classes:

\begin{indpar}
\emkey{horizontal-space-character}
    \begin{tabular}[t]{rl}
    :::= & characters in UNICODE category \TT{Zs} \\
         & (includes {\em ASCII-single-space}) \\
    $|$  & {\em horizontal-tab-character}
    \end{tabular}
\\
\emkey{vertical-space-character}
    \begin{tabular}[t]{rl}
    :::= & {\em line-feed} $|$ {\em carriage-return} \\
    $|$ & {\em form-feed} $|$ {\em vertical-tab}
    \end{tabular}
\\
\emkey{space-character} :::= {\em horizontal-space-character}
                        $|$ {\em vertical-space-character}
\\[1ex]
\emkey{graphic-character} :::= characters in UNICODE categories
                              \TT{L}, \TT{M}, \TT{N}, \TT{P}, and \TT{S}
\\
\emkey{control-character} :::=
	characters in UNICODE categories \TT{C} and \TT{Z}
\\[1ex]
\emkey{isolated-separating-character} :::= \\
\hspace*{0.5in}
    \begin{tabular}[t]{l}
    characters in UNICODE categories \TT{Ps}, \TT{Pi}, \TT{Pe},
    and \TT{Pf}; \\
    includes \TT{\{ ( [ << >> ] ) \}}
    \end{tabular}
\\
\emkey{separating-character} :::= \TT{|} $|$ {\em isolated-separating-character}
\\[1ex]
\emkey{leading-separator-character} :::=
	\TT{`} $|$ \TT{\textexclamdown} $|$ \TT{\textquestiondown}
\\
\emkey{trailing-separator-character} :::=
	\TT{'} $|$ \TT{!} $|$ \TT{?} $|$ \TT{.} $|$ \TT{:}
	       $|$ \TT{,} $|$ \TT{;}
\\[1ex]
\emkey{quoting-character} :::= \TT{"}
\\[1ex]
\emkey{letter} :::=
    characters in UNICODE category \TT{L}
\\
\emkey{ASCII-digit} :::= \TT{0} $|$ \TT{1} $|$ \TT{2} $|$ \TT{3} $|$ \TT{4}
                     $|$ \TT{5} $|$ \TT{6} $|$ \TT{7} $|$ \TT{8} $|$ \TT{9}
\\
\emkey{digit} :::=
    characters in UNICODE category \TT{Nd}
    (includes {\em ASCII-digits})
\\
\emkey{lexical-item-character} :::=
	\begin{tabular}[t]{l}
        {\em graphic-character} other than \\
	{\em separating-character} or \TT{"}
	\end{tabular}
\end{indpar}

Comments may be placed at the ends of lines:
\begin{indpar}
\emkey{comment}\label{COMMENT} :::=
    \TT{//} {\em comment-character}\,$^\star$
\\[1ex]
\emkey{comment-character} :::= {\em graphic-character}
                          $|$ {\em horizontal-space-character}
\end{indpar}

Lexemes may be separated by {\em white-space}, which
is a sequence of {\em space-characters},
but, with some exceptions mentioned just below, is not itself a lexeme:
\begin{indpar}
\emkey{white-space} :::= {\em space-character}\PLUS{}
\\[0.3ex]
\emkey{horizontal-space} :::= {\em horizontal-space-character}\PLUS{}
\\[0.3ex]
\emkey{vertical-space} :::= {\em vertical-space-character}\PLUS{}
\end{indpar}

The following is a special virtual lexeme:
\begin{indpar}
\emkey{indent}\label{INDENT} ::=
        virtual lexeme inserted just before the first
	{\em graphic-character} on a line
\end{indpar}

\key{Indent lexemes} have no characters, but
do have an \key{indent}, which is the indent of
the graphic character after the indent lexeme.
The \key{indent} of a character is the number
of columns that precede the character in the character's physical line.
{\em Control-characters} other than {\em horizontal-space-characters}
take zero columns, as do characters of classes \TT{Mn} (combining-marks)
and \TT{Me} (ending marks).  All other characters take one column,
except for tabs, that are set every 8 columns.
Indent lexemes are used to form logical lines and blocks
(\itemref{LOGICAL-LINES-BLOCKS-AND-STATEMENTS}).

One kind of {\em vertical-space} is given special distinction:
\begin{indpar}
\emkey{line-break}\label{LINE-BREAK} ::=
	\begin{tabular}[t]{l}
        {\em vertical-space} containing exactly one {\em line-feed}
	\end{tabular}
\end{indpar}

This is the {\em line-break} lexeme.

Non-{\em indent}, non-{\em line-break} {\em white-space}, such as occurs
in the middle of text or code outside comments, is discarded and not treated
as a lexeme.  Such {\em white-space} may be used to separate lexemes.

{\em Horizontal-\EOL space-\EOL characters}\label{ILLEGAL-CHARACTERS}
other than single
space are illegal inside {\em quoted-string} lexemes (defined below).
{\em Vertical-space} that has \underline{no} {\em line-feeds} is
illegal (see below).
{\em Control-characters} not in {\em white-space} are illegal.
Characters that have no UNICODE category are {\em unrecognized-characters}
and are illegal:
\begin{indpar}
\emkey{misplaced-horizontal-space-character} :::= \\
\hspace*{0.5in}
    {\em horizontal-space-character}, other than ASCII-single-space
\\[0.3ex]
\emkey{misplaced-vertical-space-character} :::= \\
\hspace*{0.5in}{\em vertical-space-character} other than {\em line-feed}
\\[0.3ex]
\emkey{illegal-control-character} :::= \\
\hspace*{0.5in}
    \begin{tabular}[t]{l}
    {\em control-character},
    but \underline{not} a {\em horizontal-space-character} or \\
    {\em vertical-space-character}
    \end{tabular}
\\[0.3ex]
\emkey{unrecognized-character} :::= \\
\hspace*{0.5in}
    \begin{tabular}[t]{l}
    character with no UNICODE category or \\
    with a category other than
    \TT{L}, \TT{M}, \TT{N}, \TT{P}, \TT{S}, \TT{C}, or \TT{Z}
    \end{tabular}
\end{indpar}

Sequences of these characters generate warning messages,
but are otherwise like {\em horizontal-space}:
\begin{indpar}
\emkey{misplaced-horizontal} :::=
    {\em misplaced-horizontal-space-character}\PLUS{}
\\[0.3ex]
\emkey{misplaced-vertical} :::=
    {\em misplaced-vertical-space-character}\PLUS{}
\\[0.3ex]
\emkey{illegal-control} :::= {\em illegal-control-character}\PLUS{}
\\[0.3ex]
\emkey{unrecognized} :::= {\em unrecognized-character}\PLUS{}
\end{indpar}

{\em Misplaced-horizontal} only exists inside a {\em quoted-string},
but the other three sequences can appear anywhere.  When they occur,
these sequences generate warning messages, but otherwise they behave
like {\em horizontal-space}.  Specifically, outside {\em quoted-strings}
and {\em comments} these sequences can be used to separate other lexemes,
just as {\em horizontal-space} can be used,
whereas inside {\em quoted-strings} and
{\em comments} these sequences do nothing aside from generating
warning messages.

\begin{boxedfigure}[!p]

\emkey{lexeme}
        \begin{tabular}[t]{rl}
	::= & {\em numeric-word} $|$ {\em word} $|$
	      {\em natural} $|$ {\em number} $|$ {\em numeric} \\
	$|$ & {\em mark} $|$ {\em separator} $|$ {\em quoted-string} \\
	$|$ & {\em indent} $|${\em line-break} $|$
	      {\em comment} $|$ {\em end-of-file}
	\end{tabular}
\label{LEXEME}
\\[1ex]
\emkey{strict-separator} :::= {\em isolated-separating-character} $|$
                              \TT{|}\PLUS{}
\\[0.5ex]
\emkey{leading-separator} :::=
	\TT{`}\PLUS{} $|$ 
	\TT{\textexclamdown}\PLUS{} $|$ \TT{\textquestiondown}\PLUS{}
\\[0.5ex]
\emkey{trailing-separator} :::= \TT{'}\PLUS{} $|$
				   \TT{!}\PLUS{} $|$
				   \TT{?}\PLUS{} $|$
				   \TT{.}\PLUS{} $|$
				   \TT{:}\PLUS{} $|$
				   \TT{;} $|$
				   \TT{,}
\\[0.5ex]
\emkey{separator}
    ::= {\em strict-separator} 
    $|$ {\em leading-separator}
    $|$ {\em trailing-separator}
\\[1ex]
\emkey{quoted-string}\label{QUOTED-STRING} :::=
    \TT{"} {\em character-representative}\,\STAR{} \TT{"}
\\[0.3ex]
\emkey{character-representative}\label{CHARACTER-REPRESENTATIVE}
	\begin{tabular}[t]{@{}rl@{}}
	::= & {\em graphic-character} other than \TT{"} \\
	$|$ & {\em ASCII-single-space-character} \\
	$|$ & {\em special-character-representative} \\
	\end{tabular}
\\[0.3ex]
\emkey{special-character-representative} :::=
    \TT{<} \{ {\em upper-case-letter} $|$ {\em digit} \}\PLUS{} \TT{>}
\\[1ex]
\emkey{lexical-item} :::= {\em lexical-item-character}\PLUS{}
                       not beginning with \TT{//}
\\[0.5ex]
\emkey{lexical-item} :::= {\em leading-separator}\STAR{}
			  {\em middle-lexeme}\QMARK{}
                          {\em trailing-separator}\STAR{}
\\[0.5ex]
\emkey{middle-lexeme} :::= 
	{\em lexical-item}
	\begin{tabular}[t]{@{}l@{}}
	not beginning with a {\em leading-separator-character} \\
	or ending with a {\em trailing-separator-character} \\
	\end{tabular}
\\[0.5ex]
\emkey{numeric-word} :::= {\em sign}\QMARK{} \ttkey{nan}
                      $|$ {\em sign}\QMARK{} \ttkey{inf}
		      ~~~~~
		      [where {\em letters} are \underline{case insensitive}]
\\[0.5ex]
\emkey{word} :::= {\em middle-lexeme}
                  \begin{tabular}[t]{@{}l@{}}
		  that contains a {\em letter} before any {\em digit} \\
		  and is not a {\em numeric-word}
		  \end{tabular}
\\[0.5ex]
\emkey{natural}\label{NATURAL}
	\begin{tabular}[t]{@{}rl@{}}
	:::= & {\em decimal-digit}\PLUS{} not beginning with \TT{0} $|$
	       \TT{0} \\
	\multicolumn{2}{l}{[but lexical type may be changed;
	                    see \pagref{LEXEME-TYPE-CONVERSION}]} \\
	\end{tabular}
\\[0.5ex]
\emkey{number}\label{NUMBER}
	\begin{tabular}[t]{@{}rl@{}}
	:::= & {\em sign}\QMARK{} {\em integer-part}
	                          {\em exponent-part}\QMARK{}
	     that is not a {\em natural} \\
	 $|$ & {\em sign}\QMARK{} {\em integer-part}\QMARK{}
	                          {\em fraction-part}
				  {\em exponent-part}\QMARK{} \\
	\multicolumn{2}{l}{[but lexical type may be changed;
	                    see \pagref{LEXEME-TYPE-CONVERSION}]} \\
	\end{tabular}
\\[0.5ex]
\begin{tabular}[t]{@{}l@{\hspace{0.6in}}l@{}}
\emkey{integer-part} :::= {\em decimal-digit}\PLUS{}
&
\emkey{fraction-part} :::= \TT{.} {\em decimal-digit}\PLUS{}
\end{tabular}
\\[0.5ex]
\emkey{exponent-part} :::= {\em exponent-indicator} {\em sign}\QMARK{}
                           {\em decimal-digit}\PLUS{}
\\[0.5ex]
\begin{tabular}[t]{@{}l@{\hspace{1in}}l@{}}
\emkey{sign} :::= \TT{+} $|$ \TT{-}
&
\emkey{exponent-indicator} :::= \TT{e} $|$ \TT{E}
\end{tabular}
\\[0.5ex]
\emkey{numeric} :::= {\em middle-lexeme}
                  \begin{tabular}[t]{@{}l@{}}
		  that contains a {\em digit} before any {\em letter} \\
		  and is not a {\em natural} or {\em number}
		  \end{tabular}
\\[0.5ex]
\emkey{mark}\label{MARK} :::= {\em middle-lexeme} not containing a
                              {\em letter} or a {\em digit}
\\[0.5ex]
\begin{tabular}[t]{@{}l@{\hspace{1in}}l@{}}
{\em indent} ::= see \pagref{INDENT}
&
{\em line-break} ::= see \pagref{LINE-BREAK}
\\[0.5ex]
{\em comment} ::= see \pagref{COMMENT}
&
{\em end-of-file} ::= see \pagref{END-OF-FILE}
\end{tabular}


\caption{L Language Program Lexemes}
\label{L-LANGUAGE-PROGRAM-LEXEMES}
\end{boxedfigure}


The lexemes in a L-Language program are specified in
Figure~\itemref{L-LANGUAGE-PROGRAM-LEXEMES}.  This specification assumes there
are no illegal characters in the input; see text
above to account for such characters.

The symbol `\ttkey{:::=}' is used in syntax equations
that define lexemes or parts of lexemes whose syntactic elements are
character sequences that must \underline{not} be separated by {\em white-space}.
The symbol `\ttkey{::=}'
is used in syntax equations that define sequences of lexemes that may
and sometimes must be separated by {\em white-space}.

There is a special \emkey{end-of-file}\label{END-OF-FILE}
lexeme that occurs only at the end of a file.

Files are scanned into sequences of lexemes which are then divided
into logical lines as per \itemref{LOGICAL-LINES-BLOCKS-AND-STATEMENTS}.
After each logical line is formed,
{\em indent}, {\em comment},
{\em line-break}, and {\em end-of-file} lexemes are deleted
from the logical line.

A \emkey{special-character-representative} can consist of
a UNICODE character name surrounded by angle brackets.  Examples are
\TT{<NUL>}, \TT{<LF>}, \TT{<SP>}, \TT{<NBSP>}.  There are three other cases:
\tttkey{Q} represents the doublequote \TT{"}, \tttkey{NL} (new line)
represents a line feed (same as \TT{<LF>}), and \tttkey{UUC} represents
the `\key{unknown UNICODE character}' which in turn is used to represent
illegal UTF-8 character encodings.

A {\em special-character-representative} can also consist of
a hexadecimal UNICODE character code, which must begin with a digit.
Thus \TT{<0FF>} represents \TT{\"y} whereas \TT{<FF>} represents
a form feed.

\key{Quoted string lexemes}
\label{QUOTED-STRING-CONCATENATION}
separated by the `\TT{\#}' mark
are glued together if they are in the
same logical line.  Thus
\begin{indpar}\begin{verbatim}
"This is a longer sentence" #
    " than we would like."
"And this is a second sentence."
\end{verbatim}\end{indpar}
is equivalent to
\begin{indpar}\begin{verbatim}
"This is a longer sentence than we would like."
"And this is a second sentence."
\end{verbatim}\end{indpar}
This is useful for
breaking long quoted string lexemes across line continuations.
But there is an important case where there is not an exact equivalence
between the glued and unglued versions.  \TT{"<" \# "LF" \# ">"} is
\underline{not} equivalent to \TT{"<LF>"}.  The former is a 4-character
quoted string, the characters being \TT{<}, \TT{L}, \TT{F},
and \TT{>}.  The latter is a 1-character quoted string, the character
being a line feed.

The definition of a \key{middle-lexeme} is unusual: it is what is left over
after removing {\em leading-separators} and {\em trailing-separators}
from a {\em lexical-item}.  The lexical scan first scans a
{\em lexical-item}, and then removes
{\em leading-separators} and {\em trailing-separators} from it.
Also {\em trailing-separators} are removed
from the end of a {\em lexical-item} by a right-to-left scan, and not
the usual left-to-right scan which is used for everything else.
Thus the {\em lexical-item}
`\TT{\textquestiondown 4,987?,{},::}' yields the
{\em leading-separator} `\TT{\textquestiondown}',
the {\em middle-lexeme} `\TT{4,987}',
and the four {\em trailing-separators} `\TT{?}',
`\TT{,}' `\TT{,}' and `\TT{::}'.

{\em Words}, {\em numerics}, and {\em marks}
in the same logical line are glued together if the first
ends with `\TT{\#}' and the second begins with `\TT{\#}'.
Thus
\begin{indpar}\begin{verbatim}
This is a continued-#
    #middle# #-lexeme.
\end{verbatim}\end{indpar}
is equivalent to
\begin{indpar}\begin{verbatim}
This is a continued-middle-lexeme.
\end{verbatim}\end{indpar}
For compatibility, two consecutive `\TT{\#}' marks may be used
to glue together two quoted strings, as in
\begin{indpar}\begin{verbatim}
"This is a continued-"#
    #"quoted"# #"-string".
\end{verbatim}\end{indpar}
which is equivalent to
\begin{indpar}\begin{verbatim}
"This is a continued-quoted-string".
\end{verbatim}\end{indpar}


A {\em numeric-word}, {\em natural}, or {\em number} lexeme
is a C/C++ constant, and 
conversely a C/C++ decimal constant
that does not end in a {\em decimal-point}
is a {\em numeric-word}, {\em natural}, or {\em number} lexeme.
All these lexemes are given an IEEE double precision number value
after the manner of C/C++, and then their lexical type is changed
as follows:
\begin{itemize}\label{LEXEME-TYPE-CONVERSION}
\item If the value is \underline{not} a finite number, the
new type is {\em numeric-word}.  For example, this applies to {\tt 1e500}
which converts to the same value as {\tt +inf}.
\item If the value is an integer in the range $[0,10^{15})$ the new
type is {\em natural}.
For example, this applies to {\tt 1e3}
which converts to the same value as {\tt 1000}.
\item Otherwise the new type is {\em number}.
For example, this applies to {\tt 1e20} or {\tt 1.1}.
\end{itemize}

In contrast, a {\em numeric}, like {\tt 02/28/2022},
represents a character string and in this
is like a {\em word}.  The lexeme {\tt 2/3} is also a {\em numeric}
and is \underline{not} used to represent a number; instead
the lexeme pair {\tt D\# "2/3"} is used to represent a rational
number constant (value of {\tt const} type).

\section{Logical Lines, Blocks, and Statements}
\label{LOGICAL-LINES-BLOCKS-AND-STATEMENTS}

Each non-blank physical line begins with an {\em indent} lexeme
that is followed by a
lexeme that cannot be an {\em indent}, {\em line-break}, or
{\em end-of-file}.

Lexemes are organized into \skey{logical line}s.\footnote{
L-Language lexemes logical lines and indented paragraphs are
layered system brcketed subexpression recognition pass
logical lines and paragraphs.}
A logical line
begins immediately after an {\em indent} lexeme, and the
\key{indent} of the logical line is the
indent of this {\em indent} lexeme (i.e., the indent of the
first graphic character of the logical line).

A logical line ends with the next {\em indent} lexeme whose indent
is not greater than the indent of the logical line, or with an
{\em end-of-file}.  Thus physical
lines with indent greater than that of the current logical line
are \skey{continuation line}s for that logical line.

A code file is a sequence of `\key{top level}' logical lines that
are required to have indent \TT{0}.

A logical line may end with a \key{block} that is itself a sequence of
logical lines that have indents greater than the indent of the
logical line containing the block.
The block is introduced by a `\TT{:}' at the end
of a \underline{physical} line, provided the `\TT{:}' is not inside brackets
or quotes
(e.g., not inside \TT{(~)} or \TT{`~'}).
If the first {\em indent} lexeme after the
`\TT{:}' has an indent that is \underline{not} greater than the indent
of the logical line containing the `\TT{:}', the block is empty.
Otherwise the indent of this {\em indent} lexeme becomes the
\key{indent} of the block and the indent of all the
logical lines in the block.  The first logical line of the block
starts immediately after this {\em indent} lexeme.
The block ends just before the first
logical line with lesser indent than the block indent, or the end of file.
More specifically, the last logical line of the block ends with an
{\em indent} whose indent is less than the block indent, or with an
{\em end-of-file}.

Examples are:
\begin{indpar}\begin{verbatim}
this is a top level logical line ending with a block:
    this is the first line of the block
    this is the
         second line of the block
    this is the third line of the block:
        this is the first line of a subblock
        this is the second line
                of the subblock:
            this is the only line of a sub-subblock
        this is the third line of the subblock
    this is the fourth line
            of the block:
        this is the only line of the second subblock
    this is the fifth line of the block
         and it ends with an empty subblock:
this is the second top level
     logical line
\end{verbatim}\end{indpar}

A warning message is output if two indents that are being compared
differ by more than \TT{0} and
less than \TT{2} columns, in order to better detect
indentation mistakes.

{\em Line-break} lexemes are effectively ignored.  A sequence
of {\em line-break} lexemes is followed by an {\em indent}
or {\em end-of-file} which is not ignored.
Blank physical lines are represented by sequences of
more than one {\em line-break} lexeme, and are effectively
ignored.

A logical line that contains {\em comments}, but no
lexemes other than {\em comments}, {\em line-breaks}, {\em indents}
and a possible {\em end-of-file}, is
a `\key{comment line}'.

It is an error to begin non-comment logical lines with
a {\em comment}.
{\em Comments} can be used freely in the middle of or at the
end of any logical line, or at the beginning of a comment line.

It is an error for the first logical line of a file
to have an indent that is greater than \TT{0}, the top level
indent.

It is an error for a block to be in the middle of a logical
line.  This means that the first {\em indent} following the
block must have an indent no greater than that of the logical
line containing the block.

Examples are:
\begin{indpar}\begin{verbatim}
// this is a logical line that is a single comment

// this is a logical line that has two
    // comments

this is a logical line // with a comment
     // and another comment
     with three comments // and a last comment

this is a logical line ending with a block:
     First line of the block
     Second line of the block
// Comment that ends block
// Comment that is in error because
    it begins a logical line that this continues

this is a logical line with a block:
     First line of the block
     Second line of the block
  but the block is in error because it is before
  this continuation of the logical line that contains
  the block

this is a logical line ending with a block:
        First line of the block
        Second line of the block
  // comments that end the block, but are in error,
  // because they continue the logical line
  // containing the block
\end{verbatim}\end{indpar}

After a logical line
has been formed, any {\em indent},
{\em comment}, {\em line-break}, and {\em end-of-file}
lexemes in the logical line
are removed from the logical line.  If the result is
empty, e.g., the logical line is a comment line, it is discarded.
Otherwise the
modified logical line becomes a L-Language
`\emkey{statement}'\label{STATEMENT}.

Therefore a file is a sequence of top-level statements.

Since a logical line can end with a block that itself consists
of a sequence of logical lines, a statement can end with
a block that itself consists of a sequence of statements.

\newpage

\section{Expressions}

Expressions\footnote{
L-Language expressions are
layered system standard operator parsing pass
expressions with the addition of some
operators.}
are built from operators, such as \TT{+} and \TT{*},
and primaries, such as variable names and function calls.

Operators are characterized by fixity, precedence, and format.
The L-Language operators are listed in
Figures~\itemref{L-LANGUAGE-LINE-OPERATORS-1},
~\itemref{L-LANGUAGE-LINE-OPERATORS-2},
~\itemref{L-LANGUAGE-NON-LINE-OPERATORS-1},
and~\itemref{L-LANGUAGE-NON-LINE-OPERATORS-2}.


Given this, expressions have the following syntax,
where an {\em P-expression}
is an expression all of whose operators that are outside brackets
have precedence equal to or greater than P:

\begin{indpar}
\emkey{expression}\label{EXPRESSION} ::= {\em (L-1)-expression}
\\[0.5ex]
\emkey{P-expression} ::=
    \begin{tabular}[t]{@{}l}
    {\em P-initial-operators}\QMARK{} \\
    \{ {\em (P+1)-expression} $|$ {\em P-middle-operator)} \}\PLUS{} \\
    {\em P-final-operators}\QMARK{} \\
    \end{tabular}
\\[0.5ex]
\emkey{P-basic-expression} ::=
    \begin{tabular}[t]{@{}l}
    {\em P-initial-operator}\QMARK{} \\
    \{ {\em (P+1)-expression} $|$ {\em P-middle-operator)} \}\PLUS{} \\
    {\em P-final-operator}\QMARK{} \\
    \end{tabular}
\\[0.5ex]
\emkey{P-initial-operators} ::= {\em P-prefix-operator}\STAR{}
				{\em P-initial-operator}
\\[0.5ex]
\emkey{P-final-operators} ::= {\em P-final-operator}
				{\em P-postfix-operator}\STAR{}
\\[0.5ex]
\emkey{(H+1)-expression} ::= {\em non-operator}\PLUS{}
\\[0.5ex]
\emkey{P-operator} ::= operator of precedence P
\\[0.5ex]
\emkey{P-initial-operator} ::= {\em P-operator} with \TT{initial} flag
\\[0.5ex]
\emkey{P-final-operator} ::= {\em P-operator} with \TT{final} flag
\\[0.5ex]
\emkey{P-middle-operator} ::= {\em P-operator} with \underline{neither}
                              \TT{initial} nor \TT{final} flag
\\[0.5ex]
\emkey{P-prefix-operator} ::= {\em P-operator} with \underline{both}
                              the \TT{initial} and \TT{right} flags
\\[0.5ex]
\emkey{P-postfix-operator} ::= {\em P-operator} with \underline{both}
                               the \TT{final} and \TT{left} flags
\\[2.0ex]
where in a {\em P-expression}: \\
\hspace*{1em}\begin{tabular}[t]{l}
       P is any precedence in the range [L-1,H]; \\
       no two {\em (P+1)-expressions} may be adjacent; \\ 
       each {\em P-operator} with a \TT{left} flag must be
              preceded by a {\em (P+1)-expression}; \\
       each {\em P-operator} with a \TT{right} flag must be
	  followed by a {\em (P+1)-expression}; \\
       any operator with an \TT{afix} flag must not be the first
           {\em P-operator} \\
       ~~~~~~~~in a {\em P-expression}; \\
       no operator may have both a \TT{initial} and a \TT{left} flag; \\
       no operator may have both a \TT{right} and a \TT{final} flag; \\
       no operator may have both a \TT{initial} and an \TT{afix} flag; \\
       if there is more than one operator in a
           {\em P-expression-initial-operators}, \\
       ~~~~~~~~implicit `\TT{(}' left parentheses are inserted between
                                 operators; \\
       if there is more than one operator in a
           {\em P-expression-final-operators}, \\
       ~~~~~~~~implicit `\TT{)}' right parentheses are inserted between
                                 operators; \\
       if the implicit parentheses are not balanced, implicit parentheses \\
       ~~~~~~~~are inserted at the beginning or end to balance the
               implicit parentheses;
       \end{tabular}
\end{indpar}

Essentially the expression being parsed is organized into {\em P-expressions}
where $P$ is the precedence of the {\em P-expression}.  Generally
a {\em P-expression} consists of a sequence of {\em (P+1)-expressions}
and operators of precedence $P$.
If a {\em P-expression} is not a {\em P-basic-expression}, implicit
parentheses are inserted to make the {\em P-expression} into a
{\em P-basic-expression} that contains a subexpression that is
also a {\em P-basic-expression}.  As an example of this, if `{\tt -}'
is a prefix operator, `{\tt - - x}' is converted to the equivalent
of `{\tt - (- x)}'.

The operators can have any combination of the following \key{base fixities}:

\begin{center}
\begin{tabular}{lp{5.0in}}
\ttkey{initial}	& {\em P-operator} must be the first thing
                  in its {\em P-expression}. \\
\ttkey{final}	& {\em P-operator} must be the last thing
                  in its {\em P-expression}. \\
\ttkey{left}	& {\em P-operator} must be immediately
                  preceded by a {\em (P+1)-expression}
                  in its {\em P-expression}. \\
\ttkey{right}	& {\em P-operator} must be immediately
                  followed by a {\em (P+1)-expression}
                  in its {\em P-expression}. \\
\ttkey{afix}	& {\em P-operator} must be after a (not necessarily
                  immediately) preceding {\em P-operator}
                  in its {\em P-expression}. \\
\end{tabular}
\end{center}

The following \key{combination fixities} are defined:

\begin{center}
\begin{tabular}{ll}
\ttkey{prefix}	& {\tt initial} + {\tt right} \\
\ttkey{infix}	& {\tt left} + {\tt right} \\
\ttkey{postfix}	& {\tt left} + {\tt final} \\
\ttkey{nofix}	& none of {\tt initial}, {\tt final}, {\tt left},
                  or {\tt right} \\
\end{tabular}
\end{center}

All of these but {\tt initial} and {\tt prefix} can be combined with {\tt afix}.

\newpage

\begin{boxedfigure}[!p]
\begin{center}
Line Level Operators: Part I \\
Must Occur Outside Parentheses and Brackets \\
At Top Level or Inside \{* \ldots{} *\}
\\[1ex]
\begin{tabular}{|l|l|l|l|r|}
\hline
Operator & Meaning & Fixity & Format & Precedence \\
\hline
\ttkey{if} & conditional & prefix & conditional & 0000
\\\cline{1-1}
\ttkey{else if} & & & &
\\\cline{1-4}
\ttkey{else} & terminating & initial & terminating & \\
             & conditional & & conditional &
\\\cline{1-4}
\ttkey{:} & conditional & afix & (none) & \\
                   & completion & right & &
\\\cline{1-3}
\key{subblock} & conditional & afix & & \\
               & or declaration &      & & \\
               & completion &      & &
\\\cline{2-4}
	       & assignment & postfix & postfix & \\
	       & or loop    &         &         &
\\\cline{1-4}
\ttkey{type} & declaration & prefix & declaration &
\\\cline{1-1}
\ttkey{pointer type} & & & &
\\\cline{1-1}
\ttkey{\begin{tabular}[t]{@{}l@{}}
       out-of-line\\
       ~~function
       \end{tabular}} & & & &
\\\cline{1-1}\cline{3-3}
\ttkey{function} & & right & &
\\\cline{1-1}
\ttkey{\begin{tabular}[t]{@{}l@{}}
       reference\\
       ~~function
       \end{tabular}} & & & &
\\\cline{1-1}\cline{3-4}
\ttkey{is type} & & afix & (none) &
\\\cline{1-1}
\ttkey{is function} & & infix & &
\\\cline{1-4}
\ttkey{\ABV} & abbreviate & infix & binary &
\\\hline
\ttkey{=} & assignment & left & assignment & 1000
\\\cline{1-4}
\ttkey{+=} & increment & infix & binary &
\\\cline{1-2}
\ttkey{-=} & decrement & & &
\\\cline{1-2}
\ttkey{*=} & multiply by & & &
\\\cline{1-2}
\ttkey{/=} & divide by & & &
\\\cline{1-2}
\ttkey{|=} & include & & &
\\\cline{1-2}
\ttkey{\&=} & mask & & &
\\\cline{1-2}
\ttkey{\textasciicircum=} & flip & & &
\\\cline{1-2}
\ttkey{<{}<=} & shift left & & &
\\\cline{1-2}
\ttkey{>{}>=} & shift right & & &
\\\hline
\ttkey{@=} & pointer & infix & binary & 1100 \\
           & assignment & & &
\\\hline
\end{tabular}
\end{center}

\caption{L-Language Line Operators: Part I}
\label{L-LANGUAGE-LINE-OPERATORS-1}
\end{boxedfigure}

\begin{boxedfigure}[!p]
\begin{center}
Line Level Operators: Part II \\
Must Occur Outside Parentheses and Brackets \\
At Top Level or Inside \{* \ldots{} *\}
\\[1ex]
\begin{tabular}{|l|l|l|l|r|}
\hline
Operator & Meaning & Fixity & Format & Precedence \\
\hline
\ttkey{loop} & iterator & prefix & unary & 3000
\\\cline{1-1}
\ttkey{while} &       &        &       &
\\\cline{1-1}
\ttkey{until} &       &        &       &
\\\cline{1-1}\cline{4-4}
\ttkey{exactly} &       &        & iteration       &
\\\cline{1-1}
\ttkey{at most} &       &        &       &
\\\cline{1-4}
\ttkey{times} & iteration & afix   & (none) & \\
               & modifier &        &       &
\\\hline
\end{tabular}
\end{center}

\caption{L-Language Line Operators: Part II}
\label{L-LANGUAGE-LINE-OPERATORS-2}
\end{boxedfigure}

\begin{boxedfigure}[!p]
\begin{center}
Non-Line Level Operators: Part I \\
May Occur Inside or Outside Parentheses and Brackets
\\[1ex]
\begin{tabular}{|l|l|l|l|r|}
\hline
Operator & Meaning & Fixity & Format & Precedence \\
\hline
\ttkey{,} & separator & nofix & separator & 2000
\\\hline
\ttkey{if} & selector & infix & selector & 10000
\\\cline{1-1}\cline{3-4}
\ttkey{else} & & infix & (none) & \\
             & & afix & &
\\\hline
\ttkey{BUT NOT} & logical and not & infix & binary & 11000
\\\hline
\ttkey{AND} & logical and & infix & n-ary & 11100
\\\cline{1-2}
\ttkey{OR}  & logical or  & & &
\\\hline
\ttkey{NOT}  & logical not & prefix & unary & 11200
\\\hline
\ttkey{==}  & is equal & infix & infix & 12000
\\\cline{1-2}
\ttkey{!=}  & is not equal & & &
\\\cline{1-2}
\ttkey{<}  & is less than & & &
\\\cline{1-2}
\ttkey{<=}  & is less than or equal & & &
\\\cline{1-2}
\ttkey{>}  & is greater than & & &
\\\cline{1-2}
\ttkey{>=}  & is greater than or equal & & &
\\\hline

\end{tabular}
\end{center}

\caption{L-Language Non-Line Operators}
\label{L-LANGUAGE-NON-LINE-OPERATORS-1}
\end{boxedfigure}

\clearpage

\begin{boxedfigure}[!t]
\begin{center}
Non-Line Level Operators: Part II \\
May Occur Inside or Outside Parentheses and Brackets
\\[1ex]
\begin{tabular}{|l|l|l|l|r|}
\hline
Operator & Meaning & Fixity & Format & Precedence \\
\hline
\ttkey{+}  & addition & infix & sum & 13000
\\\cline{1-2}
\ttkey{-}  & subtraction & & &
\\\cline{1-2}\cline{4-4}
\ttkey{|}  & bitwise or & & n-ary &
\\\cline{1-2}
\ttkey{\&}  & bitwise and & & &
\\\cline{1-2}
\ttkey{\textasciicircum}  & bitwise xor & & &
\\\hline
\ttkey{/}  & division & infix & binary & 13100
\\\cline{1-2}\cline{4-5}
\ttkey{*}  & multiplication & & n-ary & 13200
\\\cline{1-2}\cline{4-5}
\ttkey{**}  & exponentiation & & binary & 13300
\\\cline{1-2}
\ttkey{<{}<}  & left shift & & &
\\\cline{1-2}
\ttkey{>{}>}  & right shift & & &
\\\hline
\ttkey{+}  & no-op & prefix & unary & H-1
\\\cline{1-2}
\ttkey{-}  & negation & & & 
\\\cline{1-2}
\ttkey{\textasciitilde}  & bitwise complement & & & 
\\\cline{1-2}
\ttkey{\#}  & length & & & 
\\\cline{1-2}
\ttkey{D\#}  & decimal rational & & & 
\\\cline{1-2}
\ttkey{B\#}  & binary rational & & & 
\\\cline{1-2}
\ttkey{X\#}  & hexadecimal rational & & & 
\\\cline{1-2}
\ttkey{C\#}  & character rational & & & 
\\\hline

\end{tabular}
\end{center}

\caption{L-Language Non-Line Operators}
\label{L-LANGUAGE-NON-LINE-OPERATORS-2}
\end{boxedfigure}

The operators in
Figures~\itemref{L-LANGUAGE-LINE-OPERATORS-1},
~\itemref{L-LANGUAGE-LINE-OPERATORS-2},
~\itemref{L-LANGUAGE-NON-LINE-OPERATORS-1},
and~\itemref{L-LANGUAGE-NON-LINE-OPERATORS-2}
have precedences in
the range {\em [L,H]}.
Precedence {\em (L-1)} is reserved for the `error operator' which is a
nofix operator inserted by the parser to `fix up' parsing errors
so parsing can continue.  Precedence {\em (H-1)} is reserved for prefix
operators and precedence {\em H} is reserved for postfix operators
(although not all prefix and postfix operators have these precedences).

The first {\em P-operator} in a {\em P-expression} determines
the {\em P-expression}'s \key{format}, which is one of the following,
where in describing expression formats we use:
\begin{center}
`expression' to mean {\em P-expression}, \\
`operator' to mean {\em P-operator}, \\
and `operand' to mean {\em (P+1)-expression}:
\end{center}
\begin{center}
\begin{tabular}{p{1in}p{5.0in}}
\ttkey{conditional}
    & The expression must consist of the operator followed by an
      operand followed by either a \TT{:} operator and an
      operand or by just a subblock operator (\TT{:} indented paragraph,
      which can be an operator).
\\[0.5ex]
\ttkey{\begin{tabular}[t]{@{}l@{}}terminating\\conditional\end{tabular}}
    & The expression must consist of the operator followed by
      either a \TT{:} operator and an
      operand or by just a subblock operator.
\end{tabular}
\\[0.5ex]
\begin{tabular}{p{1in}p{5.0in}}
\ttkey{postfix}
    & The expression must consist of an operand followed by the operator.
\end{tabular}
\\[0.5ex]
\begin{tabular}{p{1in}p{5.0in}}
\ttkey{declaration}
    & The expression must consist of an operator followed by
      an operand (that may contain {\tt =} and {\tt ,}) followed sometimes
      by a subblock operator.
\end{tabular}
\\[0.5ex]
\begin{tabular}{p{1in}p{5.0in}}
\ttkey{binary}
    & The expression must consist of an operand followed by
      the operator followed by an operand.  There must be only one
      operator in the expression.
\end{tabular}
\\[0.5ex]
\begin{tabular}{p{1in}p{5.0in}}
\ttkey{assignment}
    & The expression must consist of an operand followed by
      the operator followed by an \underline{optional} operand.
\end{tabular}
\\[0.5ex]
\begin{tabular}{p{1in}p{5.0in}}
\ttkey{selector}
    & The expression operators must all be either \TT{if} or \TT{else}.
      The expression must consist of alternating operands
      and operators and begin and end with an operand.
      The two possible operators alternate, with \TT{if} first
      and \TT{else} last.
\end{tabular}
\\[0.5ex]
\begin{tabular}{p{1in}p{5.0in}}
\ttkey{separator}\label{SEPARATOR-FORMAT}
    & All operators in the expression must be identical.
      There are no other constraints on the expression.  An implied empty
      operand is inserted between two consecutive operators,
      at the beginning if the expression begins with an operator,
      and at the end if the expression ends with an operator.
      Then the operators are deleted from the expression and
      the expression operator is attached
      to the expression as its \TT{.separator} attribute.
\end{tabular}
\\[0.5ex]
\begin{tabular}{p{1in}p{5.0in}}
\ttkey{infix}
    & The expression must consist of alternating operands
      and operators and begin and end with an operand.
\\[1ex]
\ttkey{n-ary}
    & All operators in the expression must be identical.
      The expression must consist of alternating operands
      and operators and begin and end with an operand.
\end{tabular}
\\[0.5ex]
\begin{tabular}{p{1in}p{5.0in}}
\ttkey{unary}
    & The expression must consist of
      the operator followed by an operand.
\\[1ex]
\ttkey{iteration}
    & The expression must consist of
      the operator followed by an operand optionally followed
      by the afix operator `\TT{times}',
\end{tabular}
\\[0.5ex]
\begin{tabular}{p{1in}p{5.0in}}
\ttkey{sum}
    & The expression operators must all be either \TT{+} or \TT{-}.
      The expression must consist of alternating operands
      and operators and begin and end with an operand.
\end{tabular}
\end{center}

There is an additional special syntactic rule:
\begin{enumerate}
\item Non-line bitwise operators (\TT{|}, \TT{\&}, \TT{\textasciicircum},
\TT{<{}<}, \TT{>{}>}, and \TT{\textasciitilde}) cannot be mixed
with non-line arithmetic operators
(\TT{+}, \TT{-}, \TT{/}, \TT{*}, and \TT{**})
outside parentheses in a subexpression.
E.g., `{\tt x + (y * \textasciitilde{} z)}'
is illegal but `{\tt x + (y * (\textasciitilde{} z))}' is legal.
\end{enumerate}


Full semantics of operators and expressions is described later,
but the following examples give an idea of some of this semantics:

\begin{indpar}
\hspace*{-0.2in}{\tt T v \TT{=} x + y * z} \\
       Here {\tt T} is the \key{target type} of the expression
       `{\tt x + y * z}' and thus must be the result type of the prototype
       of the `{\tt +}' function, since function results cannot be
       implicitly converted.  Because it is the result type of {\tt +} and
       arithmetic operators (with a few exceptions)
       have operands that are of the same
       type as their result,
       {\tt T} is also the target type of {\tt x} and {\tt *}, and since it is
       the target type of {\tt *} it will be the target type of {\tt y}
       and {\tt z}.  Implicit conversions of variables are allowed,
       so {\tt x}, {\tt y}, and {\tt z} will all be converted
       to type {\tt T} before any computation is done.

\hspace*{-0.2in}{\tt T v \TT{=} x \TT{if} y \TT{else} z} \\
      If {\tt y} is not a {\tt const}, it is evaluated with
      target type {\tt bool}.  If that value
      is {\tt true}, {\tt x} is evaluated and returned; otherwise
      {\tt z} is evaluated and returned.  Both {\tt x} and {\tt z},
      have target type {\tt T}.

      However if {\tt y} is a {\tt const} value, the right-side of
      the statement is replaced by {\tt x} or {\tt z}, whichever
      is discarded is also not compiled, and if it would be in error
      were it compiled, the error is not detected (unless it is a parsing
      error).

\hspace*{-0.2in}{\tt bool v = x \TT{AND} y} \\
      If either operand evaluates to {\tt FALSE},
      compile-time evaluation stops and the statement is replaced by
      `{\tt bool v \TT{=} FALSE}'.

      Otherwise same as `{\tt bool v \TT{=} y if x else FALSE}'.

      The {\tt const} values {\tt TRUE}
      and {\tt FALSE} are implicitly convertible to run-time {\tt bool}
      {\tt true} ({\tt 1}) and {\tt false} ({\tt 0}), respectively.
 
\hspace*{-0.2in}{\tt x \TT{<} y \TT{<} z} \\
      This is logically equivalent to `{\tt x < y} AND {\tt y < z}', except that
      {\tt y} is evaluated at most once.

      If any comparison evaluates to {\tt FALSE} at compile-time,
      compile-time evaluation stops and the entire expression is replaced by
      `{\tt FALSE}'.

      If a single comparison evaluates to {\tt TRUE} at compile-time,
      that comparison is removed from the {\tt AND}-containing version
      of the expression.

      If run-time evaluation is necessary,
      some operands need to be evaluated
      at run-time, and a target type {\tt T} needs to be found for
      these operands.
      A single target type {\tt T} must work as the target type of all
      the run-time operands.  If one of the operands is a call
      to an explicit conversion function, the type of that conversion
      is the only one considered (i.e., if one operand has the form
      {\tt T (\ldots)} then {\tt T} is the target type for all the
      operands).  Otherwise if some of the operands are reference expressions,
      their types are tried.  If neither of these methods works,
      it is a compile error.

      Thus changing the expression to `{\tt T(x) < y < z}' will force
      the target type to be {\tt T} if that works, or a compile
      error otherwise.

\hspace*{-0.2in}{\tt v[x+5] \TT{=} y} \\
      The target type of subscript expressions such as `{\tt x + 5}'
      is {\tt int}.

\hspace*{-0.2in}{\tt \TT{\textasciitilde} x} \\
       The `{\tt \textasciitilde}' operator
       evaluates on signed integers as if they were represented
       in two's complement by binary values of unbounded size,
       and similarly for other bitwise operators.

\hspace*{-0.2in}{\tt x \TT{**} y} \\
       Requires that {\tt y} be a {\tt const} integer;
       {\tt x ** 0 \TT{==} 1}, {\tt x ** 1 \TT{==} x},
       {\tt x ** -1 \TT{==} 1/x} for all {\tt x}.

\hspace*{-0.2in}{\tt x \TT{+=} y} \\
	Means `{\tt x \TT{=} x + y}', where {\tt x} must be {\tt *READ-WRITE*}.

\hspace*{-0.2in}{\tt next x \TT{+=} y} \\
	Means `{\tt next x = x + y}'.  `{\tt next x}' must be defined.
\end{indpar}

\section{Primaries}
\label{PRIMARIES}

A \key{primary} is an {\em expression} that has no operators outside
parentheses or brackets:
\begin{indpar}
\emkey{primary}
    \begin{tabular}[t]{@{}rll}
    ::= & {\em constant-primary} \\
    $|$ & {\em reference-expression}    & [\pagref{REFERENCE-EXPRESSIONS}] \\
    $|$ & {\em function-call}		& [\pagref{FUNCTION-CALLS}] \\
    $|$ & {\em bracketed-expression}	& [\pagref{BRACKETED-EXPRESSIONS}] \\
    \end{tabular}
\\[0.5ex]
\emkey{constant-primary} ::= {\em constant} other than {\em rational-constant}
\\[0.5ex]
{\em constant} ::= see \pagref{CONSTANTS}
\\[0.5ex]
{\em rational-constant} ::= see \pagref{RATIONAL-CONSTANTS}

\end{indpar}

Note that a {\em rational-constant} is an operator (e.g. {\tt D\#})
followed by a {\em string-constant}, and therefore contains an operator
and is not a {\em primary}.

\subsection{Names}
\label{NAMES}

A \key{name} is a sequence of lexemes used to name things like
variables and functions.  Names are building blocks of primaries.

\begin{indpar}
\emkey{name}\label{NAME} ::=
    {\em initial-name-item} {\em continuing-name-item}\STAR{} \\
\emkey{initial-name-item} ::= {\em name-item} other than {\em natural} \\
\emkey{continuing-name-item} ::= {\em name-item} not containing `\TT{.}' \\
\emkey{name-item}\label{NAME-ITEM}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em word} containing no `\TT{.}' that follows a character
                     that is not a `\TT{.}' \\
        & [see text about splitting words with embedded `\TT{.}'s] \\
    $|$ & {\em natural} [see \pagref{LEXEME-TYPE-CONVERSION}] \\
    $|$ & {\em quoted-word} containing no `\TT{.}' that follows a character \\
        & that is not the beginning \TT{"} or another `\TT{.}' \\
    $|$ & {\em quoted-mark} containing no `\TT{.}' that follows a character \\
        & that is not the beginning \TT{"} or another `\TT{.}' \\
    $|$ & {\em quoted-separator} not containing `\TT{.}'s \\
    \end{tabular} \\
\emkey{quoted-word} :::= \TT{"} {\em word} \TT{"} \\
\emkey{quoted-mark} :::= \TT{"} {\em mark} \TT{"} \\
\emkey{quoted-separator} :::= \TT{"} {\em separator} \TT{"}

\begin{itemize}
\item `\TT{.}'s must appear at the beginning of {\em words}
and {\tt marks} (examples: `\TT{..size}' and `\TT{.*}').
See text about splitting {\em words} and {\em marks}
with embedded `\TT{.}'s.
\end{itemize}
\end{indpar}

{\em Words} and {\em marks} containing embedded `\TT{.}'s are split into
parts which contain `\TT{.}'s only at their beginning.
Thus:
\begin{center}
\begin{tabular}{lcl}
\TT{bill.1.weight..size} & splits into & \TT{bill~~~.1~~~.weight~~~~..size} \\
\TT{p.@.*}               & splits into & \TT{p~~~.@~~~.*} \\
\TT{.@.*}               & splits into & \TT{.@~~~.*} \\
\TT{.,.*}               & splits into & \TT{.,~~~.*} \\
\TT{.*.p}               & splits into & \TT{.*~~~.p} \\
\end{tabular}
\end{center}
However it is a compile error if one of the parts is not a {\em word}
or {\em mark}, as in the examples where {\tt .1} is a {\em number} and
{\tt .,} is not a legal lexeme.

{\em Quoted-words} and {\em quoted-marks} are \underline{not} split.

A function may be defined with a {\em name} that is a {\em quoted-word}
or {\em quoted-mark},
such as {\tt "AND"} or {\tt "+"}.
It may then be called by an expression in which the
quotes are omitted, such as {\tt x AND y} or {\tt x + y}.
Similarly a function may be
defined with a function-term {\tt ".*"} and called by the expression
{\tt p.*} which is split into {\tt p .*}.


Name items beginning with more than one `\TT{.}' are reserved
for use by systems and compilers (e.g., \TT{..size} in the examples).
Name items that are words containing `\TT{\$}' or that both
begin and end with `\TT{*}' are
similarly reserved.  For example, words of the form `\TT{T\$}\ldots'
are reserved for use as type wildcards, and the word \TT{*READ-WRITE*}
is reserved for use as a qualifier.

A name may begin with a {\em word} that is a {\em module-abbreviation}
that designates a code module: see~\itemref{MODULE-AND-BODY-DECLARATIONS}.
For example {\tt std} abbreviates the builtin standard module.

L-Language uses many kinds of names (the numbers in brackets refer to
rules below):

\begin{indpar}
\emkey{simple-name} ::= {\em word} not containing any `\TT{.}'s or `\TT{@}'s
    [\ref{FUNCTION-KEYWORD-RULE},
     \ref{OPERATOR-RULE},
     \ref{QUALIFIER-RULE}] \\
\emkey{module-abbreviation}\label{MODULE-ABBREVIATION} ::= {\em simple-name} \\
\emkey{ma} ::= {\em module-abbreviation} \\
\emkey{pointer-type-name}\label{POINTER-TYPE-NAME} ::=
    \MA{} {\em simple-name}
    [\ref{POINTER-TYPE-NAME-RULE}] \\
\\[1ex]
\emkey{basic-name}\label{BASIC-NAME} ::=
	\begin{tabular}[t]{@{}l}
	{\em name} not containing a `\TT{.}', {\em quoted-mark}, or
	    {\em quoted-separator} \\{}
	[\ref{MODULE-ABBREVIATION-RULE},
	 \ref{FUNCTION-KEYWORD-RULE},
	 \ref{OPERATOR-RULE},
	 \ref{QUALIFIER-RULE}] \\
	\end{tabular} \\
\emkey{type-name}\label{TYPE-NAME} ::=
    \MA{} {\em basic-name} not containing `\TT{@}'s
	[\ref{TYPE-NAME-RULE}] \\
\emkey{variable-name}\label{VARIABLE-NAME} ::=
    \MA{} {\em basic-name} \\
\emkey{function-variable-name}\label{FUNCTION-VARIABLE-NAME} ::=
    {\em variable-name} \\
\emkey{pointer-variable}\label{POINTER-VARIABLE} ::=
    {\em variable-name} whose {\em basic-name} begins with one or more
    `\TT{@}'s \\
\emkey{target-variable}\label{TARGET-VARIABLE} ::=
    {\em variable-name} whose {\em basic-name} does \underline{not}
    begin with an \TT{@} \\
\emkey{statement-label} ::= {\em basic-name}
    \label{STATEMENT-LABEL} not containing `\TT{@}'s
\\[1ex]
\emkey{member-name}\label{MEMBER-NAME}
	::= \begin{tabular}[t]{@{}l@{}}
                        {\em name} beginning with a {\em word} or
			{\em quoted-mark} containing a `\TT{.}', \\
			but not containing a {\em quoted-separator}
			[\ref{FUNCTION-KEYWORD-RULE},
			 \ref{OPERATOR-RULE},
			 \ref{QUALIFIER-RULE}] \\
			(note: all `\TT{.}'s in a {\em name} must be at
			 the beginning of the {\em name})
			\end{tabular} \\
\emkey{pointer-member-name}\label{POINTER-MEMBER-NAME} ::=
    {\em member-name} with one or more `\TT{@}'s
    following the initial `\TT{.}'s \\
\emkey{target-member-name}\label{TARGET-MEMBER-NAME} ::=
    {\em member-name} that is \underline{not} a {\em pointer-member-name}
\\[1ex]
\emkey{data-label}\label{DATA-LABEL} ::=
    {\em basic-name} $|$ {\em member-name}
\\[1ex]
\emkey{function-term-name} ::= {\em name} not containing a `\TT{.}'
    \label{FUNCTION-TERM-NAME}
	[\ref{MODULE-ABBREVIATION-RULE},
	 \ref{FUNCTION-KEYWORD-RULE},
	 \ref{OPERATOR-RULE},
	 \ref{QUALIFIER-RULE}] \\
\\[1ex]
\emkey{qualifier-name}\label{QUALIFIER-NAME}
    \begin{tabular}[t]{rl}
    ::= & \ttkey{co} $|$ \ttkey{ro} $|$ \ttakey{READ-WRITE}
                     $|$ \ttakey{WRITE-ONLY} \\
    $|$ & \ttakey{GLOBAL} $|$ \ttakey{HEAP} $|$ \ttakey{INIT} \\
    \end{tabular}
\begin{indpar}
{\tt co} abbreviates `constant' meaning `never changes' \\
{\tt ro} abbreviates `read-only' meaning `other code may change' \\
{\tt *GLOBAL*} has global (forever) lifetime \\
{\tt *HEAP*} has lifetime managed by a garbage collector \\
{\tt *INIT*} forces write-only during initialization
\end{indpar}
\emkey{operator-word}
    \begin{tabular}[t]{rl}
    ::= & \TT{if} $|$ \TT{else} $|$ \TT{while} $|$ \TT{until}
                  $|$ \TT{AND} $|$ \TT{OR}
		  $|$ \TT{NOT} $|$ \TT{BUT}
    \end{tabular}

\emkey{function-keyword}
    \begin{tabular}[t]{rl}
    ::= & \TT{no} $|$ \TT{not} $|$ \TT{function} \\
    $|$ & \TT{"="} $|$ \TT{","} $|$ \TT{"("} $|$ \TT{")"} $|$
          \TT{"["} $|$ \TT{"]"}
    \end{tabular}

\emkey{wild-card}\label{WILD-CARD}
    ::= {\em simple-name} beginning with {\em wild-card-prefix}

\emkey{wild-card-prefix}\label{WILD-CARD-PREFIX} :::= one of: \\
\hspace*{0.2in}\begin{tabular}{rp{4in}}
\ttkey{T\$} & name is assigned a {\em type-name} \\
\ttkey{P\$} & name is assigned a {\em pointer-type-name} \\
\ttkey{Q\ldots\$} & {\em qualifier-wild-card}; name is assigned a
                    list of {\em qualifier-names} subject to
		    {\em qualifier-wild-card-flags} `\ldots'\\
\end{tabular}

\emkey{qualifier-wild-card-flag}\label{QUALIFIER-WILD-FLAG} :::= one of: \\
\hspace*{0.2in}\begin{tabular}{rl}
\ttkey{R} & readable, excludes {\tt *WRITE-ONLY*} \\
\ttkey{W} & writable, excludes {\tt ro} and {\tt co} \\
\ttkey{U} & allows undeclared
            (i.e., neither \TT{*GLOBAL*} ~or \TT{*HEAP*}) \\
\ttkey{G} & allows \TT{*GLOBAL*} \\
\ttkey{H} & allows \TT{*HEAP*} \\
\end{tabular}
\end{indpar}

The name resolver treats a sequence of
names in certain contexts as having the form:
\begin{center}
\begin{tabular}{l}
\{ {\em qualifier-name}\STAR{} ~ {\em pointer-type-name}\}\STAR{} \\
\hspace*{0.5in}{\em qualifier-name}\STAR{} ~
{\em type-name} ~ {\em variable-name}
\end{tabular}
\end{center}
where any {\em pointer-type-name}, {\em type-name}, or {\em variable-name}
may begin with a {\em module-abbre\-via\-tion}.
While scanning this sequence from left to right,
the name resolver does \underline{not} back up after identifying
a {\em qualifier-name}, {\em module-abbreviation}, {\em pointer-type-name}
or {\em type-name} in the sequence.  As a consequence, the
following rules should be followed, least there be
various confusing syntax or semantic errors (some
violations of these rules will be detected as compilation errors,
but some will not be):
\begin{enumerate}
\item\label{MODULE-ABBREVIATION-RULE}
{\em Basic-names} and {\em function-term-names}
should not begin with a {\em module-abbre\-viation}.
\item\label{FUNCTION-KEYWORD-RULE}
{\em Names} should not contain {\em function-keywords}.
\item\label{OPERATOR-RULE}
{\em Names} that are not themselves operator names should not
begin with {\em initial-operators},
end with {\em final-operators}, or contain {\em middle-operators}.
\item\label{TYPE-NAME-RULE}
A {\em type-name} should not begin with a {\em pointer-type-name}.
\item\label{POINTER-TYPE-NAME-RULE}
A {\em pointer-type-name} should not begin with a {\em type-name}.
\item\label{QUALIFIER-RULE}
{\em Names} that are not {\em qualifier-names}
should not contain {\em qualifier-names}, with the
exception that a {\em qualifier-name} by itself can be
a {\em function-term-name}.
\end{enumerate}

{\em Variable-names}, {\em type-names}, and {\em pointer-type-names}
that begin with a {\em module-abbreviation} are called
\key{external}\label{EXTERNAL-NAME}.
Non-external names are called \key{internal}\label{INTERNAL-NAME}.

Names can abbreviate other names, using the statement:
\begin{indpar}
\emkey{abbreviation-statement}\label{ABBREVIATION-STATEMENT} ::=
    {\em abbreviating-name}~ \ABV{}~ {\em abbreviated-name}
\end{indpar}
For example:
\begin{center}
\tt bool \ABV{} std bool
\end{center}

Note that it is whole names that are abbreviated, and not parts of
names.

The \ABV{} operator executes at compile time.  The {\em abbreviation-statement}
must be within the scope\pagnote{SCOPE}
of a definition of the {\em abbreviated-name},
which must be one of the following kinds:
\begin{center} \em
pointer-type-name \\
type-name \\
qualifier-name \\
pointer-variable \\
target-variable \\
statement-label \\
pointer-member-name \\
target-member-name
\end{center}
The {\em abbreviating-name} will be of the same kind as the
{\em abbreviated-name}, and must follow the syntax rules of that
kind.  For example, if the {\em abbreviated-name}
is a {\em target-name}, the {\em abbreviating-name} cannot begin with
`\TT{@}', and if the {\em abbreviated-name} begins with $N>0$ `\TT{@}'s,
the {\em abbreviating-name} must begin with exactly $N$ `\TT{@}'s.

Note that {\em function-term-names} used in {\em function-calls}
cannot be abbreviated.


\subsection{Constants}
\label{CONSTANTS}

A \key{constant} is a value of type \ttkey{const} computed at
compile-time.  One type of constant, the map constant, is not
actually constant and can be changed.

There are five of types of constants:

\begin{indpar}
\emkey{constant}\label{CONSTANT}
    \begin{tabular}[t]{rl}
    ::= & {\em special-constant} \\
    $|$ & {\em string-constant} \\
    $|$ & {\em number-constant} \\
    $|$ & {\em rational-constant} \\
    $|$ & {\em map-constant} \\
    \end{tabular} \\
\emkey{special-constant} 
    \begin{tabular}[t]{@{}rl}
    ::= & \ttkey{TRUE} $|$ \ttkey{FALSE}
                       $|$ \ttkey{UNDEF} $|$ \ttkey{NONE} \\
    $|$ & \ttkey{*LOGICAL-LINE*} $|$ \ttkey{*INDENTED-PARAGRAPH*} \\
    \end{tabular} \\
\emkey{string-constant}\label{STRING-CONSTANT} ::= {\em quoted-string}
\end{indpar}

The meanings of the {\em special-constants} are:
\begin{indpar}[1.6in]
\begin{itemize}
\item[\TT{TRUE}] The boolean value true.  Convertible to {\tt bool ( 1 )}.
\item[\TT{FALSE}] The boolean value false.  Convertible to {\tt bool ( 0 )}.
\item[\TT{UNDEF}] The value exists but is undefined (unknown).
\item[\TT{NONE}] The value does not exist.
\item[\TT{*LOGICAL-LINE*}] see Section \itemref{PARSER-OUTPUT}
\item[\TT{*INDENTED-PARAGRAPH*}] see Section \itemref{PARSER-OUTPUT}
\end{itemize}
\end{indpar}
A special constant is not equal to any other constant.
The constant {\tt TRUE} can be implicitly converted to the
run-time {\tt bool} value {\tt 1}.
The constant {\tt FALSE} can be implicitly converted to the
run-time {\tt bool} value {\tt 0}.

A \emkey{string-constant} is just a {\em quoted-string} lexeme
that denotes a character string: see
\pagref{QUOTED-STRING} and \pagref{QUOTED-STRING-CONCATENATION}.

String constants can be used to load run-time vectors
with {\tt uns8}, {\tt uns16}, or {\tt uns32} type elements.
UTF-8, UTF-16, or UTF-32 encodings are used according to element
size.

A \emkey{number-constant}\label{NUMBER-CONSTANT}
is an {\em natural}, {\em number},
or {\em numeric-word} lexeme converted to an IEEE 64-bit floating
point number.

A number constant may be converted to a run-time
number type such as {\tt int32} or {\tt flt64}.
It is a compile error to convert to an integer type that cannot
hold the exact value of the number.
Conversion to a run-time floating type is however
never a compile error.  If necessary the converted value is
{\tt +Inf} or {\tt -Inf} or loses precision.

{\em Rational-constants} and {\em map-constants} are described in the
following sections.


\subsubsection{Rational Constants}
\label{RATIONAL-CONSTANTS}

A \key{rational constant} is a rational number with unbounded
numerators and denominators, where the
denominator is at least 1 and the numerator and denominator
have no common factors (other than 1).  If the denominator is 1, the
rational is called a \key{rational integer}.

Non-negative rational constants may be computed at compile-time
by the prefix operators:
\begin{center}
\begin{tabular}{ll}
\bf Operator	& Argument String
\\[1ex]
\TT{D\#}	& {\em decimal-constant-string} \\
\TT{B\#}	& {\em binary-constant-string} \\
\TT{X\#}	& {\em hexadecimal-constant-string} \\
\TT{C\#}	& {\em character-constant-string} \\
\end{tabular}
\end{center}

Each of these operators takes a {\tt const} string as its sole argument.
The syntax of the argument strings is:

\begin{indpar}
\emkey{sign} :::= \TT{+} $|$ \TT{-} \\
\emkey{exponent} :::=
	\{ \TT{e} $|$ \TT{E} \} {\em sign}\QMARK{} {\em dit}\PLUS{}
\\[0.5ex]
\emkey{decimal-constant-string} \\
\hspace*{0.5in}
    \begin{tabular}[t]{@{}rl}
    :::= & \TT{"}~ {\em decimal-natural}~ {\em decimal-fraction}\QMARK{}~
    				          {\em exponent}\QMARK{}~ \TT{"} \\
     $|$ & \TT{"}~ {\em decimal-natural}~ \TT{/}~
                   {\em decimal-natural}~ \TT{"} \\
    \end{tabular}
\\[0.5ex]
\emkey{decimal-natural}
    :::= {\em dit}\PLUS{} 
         \{ \TT{,} {\em dit} {\em dit} {\em dit} \}\STAR{} \\
\emkey{decimal-fraction} :::=
    \TT{.} \{ {\em dit} {\em dit} {\em dit} \TT{,} \}\STAR{}
           {\em dit}\PLUS{} \\
\emkey{dit}\label{DIT}
	:::= \TT{0} $|$ \TT{1} $|$ \TT{2} $|$ \TT{3} $|$ \TT{4}
                    $|$ \TT{5} $|$ \TT{6} $|$ \TT{7} $|$ \TT{8} $|$ \TT{9}
\\[0.5ex]
\emkey{binary-constant-string} \\
\hspace*{0.5in}
    \begin{tabular}[t]{@{}rl}
    :::= & \TT{"}~ {\em binary-natural}~ {\em binary-fraction}\QMARK{}~
    				          {\em exponent}\QMARK{}~ \TT{"} \\
     $|$ & \TT{"}~ {\em binary-natural}~ \TT{/}~
                   {\em binary-natural}~ \TT{"} \\
    \end{tabular}
\\[0.5ex]
\emkey{binary-natural}
    :::= {\em bit}\PLUS{}
           \{ \TT{,} {\em bit} {\em bit} {\em bit} {\em bit} \}\STAR{} \\
\emkey{binary-fraction} :::=
    \TT{.} \{ {\em bit} {\em bit} {\em bit} {\em bit} \TT{,} \}\STAR{}
    {\em bit}\PLUS{} \\
\emkey{bit} :::= \TT{0} $|$ \TT{1}
\\[0.5ex]
\emkey{hexadecimal-constant-string} \\
\hspace*{0.5in}
    \begin{tabular}[t]{@{}rl}
    :::= & \TT{"}~ {\em hexadecimal-natural}~
                   {\em hexadecimal-fraction}\QMARK{}~
		   {\em exponent}\QMARK{}~ \TT{"} \\
     $|$ & \TT{"}~ {\em hexadecimal-natural}~ \TT{/}~
                   {\em hexadecimal-natural}~ \TT{"} \\
    \end{tabular}
\\[0.5ex]
\emkey{hexadecimal-natural}
    :::= {\em hit}\PLUS{}
           \{ \TT{,} {\em hit} {\em hit} \}\STAR{} \\
\emkey{hexadecimal-fraction} :::=
    \TT{.} \{ {\em hit} {\em hit} \TT{,} \}\STAR{}
    {\em hit}\PLUS{} \\
\emkey{hit} :::= \TT{0} $|$ \TT{1} $|$ \TT{2} $|$ \TT{3} $|$ \TT{4}
	     $|$ \TT{5} $|$ \TT{6} $|$ \TT{7} $|$ \TT{8} $|$ \TT{9}
	     $|$ \TT{a} $|$ \TT{b} $|$ \TT{c} $|$ \TT{d} $|$ \TT{e} $|$ \TT{f}
	     $|$ \TT{A} $|$ \TT{B} $|$ \TT{C} $|$ \TT{D} $|$ \TT{E} $|$ \TT{F}
\\[0.5ex]
\emkey{character-constant-string} :::=
	\TT{"}~ {\em character-representative}~ \TT{"}
\\[0.5ex]
{\em character-representative} :::= see \pagref{CHARACTER-REPRESENTATIVE}
\\[1ex]
where
\begin{enumerate}
\item Denominators in fractions must not be zero.
\end{enumerate}

\end{indpar}

Decimal naturals may have commas
every 3 digits from the end and decimal fractions may have
commas every 3 digits from the decimal point.
Similarly for binary naturals and fractions with commas every 4 binary
digits,
and with hexa-decimal naturals and fractions with commas every 2
hexa-decimal digits.
If there is a decimal point, there \underline{must}
be at least one integer digit and
one fraction digit.

For decimal constants without \TT{/} the denominator is specified by the
exponent and is a power of \TT{10}; for
binary constants, a power of \TT{2}; and for
hexadecimal constants, a power of \TT{16}.

The value of a character constant is the integral UNICODE code point of the
{\em character-representative}.

Negative rational constants can be computed at compile-time by applying
the minus operator `\TT{-}' to a non-negative rational constant.

A rational constant may be converted to a run-time number
type such as {\tt int32} or {\tt flt64}.
It is a compile error to convert to an integer type that cannot
hold the exact value of the rational constant.
Conversion of a rational constant
to a run-time floating type is however
never a compile error.  If necessary the converted value is
{\tt +Inf} or {\tt -Inf} or precision is lost.

There are also run-time {\tt D\#}, {\tt B\#}, and {\tt X\#}
operators (see \pagref{RUN-TIME-STRING-TO-NUMBER-CONVERSIONS}),
but rationals cannot be stored at run-time.

\subsubsection{Map Constants}
\label{MAP-CONSTANTS}

A \key{map constant} has two parts, a list (a.k.a, a vector) and a dictionary.
Either or both can be empty.

A map constant is computed by an {\em expression} whose syntax is:

\begin{indpar}
\emkey{map-constant}\label{MAP-CONSTANT}
    \begin{tabular}[t]{rl}
    ::= & \TT{\{} \TT{\}} \\
    $|$ & \TT{\{} {\em map-list} \TT{\}} \\
    $|$ & \TT{\{} {\em map-dictionary} \TT{\}} \\
    $|$ & \TT{\{} {\em map-list}\TT{,} {\em map-dictionary} \TT{\}} \\
    $|$ & {\em phrase-constant} \\
    $|$ & {\em expression-constant} \\
    $|$ & {\em type-constant} \\
    $|$ & {\em pointer-type-constant} \\
    \end{tabular}
\\[0.5ex]
\emkey{map-list} ::= {\em list-element} \{ \TT{,} {\em list-element} \}\STAR{}
\\[0.5ex]
\emkey{map-dictionary} ::= {\em dictionary-entry}
                              \{ \TT{,} {\em dictionary-entry} \}\STAR{}
\\[0.5ex]
\emkey{dictionary-entry} ::=
    {\em dictionary-label} \TT{=>} {\em dictionary-value}
\\[0.5ex]
\emkey{list-element}\label{LIST-ELEMENT} ::= {\em constant-expression}
\\[0.5ex]
\emkey{dictionary-label}\label{DICTIONARY-LABEL}
    ::= {\em constant-expression} evaluating to a string
\\[0.5ex]
\emkey{dictionary-value}\label{DICTIONARY-VALUE}
    ::= {\em constant-expression}
\\[0.5ex]
{\em constant-expression} ::= a {\tt const} valued {\em expression} as
    defined on \pagref{CONSTANT-EXPRESSION}
\\[0.5ex]
{\em expression} ::= see \pagref{EXPRESSION}
\\[0.5ex]
\emkey{phrase-constant} ::= \TT{`} {\em expression} \TT{'}
\\[0.5ex]
\emkey{expression-constant} ::= \TT{\{*} {\em expression} \TT{*\}}
\\[0.5ex]
\emkey{type-constant} ::= {\em type-name}
\\[0.5ex]
\emkey{pointer-type-constant} ::= {\em pointer-type-name}
\\[0.5ex]
{\em type-name} ::= see \pagref{TYPE-NAME}
\\[0.5ex]
{\em pointer-type-name} ::= see \pagref{POINTER-TYPE-NAME}
\end{indpar}

Maps \underline{cannot} be represented at run-time.

By abuse of language, \key{list} is used to refer to a map whose
dominant mode of usage is to go through the map list elements
sequentially.  Similarly \key{vector} is used to refer to a map whose
dominant mode of usage is to access the map list elements randomly
using subscripts.  And \key{dictionary} is used to refer to a map
whose dominant mode of usage is to access the map's dictionary elements.

Dictionary entries are also called \skey{attribute}s.  For lists and
vectors, they are also called \skey{annotation}s.

Each {\em map-constant}
creates a distinct map: no two such maps are \TT{==}.  A map created
by a {\em map-constant} is initially set so that it and all its dictionary
entries are read-only.  This can be changed: see \pagref{READ-ONLY-MAP}.

An \emkey{expression-constant}\label{EXPRESSION-CONSTANT}
is shorthand for the {\em map-constant}
produced when the {\em expression} is parsed: see \pagref{PARSER-OUTPUT}.
Generally, parsing an expression groups expression elements into
sublists and moves bracket and separator punctuation to annotations
(dictionary entries).  Some examples are:
\begin{center} \tt
\begin{tabular}{l@{~~~}l}
\rm The expression:	& \rm Is equivalent to:
\\\hline
\{* X = ( Y + 1 ) *\}	& \{ \{ "X" \}, "=", \\
			&  ~~\{ \{ "Y" \}, "+", \{ 1 \}, ".initiator" =>"(", \\
			& ~~~~~~~~~~~~~~~~~~~~~~~~~".terminator" =>")" \} \}
\\[0.5ex]
\{* X, Y = Y, X *\}	& \{ \{ "X", "Y", ".separator" => "," \}, \\
			&  ~ "=", \\
			&  ~ \{ "Y", "X", ".separator" => "," \} \}
\\[0.5ex]
\{* X + Y * Z *\}	& \{ \{ "X" \}, "+", \{ \{ "Y" \}, "*", \{ "Z" \} \} \}
\\[0.5ex]
\{* X 3 = Y Z + 1 *\}	& \{ \{ "X", 3 \}, "=",
                             \{ \{ "Y", "Z" \}, "+", \{ 1 \} \} \}
\end{tabular}
\end{center}
In an \TT{\{*} {\em expression} \TT{*\}} constant,
line level operators (those in
Figures~\itemref{L-LANGUAGE-LINE-OPERATORS-1}
and~\itemref{L-LANGUAGE-LINE-OPERATORS-2})
are recognized if and only if
they are outside parentheses in the {\em expression}.

\emkey{Phrase-constants}\label{PHRASE-CONSTANT}
are like {\em expression-constants} except that
operators (including separators, e.g. `{\tt ,}') are not recognized.
Brackets are recognized and create sublists.  Some examples contrasting
with {\em expression-constants} are:
\begin{center} \tt
\begin{tabular}{l@{~~~}l}
\rm The Expression:	& \rm Is Equivalent To:
\\\hline
`X = Y + 1'			& \{ "X", "=", "Y", "+", 1 \}
\\[0.5ex]
\{* X = Y + 1 *\}		& \{ \{ "X" \}, "=",
                                     \{ \{ "Y" \}, "+", \{ 1 \} \} \}
\\[0.5ex]
`X = ( Y + 1 )'		& \{ "X", "=", \{ "Y", "+", 1, \\
                        & ~~~~~~~~~~~~~~".initiator" => "(", \\
                        & ~~~~~~~~~~~~~~".terminator" => ")" \} \}
\\[0.5ex]
\{* X = ( Y + 1 ) *\}	& \{ \{ "X" \}, "=", \{ \{ "Y" \}, "+", \{ 1 \}, \\
                        & ~~~~~~~~~~~~~~~~~~".initiator" => "(", \\
                        & ~~~~~~~~~~~~~~~~~~".terminator" => ")" \} \}
\end{tabular}
\end{center}

Map constants containing parsed code can be computed
by {\em include-assignment-statements}:
see \pagref{INCLUDE-ASSIGNMENT-STATEMENT}.

{\em Type-names} and {\em pointer-type-names} can be used at
compile-time as if they were variables of type {\tt const}
with map values.  These map values are partly read-only,
with the read-only part including elements with labels like
{\tt .size} for the size in bits of run-time values of the type.
Users can add their own elements if these do not conflict
with the names of the read-only elements.  See \pagref{TYPE-MAPS}.

\subsection{Reference Expressions}
\label{REFERENCE-EXPRESSIONS}

A \emkey{reference-expression} computes a \key{reference pointer} to a location.
In some cases the {\em reference-expression}
computes a \key{real reference pointer} that can be stored in a variable.
In other cases a \key{virtual reference pointer} is computed that
can only be used by the {\em reference-expression} to read a value from the
location or write a value into the location.

{\em Reference-expressions} are simple or compound.
A \key{simple} {\em reference-expression} is
a {\em variable-name}, `\TT{next} {\em variable-name}', or
{\em function-variable-name}.
A \key{compound} {\em reference-expression} consists of two parts:
a \key{base} that is a smaller {\em reference-expression},
and an \key{offset} that follows the base with
a \TT{[} or {\em member-name}
(which begins with `\TT{.}': see \pagref{MEMBER-NAME}).

Every {\em reference-expression} begins with a simple
{\em reference-expression} called the \key{root} of the
{\em reference-expression}.  The root is then followed by zero or more
offsets.

The full syntax of a {\em reference-expression} is:

\begin{indpar}
\emkey{reference-expression}\label{REFERENCE-EXPRESSION}
    \begin{tabular}[t]{rl}
    ::= & {\em simple-reference-expression} \\
    $|$ & {\em reference-base} ~ {\em reference-offset} \\
    \end{tabular}
\\[0.5ex]
\emkey{simple-reference-expression}\label{SIMPLE-REFERENCE-EXPRESSION}
    \begin{tabular}[t]{rl}
    ::= & {\em variable-name} \\
    $|$ & \TT{next}~ {\em variable-name} \\
    $|$ & {\em function-variable-name} \\
    \end{tabular}
\\[0.5ex]
\emkey{reference-base}\label{REFERENCE-BASE}
    ::= {\em reference-expression}
\\[0.5ex]
\emkey{reference-offset}\label{REFERENCE-OFFSET}
    \begin{tabular}[t]{rl}
    ::= & {\em member-name} \\
    $|$ & {\em index-list} \\
    $|$ & {\em member-name} ~ {\em index-list} \\
    \end{tabular}
\\[0.5ex]
\emkey{index-list} ::= \TT{[} {\em index} \{ \TT{,} {\em index} \}\STAR{} \TT{]}
\\[0.5ex]
\emkey{index}\label{REFERENCE-INDEX}
    ::= {\em expression}
\\[0.5ex]
{\em variable-name} ::= see \pagref{VARIABLE-NAME}
\\[0.5ex]
{\em function-variable-name} ::= see \pagref{FUNCTION-VARIABLE-NAME}
\\[0.5ex]
{\em member-name} ::= see \pagref{MEMBER-NAME}
\begin{enumerate}
\item
An {\em expression} with no operators that begins
with a {\em variable-name} or `\TT{next} {\em vari\-able-name}'
and which is not followed
by an explicitly or implicitly parenthesized subexpression
is a {\em reference-expression}.

Otherwise an {\em expression} with no operators is one of:
\begin{enumerate}
\item a {\em constant}\pagnote{CONSTANT}, or
\item
a (non-reference) {\em function-call}\pagnote{FUNCTION-CALL}, or
\item
an explicitly parenthesized subexpression
preceded by a {\em module-abbreviation}
(see \pagref{MA-SYNTACTIC-SUGAR} for more information about this last case)
\end{enumerate}
\item In a {\em reference-expression},
{\em module-abbreviation} may appear as part of a
({\em function-}){\em variable-name}, but may \underline{not} appear
elsewhere.
A ({\em function-}){\em variable-name} with a {\em module-abbreviation}
names a different variable or reference function than does the same
name without the {\em module-abbreviation}.
\item
One dimensional indexing can be used with \TT{av} and \TT{fv} pointers,
and with user defined pointer types that convert to \TT{av} or \TT{fv}
pointers.
Multi-dimensional indexing can be used with {\em member-names}
of multi-dimensional fields and subfields.  Multi-dimensional indexing
can also be used with {\em reference-offsets} defined by
{\em reference-functions}: see Reference Function Declarations,
\itemref{REFERENCE-FUNCTION-DECLARATIONS}.

\end{enumerate}
\end{indpar}

Examples of reference pointers are:
\begin{indpar}\small\begin{verbatim}
type my type:
    int X;
    ap mytype @Y

my type Z:       // A virtual pointer is computed to the variable Z.
    Z.X = 5      // A virtual pointer to Z.X is computed.
    Z.@Y = null  // A virtual pointer to Z.@Y is computed.
                 // This is virtual both because it points into the
                 // local stack where Z is, and also because it points
                 // at a location whose type is a pointer type.

ap my type @W:   // A real pointer @W is computed to the variable W.
    W.X = 5      // A real pointer to W.X (denotable by @W.X) is computed.
    W.@Y = null  // A virtual pointer to W.@Y is computed.
                 // The pointer is virtual because it points at a pointer.
    W.@Y = @W    // A virtual pointer to @W is computed and dereferenced
                 // to make a real pointer that is the value of `@W'.
                 // W.@Y now points at W.
\end{verbatim}\end{indpar}

Generally a run-time reference pointer
is virtual if and only if it points into a
local or global stack or it points at a location containing a value of
pointer type.
Compile time reference pointers (involving {\tt const} values) are always
virtual, and consist of either a pointer into a compile-time local or
global stack, or a map/index pair.


A virtual reference pointer is replaced by the value it points at in
the following situations:
\begin{itemize}
\item It was computed by a {\em reference-base} in a compound
{\em reference-expression} and it points at
a run-time pointer value or a compile-time map {\tt const} value.
\item It was computed by an entire run-time {\em reference-expression}
with a {\em pointer-variable} root, it points at a pointer value, and
the {\em reference-expression} is being used to produce a real reference
pointer value and not to store a value.
\end{itemize}

If the root of a {\em reference-expression} is a {\em pointer-variable}
(beginning with \TT{@}), the reference pointer computed by the entire
{\em reference-expression} is \underline{not}
dereferenced, and it is an error if the reference pointer is not real.
If the root is a {\em target-variable}, the reference
pointer is dereferenced, and the pointer may be virtual.

{\em Reference-expressions} can call {\em reference-functions} to perform
all or some of their computations.  There are two kinds of
{\em reference-functions}:
\begin{itemize}
\item\key{Function Variables}:~~
These functions
are invoked by {\em function-variable-names} that are syntactically
like {\em variable-names} which are {\em simple-reference-expressions} and
possibly the roots of compound {\em reference-expressions}.
\item\key{Function Offsets}:~~
These functions are invoked by {\em reference-offsets} in
compound {\em reference-expressions}
that act like postfix operators on
real reference pointers produced by the bases of the
compound {\em reference-expressions}.
\end{itemize}

For details on calls to {\em reference-functions}
see Reference Functions\pagnote{REFERENCE-FUNCTION-DECLARATIONS}.
The rest of this section applies to {\em reference-expressions}
that do \underline{not} make these calls.

A {\em member-name} of the form `\TT{.}{\em data-label}\,'
may be used to select a field or subfield\label{FIELD-SELECTION}
of a user defined type\pagnote{TYPE-DECLARATIONS} value or
a dictionary entry of a {\em map-dictionary}.

An {\em index} may be used to select an element of a vector
or array in a
user defined type value, or the
element of a vector pointed at by a pointer, or an element
of a {\em map}.  An {\em index} can be a {\em const}
string.  In general, if \TT{"$S$"} is a {\tt const} string,
\TT{["$S$"]} is equivalent to `\TT{.$S$}'.  This can be used
with a run-time {\em reference-expression}
as a field or subfield label, or with a compile-time
{\em reference-expression} to select a map {\em dictionary-entry}.

Otherwise the
{\em index} must be a positive or negative integer.  Bounds imposed
by user defined types or stored in a pointer are used to
check that the {\em index} is within range.
The target type of a run-time {\em index} is \TT{int}.


The type of a run-time {\em reference-expression}
is computed bottom up starting with the type of the root.
Run-time virtual reference pointers are just like real reference
pointers of \TT{ap} or \TT{fp} type, except that a virtual pointer
may point into the run-time local or global
stack or may point at a pointer datum.  The reference pointer for
a {\em variable-name} root of the reference expression is in essence an \TT{ap}
pointer with {\tt co} or {\tt *INIT*} qualifier pointing into
the local or global stack.  {\em Reference-offsets} modify this as the
{\em reference-expression} is computed.  At some point the virtual
reference pointer may point at a real pointer datum and be replaced
by that real pointer datum according to the rules above.

When a {\em member-name} {\em reference-offset} specifying a field
in a user defined type modifies a
virtual or real reference pointer, the qualifiers of the resulting reference
pointer are determined according to 
Figure~\ref{REFERENCE-EXPRESSION-QUALIFIER-COMPUTATION}.%
\label{QUALIFIER-COMPUTATION}
The target type of the modified pointer is provided by the 
{\em member-name} {\em reference-offset}, which may also change the
(effective) pointer type of the modified reference pointer from
\TT{ap} to \TT{fp}.
Note that if the qualifiers of the unmodified reference pointer
are {\tt co} or {\tt *INIT*}, these remain the qualifiers of the
modified reference pointer.

\begin{boxedfigure}[!t]
\newcommand{\tts}{\tt \small}
\begin{center}
Reference Expression Result \\
Pointer Target or Value Qualifiers \\
Given Base and Field Qualifiers
\\[1ex]
\begin{tabular}{|l|c|c|c|c|c|}
\multicolumn{1}{l}{Base}	\\
\multicolumn{1}{l}{Access}	& \multicolumn{5}{c}{Field Access Qualifier}
\\\cline{2-6}
\multicolumn{1}{l|}{Qualifier}
       & (none) & \tt co & \tt ro & \tts *READ-WRITE* & \tts *WRITE-ONLY*
\\\hline
\tt co & \tt co & \tt co & \tt co & \tt co & (illegal)
\\\hline
\tt ro & \tt ro & \tt co & \tt ro & \tt ro & (illegal)
\\\hline
\tts *READ-WRITE* & \tts *READ-WRITE* & \tt co & \tt ro & \tts *READ-WRITE*
		  & \tts *WRITE-ONLY*
\\\hline
\tts *WRITE-ONLY* & \tts *WRITE-ONLY* & (illegal) & (illegal)
                 & \tts *WRITE-ONLY* & \tts *WRITE-ONLY*
\\\hline
\tts *INIT* & \tts *INIT* & \tts *INIT* & \tts *INIT* & \tts *INIT*
            & \tts *INIT*
\\\hline
\end{tabular}
\\[1ex]
\begin{minipage}{6.0in}
\raggedright
\begin{enumerate}
\item Here\label{INIT-FORCING}
{\tt *INIT*} is a pseudo-qualifier used for bases
that are being initialized.  It has the same effect as {\tt *WRITE-ONLY*}
except that it forces fields/subfields of the base to be {\tt *INIT*}
even if they are {\tt co} or {\tt ro}.
\item The {\em reference-expression} has the same lifetime qualifier
({\tt *GLOBAL*}, {\tt *HEAP*}, or undeclared )
and lifetime depth as the base (see \itemref{LIFETIMES}).
\end{enumerate}
\end{minipage}
\end{center}

\caption{Reference Expression Qualifier Computation}
\label{REFERENCE-EXPRESSION-QUALIFIER-COMPUTATION}
\end{boxedfigure}

Computing types of reference pointers is a bottom-up process,
and is different from computing types of general
sub-{\em expressions}, which are top-down using a target type
provided by the {\em statement} containing the sub-{\em expression}.
Since the type of a {\em reference-expression} does not depend on
its containing {\em statement}, implicit conversion of a
{\em reference-expression} value to a {\em statement} provided
target type is allowed, whereas implicit conversion
of a sub-{\em expression} that is a {\em function-call}
is \underline{not} allowed.

Reference pointers at compile-time either point into the compile-time
local or global stacks or consist of a map/index pair of {\tt const}
value.  These pointers always point at a {\tt const} value, and
are always virtual -- there are no real compile-time reference pointers.
A {\em reference-offset} always dereferences the current reference point
to a {\tt const} value that must be a map, and then forms a map/index
pair for the new referenc pointer.

Map {\tt const} values are represented internally by pointers to where
the map is stored, so that if {\tt X} is a variable equal to,
i.e., pointing at, a map, then {\tt Y = X} copies the pointer
to the map to the variable {\tt Y}.  By default map constants
are read-only and cannot be changed, but it is possible to mark
a whole map as read-write, and to independently mark dictionary members
as either read-only or read-write.
Dictionary members are marked read-only when they are initially created.

The following example illustrates
computation with map constants:
\begin{indpar}\begin{verbatim}
const U = {"A", "B"}[0]  // Illegal: {"A". "B"} is not a simple
                         // reference expression.
const X = {"A", "B"}
const V = X[0]           // Legal, == "A".
X[0] = "C"               // Illegal, X is read-only.
read-write ( X )
X[0] = "C"               // Now X is {"C", "B"}.
const Y = X              // Now X and Y are both {"C", "B"}. 
Y[1] = "D"               // Now X and Y are both {"C", "D"}. 
const Z = { Y, "M" }     // Now Z is {{"C", "D"}, "M"}.
Z[0].W = "N"             // Now Z is {{"C", "D", "W" => "N"}, "M"},
                         // X and Y are both {"C", "D", "W" => "N"}.
X.W = "P"                // Illegal, X.W is read-only.
read-write ( X, "W" )
X.W = "P"                // X and Y are both {"C", "D", "W" => "P"}.
                         // Now Z is {{"C", "D", "W" => "P"}, "M"},
\end{verbatim}\end{indpar}

\subsection{Function Calls}
\label{FUNCTION-CALLS}

The syntax of function calls is:

\begin{indpar}
\emkey{function-call}\label{FUNCTION-CALL} ::= \\
\hspace*{0.5in}
        {\em module-abbreviation}\QMARK{}
        {\em parenthesized-call-argument-list}\STAR{}
        {\em call-term}\PLUS{}
\\[0.5ex]
\emkey{call-term}\label{CALL-TERM}
    \begin{tabular}[t]{rl}
    ::= & {\em call-term-name} {\em call-argument-list}\STAR{} \\
    $|$ & \ttkey{no} {\em call-term-name} \\
    $|$ & \ttkey{not} {\em call-term-name} \\
    \end{tabular}
\\[0.5ex]
\emkey{call-term-name}\label{CALL-TERM-NAME} ::=
    \begin{tabular}[t]{@{}l}
    {\em function-term-name} with quotes \underline{optionally} removed from \\
    {\em quoted-words}, {\em quoted-marks}, and {\em quoted-separators}
    \end{tabular}
\\[0.5ex]
{\em function-term-name} ::= see \pagref{FUNCTION-TERM-NAME}
\\[0.5ex]
\emkey{call-argument-list}\label{CALL-ARGUMENT-LIST}
    \begin{tabular}[t]{rl}
    ::= & \TT{(} {\em actual-argument}
          \{ \TT{,} {\em actual-argument} \}\STAR{} \TT{)} \\
    $|$ & \TT{[} {\em actual-argument}
          \{ \TT{,} {\em actual-argument} \}\STAR{} \TT{]} \\
    $|$ & \TT{(~)} $|$ \TT{[~]} \\
    \end{tabular}
\\[0.5ex]
\emkey{parenthesized-call-argument-list}%
    \label{PARENTHESIZED-CALL-ARGUMENT-LIST} ::= \\
\hspace*{0.5in}
    {\em call-argument-list} with parentheses \TT{(~)}
    (and \underline{not} square brackets \TT{[~]})
\\[0.5ex]
\emkey{actual-argument} ::= {\em expression}
\\[0.5ex]
{\em expression} ::= see \pagref{EXPRESSION}
\begin{enumerate}
\item {\em Call-term-names} cannot be abbreviated.
\item {\em Call-terms} of the form `{\tt no x}' and `{\tt not x}' are
equivalent to `{\tt x(FALSE)}'.
\item {\em Parenthesized-call-argument-lists} may have implicit
parentheses.
\item\label{PARENTHESIZED-ARGUMENT-LIST-RULE}
There must be at least one explicit or implicit
{\em parenthesized-call-argument-list} just before or just
after the first {\em call-term-name} (to distinguish {\em function-calls}
from {\em reference-expressions}).
\end{enumerate}
\end{indpar}

Thus a {\em function-call} is an optional {\em module-abbreviation}
followed by a sequence of {\em function-term-names}
and {\em call-argument-lists}.  Note that {\em Function-term-names} cannot
contain `\TT{.}'s and therefore cannot be {\em member-names},
which are reserved for {\em reference-calls}\pagnote{REFERENCE-CALL}.
Also any \TT{[~]} bracketed {\em call-argument-lists} must be preceded by
a {\em paraenthesized-call-argument-list},
a syntactic distinction to their use in {\em reference-calls}.

{\em Function-calls} are matched to {\em function-prototypes} in
{\em function-declarations}.  The
{\em call-term-names} in a match are identical to the
{\em function-term-names} taken from the prototype being matched, except
that quotes (\TT{"}) in a prototype {\em quoted-word}, {\em quoted-mark}, or
{\em quoted-separator} may (or may not) be omitted in the
{\em function-call}.  The first
step in matching is to scan the {\em function-call} to identify the
{\em call-term-names}.  There is no parser backing up after this is
done: if the results of this initial scan do not lead to a satisfying
match, the entire call-declaration match fails.

\subsection{Bracketed Expressions}
\label{BRACKETED-EXPRESSIONS}

The syntax of a {\em bracketed-expression} is:

\begin{indpar}
\emkey{bracketed-expression}\label{BRACKETED-EXPRESSION}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em ma}\QMARK{} \TT{(} {\em expression} \TT{)} \\
    $|$ & \TT{[} {\em expression} \TT{]} \\
    $|$ & \TT{\{} {\em expression} \TT{\}} \\
    $|$ & \TT{`} {\em expression} \TT{'} \\
    $|$ & \TT{\{*} {\em expression} \TT{*\}} \\
    \end{tabular}
\\[0.5ex]
{\em ma} ::= {\em module-abbreviation} ~~~ [see \pagref{MODULE-ABBREVIATION}]
\end{indpar}

Arithmetic subexpressions and some function argument lists are bracketed
with \TT{()} brackets.  Reference expression index lists and some function
argument lists are bracketed with \TT{[]} brackets.
Expressions that compute map constants
are bracketed with \TT{\{~\}}, \TT{`~'}, or \TT{\{*~*\}},
brackets (see \itemref{MAP-CONSTANTS}).

An expression of the form `{\em ma} \TT{(} {\em expression} \TT{)}' is%
\label{MA-SYNTACTIC-SUGAR}
just syntactic sugar for `\TT{(} {\em ma} {\em expression} \TT{)}', except
that the {\em expression} is parsed before the {\em ma} is moved inside the
\TT{()}'s.  Thus if {\tt mom} is a {\em module-abbreviation},
`{\tt mom ( x + y * z )}' is syntactic sugar for \\
\centerline{\tt ( mom x "+" ( y "*" z ) )}
in which the parenthesis pair surrounding `{\tt y "*" z}' is implied.
This allows the {\em module-abbre\-via\-tion} to be applied to the outermost
operator in the {\em expression}.

\section{Assignment Statements}
\label{ASSIGNMENT-STATEMENTS}

{\em Assignment-statements} have a list of variables on the
left side of an \TT{"="} operator
which receive values from a list of expressions or
a block of code on the right side of the operator.  The left-side variables
and the \TT{"="}
may be omitted if the right side produces no values,
or if all left-side variables
have the form of `{\tt next} {\em variable-name}' and are
implied by the right side.

The forms of an {\em assignment-statement} are:
\begin{indpar}
\emkey{assignment-statement}
    \begin{tabular}[t]{@{}rll}
    ::= & {\em expression-assignment-statement} \\
    $|$ & {\em call-assignment-statement} \\
    $|$ & {\em block-assignment-statement} \\
    $|$ & {\em deferred-assignment-statement} \\
    $|$ & {\em loop-assignment-statement} \\
    $|$ & {\em isolated-declaration-statement} \\
    \end{tabular}
\\[0.5ex]
\emkey{expression-assignment-statement} ::= \\
\hspace*{0.5in} {\em assignment-result}
                \{ \TT{,} {\em assignment-result} \}\STAR{}
		\TT{=} {\em expression-list}
\\[0.5ex]
{\em expression-list} ::= see \pagref{EXPRESSION-LIST}
\\[0.5ex]
\emkey{call-assignment-statement} \\
\hspace*{0.5in} \begin{tabular}{rl}
                ::= & {\em assignment-result}
                      \{ \TT{,} {\em assignment-result} \}\STAR{}
		      \TT{=} {\em assignment-call} \\
		$|$ & {\em assignment-call}
		\end{tabular}
\\[0.5ex]
\emkey{assignment-call} ::= {\em function-call} $|$
                            {\em call-expression}
\\[0.5ex]
{\em function-call} ::= see \pagref{FUNCTION-CALL}
\\[0.5ex]
{\em call-expression} ::= see \pagref{CALL-EXPRESSION}
\\[0.5ex]
\emkey{block-assignment-statement} ::= \\
\hspace*{0.5in}
    \begin{tabular}[t]{@{}rll}
        & {\em block-variable-declaration}
                \{ \TT{,} {\em block-variable-declaration} \}\STAR{} \\
	& ~~~~~ \{ \TT{=} \{ \ttkey{do} {\em block-label} \}\QMARK{} \}\QMARK{}
		   \TT{:} \\
        & ~~~~~~~~~~ {\em statement}\STAR{} \\
        & ~~~~~~~~~~ {\em exit-subblock}\STAR{} \\
    $|$ & \ttkey{do} {\em block-label}\QMARK{} \TT{:} \\
        & ~~~~~ {\em statement}\STAR{} \\
        & ~~~~~ {\em exit-subblock}\STAR{} \\
    \end{tabular}
\\[0.5ex]
\emkey{deferred-assignment-statement} ::= \\
\hspace*{0.5in}
        {\em result-variable-declaration}
	    \{ \TT{,} {\em result-variable-declaration} \}\STAR{}
	    \TT{=} \ttkey{*DEFERRED*}
\\[0.5ex]
\emkey{loop-assignment-statement} ::= \\
\hspace*{0.5in}
    \begin{tabular}[t]{@{}rll}
        & {\em block-variable-declaration}
                \{ \TT{,} {\em block-variable-declaration} \}\STAR{}
		\TT{=} \\
	& ~~~~~~~~~~~~~~~ {\em iteration-control} \TT{:} \\
        & ~~~~~ {\em statement}\STAR{} \\
        & ~~~~~ {\em exit-subblock}\STAR{} \\
    $|$ & {\em iteration-control} \TT{:} \\
        & ~~~~~ {\em statement}\STAR{} \\
        & ~~~~~ {\em exit-subblock}\STAR{} \\
    \end{tabular}
\\[0.5ex]
\emkey{isolated-declaration-statement} ::= {\em result-variable-declaration}
\\[0.5ex]
\emkey{exit-subblock} ::=
    \begin{tabular}[t]{l}
    {\em exit-label} \ttkey{exit}\TT{:} \\
    \TT{~~~~}{\em statement}\STAR{} \\
    \end{tabular}
\\[0.5ex]
{\em iteration-control} ::= see \pagref{ITERATION-CONTROL}
\\[0.5ex]
\emkey{block-label}\label{BLOCK-LABEL} ::= {\em statement-label}
\\[0.5ex]
\emkey{exit-label} ::= {\em statement-label}
\\[0.5ex]
{\em statement-label} ::= see \pagref{STATEMENT-LABEL}
\\[0.5ex]
\emkey{assignment-result}\label{ASSIGNMENT-RESULT}
    \begin{tabular}[t]{@{}rll}
    ::= & {\em block-variable-declaration} \\
    $|$ & {\em reference-expression}
    \end{tabular}
\\[0.5ex]
{\em reference-expression} ::= see \pagref{REFERENCE-EXPRESSIONS}
\\[0.5ex]
\emkey{block-variable-declaration}\label{BLOCK-VARIABLE-DECLARATION}
    \begin{tabular}[t]{@{}rll}
    ::= & {\em result-variable-declaration} \\
    $|$ & {\em next-variable-declaration} \\
    \end{tabular}
\\[0.5ex]
\emkey{result-variable-declaration}\label{RESULT-VARIABLE-DECLARATION} ::= \\
\hspace*{0.5in}\begin{tabular}{rl}
	    & {\em type-name} {\em target-variable} \\
	$|$ & {\em pointer-type-name}
	      \{ {\em qualifier-name}\STAR{} {\em pointer-type-name} \}\PLUS{}
	      \\
	    & ~~~~~~~~{\em qualifier-name}\STAR{} {\em type-name} \\
	    & ~~~~~~~~ {\em pointer-variable} \\
	$|$ & {\em pointer-type-name}
	      {\em qualifier-name}\STAR{} {\em type-name} \\
	    & ~~~~~~~~ {\em pointer-variable}
	               \{ \TT{@=} {\em allocation-call} \}\QMARK{} \\
	\end{tabular}
\\[0.5ex]
\emkey{next-variable-declaration}\label{NEXT-VARIABLE-DECLARATION} \\
\hspace*{0.5in}\begin{tabular}{rl}
      ::= & \ttkey{next} {\em target-variable-name} \\
      $|$ & \ttkey{next} {\em pointer-variable-name}
	      ~ \{ \TT{@=} {\em allocation-call} \}\QMARK{} \\
      \end{tabular}
\\[0.5ex]
{\em qualifier-name} ::= see \pagref{QUALIFIER-NAME}
\\[0.5ex]
{\em pointer-type-name} ::= see \pagref{POINTER-TYPE-NAME}
\\[0.5ex]
{\em type-name} ::= see \pagref{TYPE-NAME}
\\[0.5ex]
{\em variable-name} ::= see \pagref{VARIABLE-NAME}
\\[0.5ex]
{\em target-variable} ::= see \pagref{TARGET-VARIABLE}
\\[0.5ex]
{\em pointer-variable} ::= see \pagref{POINTER-VARIABLE}
\\[0.5ex]
\emkey{allocation-call}\label{ALLOCATION-CALL} ::= {\em function-call}
\\[2ex]
where
\begin{enumerate}
\item If a {\em result-variable-declaration}
has $N>0$ {\em pointer-type-names}, the {\em pointer-variable}
it declares must begin with exactly $N$ `\TT{@}'s.
\item {\em Result-variable-declarations}
with $N>1$ {\em pointer-type-names} can\underline{not} have
{\em alloca\-tion-calls}.
\item For a {\em pointer-variable} with an {\em allocation-call},
the {\em allocation-call} allocates and zeros memory for the
associated {\em target-variable}, and returns a pointer to the
allocated memory that is stored in the {\em pointer-variable}.
For such a {\em pointer-variable} it is the
associated {\em target-variable} that is set by the {\em assignment-statement}.
\item For an {\em isolated-declaration-statement} declaring a
{\em pointer-variable} with no {\em alloca\-tion-call},
`{\tt @= local}' is implied if the {\em pointer-variable}
has no lifetime qualifier (is undeclared), and 
`{\tt @= global}' is implied if the {\em pointer-variable}
has the {\tt *GLOBAL*} qualifier.
\item For an {\em isolated-declaration-statement} `{\tt = *DEFERRED*}'
is implied unless the declaration is of a {\tt *READ-WRITE*}
{\em pointer-variable}.
\item An {\em isolated-declaration-statement} declaring a
{\tt *READ-WRITE*} {\em pointer-variable} (for which
`{\tt = *DEFERRED*}' is \underline{not} implied) is equivalent
to a {\em block-assignment-statement} with an empty subblock.
\end{enumerate}

\end{indpar}

Associated with {\em block-assignment-statements} and
{\em loop-assignment-statements}
there are {\em con\-trol-statements}
to control the flow of execution within the more complex
{\em assignment-state\-ment}:
\begin{indpar}
\emkey{control-statement}\label{CONTROL-STATEMENT}
    \begin{tabular}[t]{@{}rll}
    ::= & {\em block-control-statement}
        & [\pagref{BLOCK-CONTROL-STATEMENT}] \\
    $|$ & {\em loop-control-statement}
        & [\pagref{LOOP-CONTROL-STATEMENT}] \\
    \end{tabular}
\end{indpar}

A {\em \ldots-variable-declaration}\label{VARIABLE-ALLOCATION}
allocates memory for its variables
in the frame of the currently executing out-of-line function.
The sizes of these variables must be known at compile time.
For a {\em pointer-variable} it is the pointer itself that is
allocated to the currently executing out-of-line function; the
memory pointed at can be allocated elsewhere.
For sizes not known at compile time, a pointer to the variable
can be allocated by an {\em allocation-call} that is given the variable
size at run-time.

{\em Expression-assignment-statements} set the values of their result variables
to the values of the {\em expressions} in the {\em expression-list}.
{\em Call-assignment-statements} set the values of their result variables
to the values returned by the {\em function-call}.

A {\em block-variable-declaration}
initializes its variables
according to the declaration syntax as follows:
\begin{indpar}[0.05in]
Non-{\tt next} variable declaration with no {\em allocation-call}\,: \\
\hspace*{3em}The memory is zeroed. \\
{\tt Next} variable declaration with no {\em allocation-call}\,: \\
\hspace*{3em}Previous value of the named variable. \\
Variable declaration with {\em allocation-call}\,: \\
\hspace*{3em}Value returned by the {\em allocation-call}
             (the allocated memory is zeroed).
\end{indpar}
Zeroed numbers are zero, while zeroed pointers typically
cause segmentation faults when de-referenced.

In a {\em block-assignment-statement},
variables declared by {\em block-variable-declarations}
\underline{without} {\em allocation-calls}
are given the qualifier {\tt *INIT*} in {\em statements}
of the {\em block-assignment-statement} and {\tt co} after the
{\em block-assignment-statement}.
The {\tt *INIT*} qualifer is equivalent to {\tt *WRITE-\EOL ONLY*}
except that it forces fields and elements of the value to also
be {\tt *INIT*}\pagnote{INIT-FORCING}.

In a {\em block-assignment-statement},
{\em pointer-variables} declared by {\em block-variable-declarations}
\underline{with} {\em allocation-calls}
are initialized by the {\em allocation-call}
(see \pagref{ALLOCATION-CALLS}) and are thereafter
{\tt co}, but the memory
pointed at is zeroed initially, 
{\tt *INIT*} in {\em statements}
of the {\em block-assignment-statement}, and 
subject to the {\em pointer-variable} {\em qualifiers} after
the {\em block-assignment-statement}.

A {\em loop-assignment-statement} is similar to a
{\em block-assignment-statement} except that variables declared
by {\em next-variable-declarations} are reallocated for each iteration
of the loop, and the value given by the previous iteration can be
read by the current iteration using the {\em variable-name}
(without a preceding `{\tt next}').
Non-{\tt next} variables are allocated only at the start of the
{\em loop-assignment-statement}, and are {\tt *INIT*} (and not readable)
throughout all iterations.

If a {\em declaration} declares a {\em pointer-variable},
an associated {\em target-variable} is implicitly declared at the same time
whose name is the {\em pointer-name} with the initial `{\tt @}' removed.
The {\em target-variable} is not itself allocated to memory,
but instead references the value the {\em pointer-variable}
points at.

Note that a variable declaration does not allow
qualifiers on anything but the target of a pointer.  The implicit
qualifier of a declared variable is {\tt co} after the
{\em assignment-statements} meaning that
the value of the variable once initially set is never changed.
The qualifiers of a {\em target-variable} associated with a
{\em pointer-variable} are {\tt *INIT*} in the subblock {\em statements}
of a {\em block/loop-assignment-statement} and those of the target of
its associated pointer after the
{\em block/loop-assignment-statement}.

A {\em next-variable-declaration} for a {\em variable} {\tt v}
must occur in the scope of either a non-{\em next-variable-declaration}
for {\tt v} or another {\em next-variable-declaration} for {\tt v}.
Furthermore, {\tt v} cannot be a {\em target-variable} associated
with a {\em pointer-variable}.
The {\em next-variable-declaration} re-declares {\tt v} making a new
variable that hides the previously declared {\tt v}.  The new variable
has the same types and qualifiers as the previous variable named {\tt v}.

A {\em next-variable-declaration} for a variable {\tt v} enables
`{\tt next v}' to be used as an {\em assignment-result} within the subblock
{\em statements} of a {\em block/loop assignment-statement}.  Use of
{\tt v} within these statements without the `{\tt next}'
refers to the value of {\tt v} just
before a {\em block-assignment-statement} or current
{\em loop-assignment-statement} iteration was executed.

Under some circumstances `{\tt next v}' will
be implicitly added to the {\em assignment-result}
list of a {\em call-statement} (see \pagref{CALL-NEXT-PROMOTION}),
the {\em block-variable-declaration} list
of a {\em block-assignment-statement} (see \pagref{BLOCK-NEXT-PROMOTION}),
or the {\em block-variable-declaration} list of a
{\em loop-assignment-statement} (see \pagref{LOOP-NEXT-PROMOTION}).

A {\em deferred-assignment-statement}
behaves like a {\em block-assignment-statement} with an empty block,
but in addition allows each of its variables to be redeclared in a subsequent
`companion' {\em block-variable-delcaration} which does not
reallocate the variable (there may be separate companions for different
variables).

For loops\label{LOOP-ALLOCATION},
4 copies of the variables allocated by an iteration
are allocated to the out-of-line function frame when the function is called,
and the loop cycles among these copies.
A call to `{\tt local}' inside a loop stores a pointer value in
one of these 4 copies.  If such a pointer is already
allocated by a previous loop iteration, its memory is reused, or
doubled in size and reallocated.  This means that the total memory allocated
to a pointer inside a loop copy by `{\tt local}' will never be more than
4 times the size of the maximum memory needed for any single loop
iteration.  As there can be 4 copies of the iteration variables,
a call to `{\tt local}' inside a loop
may allocate to the stack at most 4x4 = 16 times as much
memory as any single iteration call to `{\tt local}'.


\subsection{Expression Assignment Statements}
\label{EXPRESSION-ASSIGNMENT-STATEMENTS}

The syntax of an {\em expression-assign\-ment-statement} is:
\begin{indpar}
\emkey{expression-assignment-statement} ::= \\
\hspace*{0.5in} {\em assignment-result}
                \{ \TT{,} {\em assignment-result} \}\STAR{}
		\TT{=} {\em expression-list}
\\[0.5ex]
\emkey{expression-list}\label{EXPRESSION-LIST} ::=
	      {\em expression} \{ \TT{,} {\em expression} \}\STAR{}
\\[0.5ex]
{\em assignment-result} ::= see \pagref{ASSIGNMENT-RESULT}
\\[0.5ex]
{\em expression} ::= see \pagref{EXPRESSION}
\\[2.0ex]
where
\begin{enumerate}

\item The number of {\em expressions} must equal the number
of {\em assignment-results}.

\item The {\em expression-list} must not consist of a single
{\em expression} which is a {\em function-call} (else the
{\em statement} is a {\em call-assignment-statement} as described in
\itemref{CALL-ASSIGNMENT-STATEMENTS}).  However the {\em expression-list}
may consist of a single {\em reference-call}.

\end{enumerate}
\end{indpar}

Sub-{\em expressions} computable at compile-time are evaluated
in bottom-to-top left-to-right order and replaced by their {\tt const} values
before the {\em statement} is compiled into run-time code.
At run-time {\em expressions} are evaluated in bottom-to-top
left-to-right order and
then the {\em expression} values are stored in the {\em assignment-results}.

Variable names declared by {\em result-variable-declarations} that are
{\em assignment-results} are not visible to the {\em expressions}.
In particular, if `{\tt next V}' is an {\em assignment-result},
the name `{\tt V}' in an {\em expression} will refer to the variable
that exists before the {\em expression-assignment-statement}.

The type of an {\em assignment-result} becomes the \key{target type}
of its corresponding {\em expression}.  If the {\em expression}
is a {\em function-call}, the type of the first result of the
{\em function-prototype} must match the target type of the {\em expression},
and the types of the prototype arguments become the target types
of the {\em actual-argument} sub-expressions.

If an {\em expression} is a {\em reference-expression}
or a {\em constant-expression}
(which is replaced by a constant),
it will be implicitly
converted to its target type if possible.

An example is:
\begin{indpar}\begin{verbatim}
int x = 5              // target type of 5 is int
flt y = 6              // target type of 6 is flt
flt z = 7              // target type of 7 is flt
flt r1 = x + y         // target type of +, x, y is flt
flt r2 = x + y * z     // target type of +, x, *, y, z is flt
next x = z             // illegal; target type of z is int
\end{verbatim}\end{indpar}

Here the {\tt +} and {\tt *} operator functions are only defined
for cases where their operand types are the same as their result type,
and {\tt int} variables may be implicitly converted to {\tt flt}
but not vice-versa.

\subsection{Call Assignment Statements}
\label{CALL-ASSIGNMENT-STATEMENTS}

The syntax of a {\em call-assignment-statement} is:
\begin{indpar}
\emkey{call-assignment-statement} \\
\hspace*{0.5in} \begin{tabular}{rl}
                ::= & {\em assignment-result}
                      \{ \TT{,} {\em assignment-result} \}\STAR{}
		      \TT{=} {\em assignment-call} \\
		$|$ & {\em assignment-call}
		\end{tabular}
\\[0.5ex]
\emkey{assignment-call} ::= {\em function-call} $|$
                            {\em call-expression}
\\[0.5ex]
{\em assignment-result} ::= see \pagref{ASSIGNMENT-RESULT}
\\[0.5ex]
{\em function-call} ::= see \pagref{FUNCTION-CALL}
\\[0.5ex]
{\em call-expression} ::= see \pagref{CALL-EXPRESSION}
\end{indpar}

A {\em call-assignment-statement} with {\em assignment-results}
follows the same general rules
as {\em expres\-sion-assignment-state\-ments} except that its right
side is a single {\em function-call} or the functionally similar
{\em call-expression} and the result values of the call are stored
in the {\em assignment-results} proceeding left-to-right.
Excess call results are discarded.  There must be an least as many
call results as there are {\em assignment-results}.

The types of the function prototype results \underline{cannot}
be implicitly converted to the types of the {\em assignment-results}.

\label{CALL-NEXT-PROMOTION}
The right side of a {\em call-assignment-statement} may have
an implied `\TT{next} $v$' if the {\em function-prototype} has 
a `\TT{next} $w$' {\em prototype-result-declaration}
and a {\em prototype-argument-declaration} of the
form `\dots{} {\em type-name} $w$', and $v$ is a {\em variable-name}
that by itself is the actual argument matched to $w$
(see \pagref{PROTOTYPE-NEXT-RESULT}).  An example is:
\begin{indpar}\begin{verbatim}
function next w = inc ( int w ):
    next w = w + 1
int v = 5
inc ( v )    // Equivalent to `next v = v + 1'.
\end{verbatim}\end{indpar}

\subsection{Block Assignment Statements}
\label{BLOCK-ASSIGNMENT-STATEMENTS}

The syntax of {\em block-assignment-statements} is:

\begin{indpar}
\emkey{block-assignment-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{@{}rll}
        & {\em block-variable-declaration}
                \{ \TT{,} {\em block-variable-declaration} \}\STAR{} \\
	& ~~~~~ \{ \TT{=} \{ \ttkey{do} {\em block-label} \}\QMARK{} \}\QMARK{}
		   \TT{:} \\
        & ~~~~~~~~~~ {\em statement}\STAR{} \\
        & ~~~~~~~~~~ {\em exit-subblock}\STAR{} \\
    $|$ & \ttkey{do} {\em block-label}\QMARK{} \TT{:} \\
        & ~~~~~ {\em statement}\STAR{} \\
        & ~~~~~ {\em exit-subblock}\STAR{} \\
    \end{tabular}
\\[0.5ex]
{\em block-variable-declaration} ::=
    see \pagref{BLOCK-VARIABLE-DECLARATION}
\\[0.5ex]
\emkey{exit-subblock}\label{EXIT-SUBBLOCK} ::=
    \begin{tabular}[t]{l}
    {\em exit-label} \ttkey{exit}\TT{:} \\
    \TT{~~~~}{\em statement}\STAR{} \\
    \end{tabular} \\
\emkey{exit-label} ::= {\em statement-label}
\\[0.5ex]
{\em statement-label} ::= see \pagref{STATEMENT-LABEL} \\
{\em statement} ::= see \pagref{STATEMENT}
\\[0.5ex]
\emkey{exception-subblock}\label{EXCEPTION-SUBBLOCK} ::=
    {\em exit-subblock} whose {\em exit-label} is \ttkey{*EXCEPTION*}
\\[0.5ex]
\emkey{block-control-statement}\label{BLOCK-CONTROL-STATEMENT}
	::= {\em goto-exit-statement} | {\em throw-statement} \\
{\em go-to-exit-statement} ::= see \pagref{GO-TO-STATEMENT} \\
{\em throw-statement} ::= see \pagref{THROW-STATEMENT}
\\[2.0ex]
where
\begin{enumerate}

\item The {\em exit-label} \ttkey{*EXCEPTION*} is special and
any {\em exception-subblock} must be the last {\em exit-subblock}
in the {\em block-assignment-statement}.

\end{enumerate}
\end{indpar}

The {\em block-assignment-statement}
first allocates and initializes memory in the current function frame
for the variables declared by the {\em block-variable-declarations}.

Then any {\em statements} and
{\em exit-subblocks} are executed.  During this execution
block variables \underline{not} set by an {\em allocation-call}
are {\tt *INIT*}\pagnote{INIT-FORCING},
and after this execution, these variables become
{\tt co}.  During this execution pointer variables set by
an {\em allocation-call} are {\tt co}, but their target type is changed
to {\tt *INIT*}, and after execution the target type
qualifiers become whatever the pointer variable declarations specify.

When a declaration has an {\em allocation-call}\label{ALLOCATION-CALLS},
its variable must have pointer
type, and the {\em allocation-call} is executed to set the pointer
before any {\em statements} in the {\em block-assignment-statement}
are executed.  The {\em allocation-call} is executed
with a pre-pended argument list consisting of two {\tt uns} values
in {\tt ()} parentheses.  The first value is the number of bytes to
be allocated, and the second value is the byte alignment of the
memory to be allocated.
The {\em prototype-pattern}
of the called function's prototype\pagnote{PROTOTYPE-PATTERN}
must begin with `{\tt ( uns length, uns alignment )}', although
the argument names may be different.
The called function must allocate a block of
memory with the required number of bytes and alignment and zero that
block.  The prototype must have
exactly one result variable whose type is identical to the
the pointer type of the {\em pointer-variable} being set (but the
prototype result type may contain wildcards).

As a general rule, allocator functions that return a value of
type {\tt av} or {\tt fv} or a user defined vector pointer
have a {\tt []} argument list
with a single argument giving a vector size {\tt N}.
The allocator allocates not a single block of the given length
and alignment, but instead a vector of {\tt N} such blocks, with zero padding
between the blocks if necessary to obtain proper alignment for each
block.  However,
this is by convention and is not a builtin requirement of the L-Language.
The convention is followed by the builtin allocators (e.g., {\tt local}).

A {\em go-to-exit-statement} within a block may exit the block or
enter an {\em exit-subblock} of the block:
\begin{indpar}
\emkey{go-to-exit-statement}\label{GO-TO-STATEMENT} ::=
    \ttkey{go to} {\em go-to-label} \TT{exit}
\\[0.5ex]
\emkey{go-to-label} ::= {\em block-label} $|$ {\em exit-label} other than
                        {\tt *EXCEPTION*}
\end{indpar}

Unless a {\em go-to-exit-statement} is executed,
a block exits after the last {\em statement} in the block,
and an {\em exit-subblock} exits its containing block after the last
{\em statement} in the {\em exit-subblock}.

A {\em go-to-exit-statement} in an {\em exit-subblock} may only enter
a \underline{subsequent} {\em exit-subblock} or exit any of its containing
{\em block-assignment-statements} by using that block's {\em block-label}.

An {\em exception-subblock} is entered if any
preceding {\em statement} in the {\em block-assignment-state\-ment}
executes a:
\begin{indpar}
\emkey{throw-statement}\label{THROW-STATEMENT} ::=
    \ttkey{throw} ~ {\em throw-ID}\QMARK{} \\
\emkey{throw-ID} ::= {\em expression} evaluating to an {\tt uns} integer
\end{indpar}
If a {\tt throw-statement} is executed in an
{\em exception-subblock}, it behaves as if the containing
{\em block-assignment-statement}
were replaced by the {\tt throw-statement}.  If a
{\em block-assignment-statement} has no {\em exception-subblock},
it behaves as if it did have an {\em exception-subblock} whose only
statement was a `{\tt throw}' statement (without {\em throw-ID}).

A {\em throw-statement} with {\em throw-ID} stores the {\em throw-ID}
and statement program counter in the {\tt std current exception data}:
see section \itemref{BUILTIN-EXCEPTION-AND-TRACE-SUPPORT-OPERATIONS}.
A {\em throw-statement} with\underline{out} a {\em throw-ID}
leaves the {\tt std current exception data} untouched.

A statement that has a fault,
such as a memory fault or an integer divide-by-zero fault,
executes as a {\em throw-statement} with one of the builtin {\em throw-IDs}
of section \itemref{BUILTIN-EXCEPTION-AND-TRACE-SUPPORT-OPERATIONS}.

{\em Go-to-exit-statements} define various possible execution
paths through a {\em block-assignment-statement}
(these are paths in an acyclic graph).
It is a compile error if a {\em statement}
within the {\em block-assignment-statement}
uses a declaration and the statement can be reached by a path that
does not contain the declaration.
Note that declarations not in {\em exit-subblocks} have scope
that includes the {\em exit-subblocks}, but declarations
within an {\em exit-subblock} have scope that ends with the end of
the {\em exit-subblock}.  A {\em function declaration}
is `used' if and only if its
prototype matches a {\em function-call}.\footnote{Stack space for every
stack variable that might be used by an out-of-line function is
allocated when the out-of-line function is called.  Space allocated
by the \TT{local} function is treated differently:  see
\pagref{OUT-OF-LINE-LOCALS}.}

There is an exception to the last paragraph for {\em exception-subblocks}.
In these any {\tt co} variable allocated in the
{\em block-assignment-statement} may be read, but the value will
be zero or {\tt null} if the variable's declaration has not been
executed.  The `{\tt is set}' function\pagnote{IS-SET} should be
used to test a variable in this case.

If\label{BLOCK-NEXT-PROMOTION} `{\tt next} {\em variable-name}' is used as an
{\em assignment-result} of some {\em statement} within a
{\em block-assignment-statement} that is not within the scope of
a {\em result-variable-declaration} for the {\em variable-name}
that is also within some {\em statement} of the
{\em block-assignment-statement},
then `{\tt next} {\em variable-name}' will be automatically added
to the {\em block-variable-declarations}
of the {\em block-assignment-state\-ment},
if it is not already there.  For example:
\begin{indpar}\begin{verbatim}
int x = 5
do:
    next x = x + 1
\end{verbatim}\end{indpar}
is equivalent to:
\begin{indpar}\begin{verbatim}
int x = 5
next x = do:
    next x = x + 1
\end{verbatim}\end{indpar}

\subsection{Deferred Assignment Statements}
\label{DEFERRED-ASSIGNMENT-STATEMENTS}

The syntax of {\em defer\-red-assignment-state\-ments} is:

\begin{indpar}
\emkey{deferred-assignment-statement} ::= \\
\hspace*{0.3in}
    \begin{tabular}[t]{@{}l}
        {\em result-variable-declaration}
                \{ \TT{,} {\em result-variable-declaration} \}\STAR{}
		     \TT{=} \ttkey{*DEFERRED*} \\
    \end{tabular}
\\[0.5ex]
{\em result-variable-declaration} ::=
    see \pagref{RESULT-VARIABLE-DECLARATION}
\end{indpar}

Each variable declared by a {\em result-variable-declaration}
of a {\em deferred-assignment-statement} must be declared identically,
except for addition or subtraction of an {\em allocation-call},
as a {\em block-variable-declaration} of a {\em block-assignment-statement}
that is within the scope\pagnote{SCOPE} of the
{\em deferred-assignment-statement}.  The {\em block-assignment-statement},
known as the \key{companion} of the {\em result-variable-declaration},
computes the value of the
declared variable, except in the case of a pointer variable whose value is
set by an {\em allocation-call} in the {\em deferred-assignment-statement}.
If a {\em deferred-assignment-statement} is in a module
(\itemref{MODULE-AND-BODY-DECLARATIONS}), companions
of its {\em result-variable-declarations}
must be in that module or its bodies.

A pointer variable may have an {\em allocation-call} in either its
{\em deferred-assignment-statement} or in its companion, but not
both.

{\em Deferred-assignment-statements} and their companions must be
top-level.

{\em Deferred-assignment-statement} variable initialization is the
same as {\em block-assignment-state\-ment} variable initialization,
except that after the statement the variables
are made {\em ro} and not {\em co} if they are not set
by an {\em allocation-call} in the {\em deferred-assignment-statement}.
Code that reads such {\tt ro} variables
before companions compute their values will
read zero.
For pointers this will typically reference undefined memory which
will cause a memory fault if accessed.
For code after a companion in the same file as the companion the
variable qualifier will be changed to {\tt co}.


For pointers allocated by a {\em deferred-assignment-statment},
the target value will be zeroed and the
the pointer target will be given the {\tt ro} qualifier, except for
code after the pointer's companion in the same file as the companion,
for which the pointer target will be given its declared qualifiers.
In particular, function bodies after the companion in the companion's
file will see these declared qualifiers.\footnote{
If the companion is in a body, that body may not be initialized
(thereby executing the companion)
until \underline{after} code that imports the body's module is initialized:
see \itemref{PROGRAM-INITIALIZATION}.}


The variables declared in a {\em deferred-assignment-statement} are treated as
normal {\em block-vari\-able-declaration} variables inside their companions.
In particular, inside their companions
the {\tt ro} variables are {\tt *INIT*}\pagnote{INIT-FORCING},
and the {\tt co} pointer variables set by
an {\em allocation-call} in their {\em deferred-assignment-statement}
have their target type changed to {\tt *INIT*}
inside their companions.

\subsection{Loop Assignment Statements}
\label{LOOP-ASSIGNMENT-STATEMENTS}

A {\em loop-assignment-statement} has the syntax:

\begin{indpar}
\emkey{loop-assignment-statement} ::= \\
\hspace*{0.5in}
    \begin{tabular}[t]{@{}rll}
        & {\em block-variable-declaration}
                \{ \TT{,} {\em block-variable-declaration} \}\STAR{}
		\TT{=} \\
	& ~~~~~~~~~~~~~~~ {\em iteration-control-list} \TT{:} \\
        & ~~~~~ {\em statement}\STAR{} \\
        & ~~~~~ {\em exit-subblock}\STAR{} \\
    $|$ & {\em iteration-control-list} \TT{:} \\
        & ~~~~~ {\em statement}\STAR{} \\
        & ~~~~~ {\em exit-subblock}\STAR{} \\
    \end{tabular}
\\[0.5ex]
\emkey{iteration-control-list} ::=
    {\em iteration-control} \{ \TT{,} {\em iteration-control} \}\STAR{}
\\[0.5ex]
\emkey{iteration-control}\label{ITERATION-CONTROL}
    \begin{tabular}[t]{rl}
     ::= & \ttkey{loop} {\em loop-label}\QMARK{} \\
     $|$ & \ttkey{exactly} {\em int-expression} \ttkey{times} \\
     $|$ & \ttkey{at most} {\em int-expression} \ttkey{times} \\
     $|$ & \ttkey{while} {\em bool-expression} \\
     $|$ & \ttkey{until} {\em bool-expression} \\
     \end{tabular}
\\[0.5ex]
\emkey{loop-label} ::= {\em statement-label}
\\[0.5ex]
{\em statement-label} ::= see \pagref{STATEMENT-LABEL} \\
\\[0.5ex]
\emkey{int-expression} ::= {\em expression} evaluating to an {\tt int}
\\[0.5ex]
\emkey{bool-expression}\label{BOOL-EXPRESSION} ::=
    {\em expression} evaluating to a {\tt bool}
\\[0.5ex]
\emkey{loop-control-statement}\label{LOOP-CONTROL-STATEMENT} ::=
    {\em break-statement} $|$ {\em continue-statement}
\\[0.5ex]
\emkey{break-statement}\label{BREAK-STATEMENT} ::=
    \ttkey{break} {\em loop-label}\QMARK{}
\\[0.5ex]
\emkey{continue-statement}\label{CONTINUE-STATEMENT} ::=
    \ttkey{continue} {\em loop-label}\QMARK{}
\end{indpar}

A {\em loop-assignment-statement} that has no {\em result-variable-declarations}
(as opposed to {\em next-variable-declarations})
is the semantic equivalent of
a sequence of zero or more copies of the statement with
its {\em iteration-controls} deleted, making these copies into
{\em block-assignment-statements}.  Each copy is called an
\key{iteration} of the {\em loop-assignment-statement}.
The number of iterations is
determined at run-time by the {\em iteration-controls}
and {\em loop-control-statements}.

A simple example is:
\begin{indpar}\begin{verbatim}
int sum = 0
int i = 1
next sum, next i = while i < 4:
    next sum = sum + i
    next i = i + 1
\end{verbatim}\end{indpar}
which is semantically equivalent to:
\begin{indpar}\begin{verbatim}
int sum = 0
int i = 1
next sum, next i =:
    next sum = sum + i
    next i = i + 1
next sum, next i =:
    next sum = sum + i
    next i = i + 1
next sum, next i =:
    next sum = sum + i
    next i = i + 1
// Now sum == 6 and i == 4
\end{verbatim}\end{indpar}

However at run-time the variable values of all but the
last 4 iterations of the {\em loop-assignment-statement}
are discarded, which would not be the case if the compiler
actually inserted iterations in the source code. 
This only affects debugging.

If instead there are {\em result-variable-declarations}, these are
treated as if they had been moved to an immediately outer
{\em block-assignment-statement}.  For example:
\begin{indpar}\begin{verbatim}
int sum = 0
int i = 1
int result, next sum, next i = loop:
    next sum = sum + i
    next i = i + 1
    if i + 1 >= 4:
        result = sum
        break // terminate loop
\end{verbatim}\end{indpar}
is semantically equivalent to:
\begin{indpar}\begin{verbatim}
int sum = 0
int i = 1
int result:
    next sum, next i = loop:
        next sum = sum + i
        next i = i + 1
        if i + 1 >= 4:
            result = sum
            break // terminate loop
\end{verbatim}\end{indpar}

Another way of putting this is that the variables of
{\em next-variable-declarations} get allocated anew each
iteration, but the variables of {\em result-variable-declarations}
are only allocated once before the first iteration.  As they
have the {\tt *INIT*} qualifier throughout the
{\em loop-assignment-statement}, they can only be written
inside that {\em statement}.

The {\em iteration-controls} are independent of each other:
{\tt loop x} just provides a {\em loop-label},
{\tt exactly x times} and {\tt at most x times} both terminate
the loop after {\tt x} iterations (both do the same thing),
{\tt while x} terminates
the loop if {\tt x} is {\tt false} at the start of an iteration,
and {\tt until x} terminates
the loop if {\tt x} is {\tt true} at the start of an iteration.
There can be at most one {\tt loop x}, but there can be multiple
variants of the other {\em iteration-controls}.

The {\em break-statement} exits the current iteration of the
{\em loop-assignment-statement} and prevents further iterations.
A {\em continue-statement} exits the current iteration of the
{\em loop-assignment-statement} but lets the
{\em iteration-control} determine whether there will be any
more iterations.  If there are nested loops, a {\em loop-label}
may be used with these statements to designate which nested iteration
is being exited.

\label{LOOP-NEXT-PROMOTION}
As in {\em block-assignment-statements}, if `{\tt next V}' occurs
as an {\em assignment-result} within the loop {\em statements}
but is not within the scope of a {\em result-variable-declaration}
for {\tt V} that is also within the loop {\em statements},
`{\tt next V}' will be added to the {\em next-variable-declaration}
list of the {\em loop-assignment-statement}.  Therefore the
above example could be written as:
\begin{indpar}\begin{verbatim}
int sum = 0
int i = 1
next sum = while i < 4:
    next sum = sum + i
    next i = i + 1
\end{verbatim}\end{indpar}
or
\begin{indpar}\begin{verbatim}
int sum = 0
int i = 1
while i < 4:
    next sum = sum + i
    next i = i + 1
\end{verbatim}\end{indpar}

\section{Conditional Statements}
\label{CONDITIONAL-STATEMENTS}

A {\em conditional-statement} executes another {\em statement}
or block of {\em statements} according to what a
{\em bool-expression} evaluates to.
{\em Conditional-statements} have the syntax:

\begin{indpar}
\emkey{conditional-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{rl}
        & \ttkey{if} {\em bool-expression} \TT{:} \\
	& ~~~~~ {\em statement}\STAR{} \\
    $|$ & \ttkey{else if} {\em bool-expression} \TT{:} \\
	& ~~~~~ {\em statement}\STAR{} \\
    $|$ & \ttkey{else} \TT{:} \\
	& ~~~~~ {\em statement}\STAR{} \\
    $|$ & \ttkey{if} {\em bool-expression} \TT{:} {\em restricted-statement} \\
    $|$ & \ttkey{else if} {\em bool-expression} \TT{:}
    		{\em restricted-statement} \\
    $|$ & \ttkey{else} \TT{:} {\em restricted-statement} \\
	\end{tabular}
\\[0.5ex]
{\em bool-expression} ::= see \pagref{BOOL-EXPRESSION}
\\[0.5ex]
{\em restricted-statement}\label{RESTRICTED-STATEMENT} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{@{}l}
   {\em expression} with no operator of precedence equal to or less than 0 \\
   (the precedence of the `\TT{:}' operator) \\
   \end{tabular}
\\[1ex]
where
\begin{enumerate}
\item An `{\tt else if}' or `{\tt else}' {\em statement} must be immediately
preceded by an `{\tt if}' or `{\tt else if}' {\em statement}.
\end{enumerate}
\end{indpar}

An example is:
\begin{indpar}\begin{verbatim}
int x = 5
int y = 6
int z:
    int sum = x + y         // Sets sum = 11
    int product = x * y     // Sets product = 30
    if sum < product:
        z = sum             // Sets z = 11
    else: z = product       // Is NOT executed
// Now z = 11
\end{verbatim}\end{indpar}

\section{Trace Statements}
\label{TRACE-STATEMENTS}

A {\em trace-statement} optionally writes an information record into
a trace file:
\begin{indpar}
\emkey{trace-statement}\label{TRACE-STATEMENT} ::=
    \ttkey{trace} ~ {\em trace-ID} \TT{,} ~ {\em trace-description}
        ~ \{ \TT{,} {\em trace-value} \}\STAR \\
\emkey{trace-ID} ::=
    {\em expression} with an {\tt uns} integer value in the range [0,63] \\
\emkey{trace-description} ::=
    {\em expression} with a {\tt const} string value \\
\emkey{trace-value} ::=
    {\em reference-expression} with a value of any run time type
\end{indpar}

A {\em trace-statement} with {\em trace-ID} X is executed if bit
{\tt 1 <{}< X} of the {\tt std current trace mask}\pagnote{CURRENT-TRACE-MASK}
is on.  Otherwise the {\em trace-statement} is a no-operation.

When a {\em trace-statement} is executed it outputs a trace record into
a trace file (not specified by this document) that contains the program
counter (as a {\tt dp uns8 @pc} value) followed by the {\em trace-values}.
The program counter, when used with debugging information
files output by the compiler and loader (not specified by this document),
identifies the particular {\em trace-statement}, its
{\em trace-description}, and the data types of the {\em trace-values}.
This information allows the trace record to
be printed in a human readable form (in a manner not specified by this
document).


\section{Declarations}
\label{DECLARATIONS}

The following is a complete list of declarations:
\begin{indpar}
\emkey{declaration}\label{DECLARATION}
    \begin{tabular}[t]{@{}rll}
    ::= & {\em result-variable-declaration}
        & [\pagref{RESULT-VARIABLE-DECLARATION}] \\
    $|$ & {\em next-variable-declaration}
        & [\pagref{NEXT-VARIABLE-DECLARATION}] \\
    $|$ & {\em block-variable-declaration}
        & [\pagref{BLOCK-VARIABLE-DECLARATION}] \\
    $|$ & {\em prototype-result-declaration}
        & [\pagref{PROTOTYPE-RESULT-DECLARATION}] \\
    $|$ & {\em prototype-argument-declaration}
        & [\pagref{PROTOTYPE-ARGUMENT-DECLARATION}] \\
    $|$ & {\em declaration-statement} \\
    \end{tabular}
\\[0.5ex]
\emkey{declaration-statement}\label{DECLARATION-STATEMENT}
    \begin{tabular}[t]{@{}rll}
    ::= & {\em type-declaration}
        & [\pagref{TYPE-DECLARATIONS}] \\
    $|$ & {\em field-declaration}
        & [\pagref{FIELD-DECLARATION}] \\
    $|$ & {\em subfield-declaration}
        & [\pagref{SUBFIELD-DECLARATION}] \\
    $|$ & {\em pointer-type-declaration}
        & [\pagref{POINTER-TYPE-DECLARATIONS}] \\
    $|$ & {\em function-declaration}
        & [\pagref{FUNCTION-DECLARATION}] \\
    $|$ & {\em reference-function-declaration}
        & [\pagref{REFERENCE-FUNCTION-DECLARATIONS}] \\
    $|$ & {\em out-of-line-function-declaration}
        & [\pagref{OUT-OF-LINE-FUNCTION-DECLARATIONS}] \\
    $|$ & {\em function-type-declaration}
        & [\pagref{FUNCTION-TYPE-DECLARATION}] \\
    $|$ & {\em function-constant-declaration}
        & [\pagref{FUNCTION-CONSTANT-DECLARATION}] \\
    $|$ & {\em module-declaration}
        & [\pagref{MODULE-DECLARATION}] \\
    $|$ & {\em body-declaration}
        & [\pagref{BODY-DECLARATION}] \\
    \end{tabular}
\end{indpar}


\subsection{Type Declarations}
\label{TYPE-DECLARATIONS}

The syntax of a type declaration is:

\begin{indpar}
\emkey{type-declaration}\label{TYPE-DECLARATION}
    \begin{tabular}[t]{rl}
    ::= & \ttkey{type} {\em defined-type-name} \TT{:} \\
	& \TT{~~~~~}{\em type-subdeclaration}\STAR{} \\
    $|$ & \ttkey{type} {\em defined-type-name} \TT{:} \ttkey{*DEFERRED*} \\
    \end{tabular} \\
\emkey{defined-type-name} ::= {\em type-name} \\
{\em type-name} ::= see \pagref{TYPE-NAME}
\\[2ex]
\emkey{type-subdeclaration} ::= \\
\hspace*{0.5in}%
    \begin{tabular}[t]{@{}rl}
    ::= &  {\em field-declaration} \\
    $|$ &  \ttkey{align} {\em alignment}\QMARK{} \\
    $|$ &  \ttkey{pack} \\
    $|$ &  \ttkey{*INCLUDE*} {\em defined-type-name} \\
    $|$ &  \ttkey{*LABEL*} {\em origin-label} \\
    $|$ &  \ttkey{*OFFSET*} {\em origin-label} \{ \{\TT{+}|\TT{-}\}
                            {\em integer-constant-expression} \}\QMARK{} \\
    $|$ &  \ttkey{*OFFSET*} \{\TT{+}|\TT{-}\}\QMARK{}
                            {\em integer-constant-expression} \\
    $|$ &  \ttkey{*OFFSET* *SIZE*} \\
    $|$ &  \ttkey{***} \\
    $|$ &  \ttkey{*EXTERNAL*} \\
    $|$ &  \ttkey{*OFFSET*} \ttkey{*SIZE*} \\
    \end{tabular}
\\[2ex]
\emkey{field-declaration}\label{FIELD-DECLARATION}
    \begin{tabular}[t]{@{}rl}
    ::= &  {\em field-without-subfields-declaration} \\
    $|$ &  {\em field-with-subfields-declaration} \\
    \end{tabular}
\\[2ex]
\emkey{field-without-subfields-declaration} ::= \\
\hspace*{0.5in}\begin{tabular}{rl}
        & {\em qualifier-name}\STAR{} {\em field-type-name}~
          {\em target-label}~ {\em field-dimension}\STAR{} \\
    $|$ & {\em qualifier-name}\STAR{} {\em pointer-type-name} \\
        & ~~~~~ \{ {\em qualifier-name}\STAR{} {\em pointer-type-name}
	        \}\STAR{} \\
        & ~~~~~ {\em qualifier-name}\STAR{} {\em field-type-name}~
                {\em pointer-label}~ {\em field-dimension}\STAR{}
	\end{tabular}
\\[2ex]
\emkey{field-with-subfields-declaration} ::= \\
\hspace*{0.5in}
    {\em qualifier-name}\STAR{}
    \TT{std}\QMARK{} {\em number-type-name}~ {\em target-label}\QMARK{}
                {\em field-dimension}\STAR{} \\
\hspace*{0.5in}
    {\em subfield-declaration}\PLUS{}
\\[2ex]
\emkey{field-type-name} ::= {\em type-name} that is not {\tt const} \\
{\em type-name} ::= see \pagref{TYPE-NAME} \\
\emkey{number-type-name}
    \begin{tabular}[t]{@{}rl}
    ::= &  \ttkey{int} $|$ \ttkey{int8} $|$ \ttkey{int16} $|$ \ttkey{int32}
                       $|$ \ttkey{int64} $|$ \ttkey{int128} \\
    $|$ &  \ttkey{uns} $|$ \ttkey{uns8} $|$ \ttkey{uns16} $|$ \ttkey{uns32}
                       $|$ \ttkey{uns64} $|$ \ttkey{uns128} \\
    $|$ &  \ttkey{flt} $|$ \ttkey{flt16} $|$ \ttkey{flt32} $|$ \ttkey{flt64}
                         $|$ \ttkey{flt128} \\
    \end{tabular} \\
{\em pointer-type-name} ::= see \pagref{POINTER-TYPE-NAME}
\\[2ex]
\emkey{field-label}\label{FIELD-LABEL} ::=  {\em data-label} \\
\emkey{pointer-label}\label{POINTER-LABEL} ::=
    {\em field-label} beginning with zero or more `\TT{.}'s followed by
    one or more `\TT{@}' \\
\emkey{target-label}\label{TARGET-LABEL} ::=
    {\em field-label} that is \underline{not} a {\em pointer-label} \\
\emkey{origin-label}\label{ORIGIN-LABEL} ::=
    {\em basic-name} not beginning with \TT{@} \\
\emkey{data-label} ::=  see \pagref{DATA-LABEL} \\
\emkey{basic-name} ::=  see \pagref{BASIC-NAME}
\\[2ex]
\emkey{field-dimension} ::=  \TT{[} {\em dimension-size} \TT{]} \\
\emkey{dimension-size} ::=  {\em constant-expression}
			    with non-negative integer value \\
{\em constant-expression} ::= a {\tt const} valued expression as
    defined on \pagref{CONSTANT-EXPRESSION}
\\[2ex]
\emkey{subfield-declaration}\label{SUBFIELD-DECLARATION} ::= \\
\hspace*{0.5in}
    {\em bit-range} {\em subfield-type-name} {\em subfield-label}
    		{\em subfield-dimension}\STAR{} \\
\emkey{subfield-type-name}\label{SUBFIELD-TYPE-NAME} ::=
    {\em number-type-name} $|$ \TT{bool} \\
\emkey{subfield-label}\label{SUBFIELD-LABEL} ::=  {\em target-label} \\
\emkey{subfield-dimension} ::=  \TT{[} {\em dimension-size} \TT{]} \\
\\[2ex]
\emkey{bit-range}
    \begin{tabular}[t]{@{}rl}
    ::= &  \TT{[} {\em onlybit} \TT{]} \\
    $|$ &  \TT{[} {\em highlowbits} \TT{]} \\
    $|$ &  \TT{[} {\em highbit} \TT{-} {\em lowbit} \TT{]}
    \end{tabular} \\
\emkey{onlybit} ::= {\tt constant-expression}
		    with non-negative integer value \\
\emkey{highlowbits} :::= {\em dit}+ \TT{-} {\em dit}+
           ~~~~~ [this is a single lexeme] \\
\emkey{highbit} ::= {\tt constant-expression}
		    with non-negative integer value \\
\emkey{lowbit} ::= {\tt constant-expression}
		   with non-negative integer value \\
{\em dit} ::= see \pagref{DIT}
\\[2ex]
\emkey{alignment} ::= {\tt constant-expression}
		      with power of 2 integer value
\\[2ex]
where
\begin{enumerate}
\item If a {\em field-without-subfields-declaration}
has $N>0$ {\em pointer-type-names}, the {\em pointer-label}
it declares must begin with exactly $N$ `\TT{@}'s.
\end{enumerate}
\end{indpar}

The {\em type-subdeclarations} are processed in order.  At the
beginning of each, there is a align/pack switch value and an
offset-in-bits integer.  These determine the offset in bits
of the next {\em field-declaration} field encountered
relative to the beginning of each datum of the defined
type being declared.  There may be several {\em type-declarations}
for the same defined type (see \itemref{DEFINED-TYPE-EXPANSIONS}),
and at the beginning
of the first the align/pack switch is set to align and the offset
is set to zero.

If the align/pack switch is in the \key{align} position and the
next {\em type-subdeclaration} is a {\em field-declaration}, the
current offset will be incremented before becoming the offset
of the field being declared.  The increment will be just enough
to make the offset an exact multiple of the field's type's alignment.
The alignment of a number type is its size in bits.  The alignment
of a defined type is the least common multiple of the alignment of
any of its fields, which, since all alignments are powers of two,
is the same as the largest alignment of any of the fields.

A value of {\tt bool} type has a size of 1 bit and an alignment
of 8 bits.  When it is stored in 8 bits, the value is encoded
like a signed integer equal to -1 for {\tt true} and 0 for {\tt false}.

An `\ttkey{align} $N$' sub-declaration behaves like an unnamed
field of alignment $N$ bits and zero length,
and in addition sets the align/pack switch to `align'.
An `\ttkey{align}' sub-declaration just sets the
align/pack switch to `align'.

A \ttkey{pack} sub-declaration sets the align/pack switch to `pack'.

An \ttkey{*INCLUDE*} sub-declaration copies all the {\em type-subdeclarations}
of the given defined type into the current sequence of
{\em type-subdeclarations}.
If the defined type is
defined by multiple {\em type-declarations}, only sub-declarations
from the {\em type-declarations} in the current scope (see \itemref{SCOPE})
are copied.

A \ttkey{*DEFERRED*} {\em type-declaration} declares a {\em defined-type-name}
without declaring the definition of the named type.
Such a {\em type-declaration} is typically used allow the
{\em defined-type-name}
to be used as the target type of a pointer before its fields are declared.

The {\em defined-type-name} in a {\em type-declaration} is declared before
the {\em type-declaration}'s sub-declarations are processed, so these
sub-declarations may use the {\em defined-type-name} as a pointer target type.

A \ttkey{*LABEL*} sub-declaration assigns the current offset to the
given {\em origin-label} and provides the {\em origin-label}
for use by subsequent {\tt *OFFSET*} sub-declarations.
Each {\em origin-label} may be defined only once for a given
defined type.

An \ttkey{*OFFSET*} sub-declaration changes the current offset to the value
of a given {\em origin-label}, or to that value plus or minus
an integer, or to a given integer.
`\ttkey{*OFFSET* *SIZE*} is special: see \pagref{OFFSET-SIZE}.

\subsubsection{Defined Type Expansions }
\label{DEFINED-TYPE-EXPANSIONS}

A defined type can have just one or several {\em type-declara\-tions}.
The set of all its {\em type-declarations} is called the
\key{expansion tree} of the defined type.

The set of fields and subfields of the
defined type is
the union of those defined by any {\em type-declaration} in the defined
type's expansion tree.  However these may not have unique names, as long
as each name is unique in the scope of the {\em type-declaration}
that defines the name (because two {\em type-declarations} in the expansion
tree can have disjoint scopes).

All but one of the {\em type-declarations} in an expansion tree must be within
the scope\pagnote{SCOPE} of another {\em type-declaration}
in the expansion tree, and
the expansion tree is a tree-graph in which each {\em type-declaration} X is
the root of a subtree containing all {\em type-declarations} Y
in the tree
that are within the scope of X
(or equivalently, that have a scope
that is a subset of the scope of X).  Thus the \key{parent} of
a non-root Y is the {\em type-declaration} X in the expansion tree
with the smallest scope that contains Y.

Non-root {\em type-declarations} in the expansion tree are called
{\em expansions}, and the root {\em type-declaration} is called just
the \key{root}\label{ROOT}.

A {\em defined-type-name} must be inside the scope of the root of its expansion
tree to be visible, and hence usable.

A \key{leaf} in an expansion tree is a {\em type-declaration} that
is not the parent of any other {\em type-declaration} in the expansion
tree (equivalently, a leaf is a tree node with no children).  An expansion
tree is \key{linear} if it has only one leaf (equivalently, no tree node
has more than one child).
The sole leaf of a linear expansion tree is called a \key{linear leaf}.

Expansion trees are either internal or external.

Each {\em type-declaration} in an \key{internal expansion tree}
that is not a linear leaf must end with
the {\tt ***}\label{***} sub-declaration, and all {\em type-declarations}
in the tree must be in the same module or its bodies.  However the
{\em defined-type-name} may be external.
If the tree has a linear leaf that does \underline{not}
have a {\tt ***} sub-declaration, the {\em defined-type-name}
is \key{non-expandable}
within the scope of the linear leaf {\em type-declaration}.
Outside that scope, but within the scope of the tree root,
the {\em defined-type-name} is said to be expandable.

Each {\em type-declaration} in an \key{external expansion tree}
must end with the {\tt *EXTERNAL*}\label{*EXTERNAL*} sub-declaration.
The {\em defined-type-name} is expandable whereever it is defined
(i.e., within the scope of the tree root).

The final size and alignment of an expandable {\em defined-type-name}
are not known until load time.
Allocators use the load time
size and alignment to allocate memory for a value of
the type and then zero that memory.  Thus the `{\tt local}' allocator 
can allocate a datum of an expandable {\em defined-type-name}
and return a pointer to the datum.

A {\em defined-type-name} \underline{must be non-expandable} if it is used as
a {\em type-name} in a variable declaration, or as a {\em field-type-name}
in a {\em type-subdeclaration}, or as a {\em defined-type-name} in an
{\tt *INCLUDE*} {\em type-subdeclaration}.  However an expandable
{\em defined-type-name}
can be used as the target of a pointer type used as a variable type or
field type.

A {\em field-label} or {\em subfield-label}
declared within a {\em type-declaration} may
only be used within the scope of the {\em type-declaration}
in which the {\em field-label} or {\em subfield-label} is declared,
and may \underline{not} be re-declared within this scope.

Similarly an {\em origin-label} may only be used only after its definition
in its defining {\em type-declaration} X
and within other {\em type-declarations}
in the same expansion tree that are within the scope of X, and
may \underline{not} be re-declarated in the places it can be used.

Because it is possible for different {\em type-declarations} in
an expansion tree to have disjoint scopes, a given label may refer
to different things in these disjoint scopes: e.g., it might be a
{\em field-label} in one scope and an {\em origin-label} in the
other, or it might name completely different fields in the two scopes.

At the beginning of each {\em type-declaration} the align/pack switch
is set to align, the offset is set to zero if the {\em type-declaration}
is the root of its expansion tree, and the offset is undefined and
must be set by an {\tt *OFFSET*} statement before
it is used if the {\em type-declaration} is a non-root.

{\tt *LABEL*} and {\tt *OFFSET*} sub-declarations are typically used
to overlay sections of a defined type's value, and create what in other
languages are union types.  Care must be taken in using union values
as both type-violations and unexpected field allocations can result.

An `\ttkey{*OFFSET*} \ttkey{*SIZE*}'\label{OFFSET-SIZE} sub-declaration
changes the current offset to the size of values of the type
being defined, as it is computed at the point where the {\tt *OFFSET* *SIZE*}
sub-declaration is encountered.  This is just the maximum of all
offset values previously computed in the current {\em type-declaration}
and its ancestors in the expansion tree.
The `\ttkey{*OFFSET*} \ttkey{*SIZE*}' sub-declaration
is \underline{not} allowed in a {\em type-declaration}
if any of the ancestors of the {\em type-declaration} in its expansion
tree has more than one child.

\subsubsection{Type Fields}

A field of a value of a user defined type is accessed by prepending
`\TT{.}' to the {\em field-label} to form a {\em member-name} in
a {\em reference-expression} (see \pagref{FIELD-SELECTION}).
An example is:

\begin{indpar}\begin{verbatim}
type my type:
    uns8    kind         // Object Kind
    flt     weight

my type X:
    // Within this block X is *INIT*.
    X.kind = HIPPOPOTAMUS
    X.weight = 152.34
uns8 kind = X.kind
flt weight = X.weight
\end{verbatim}\end{indpar}

If a {\em field-label} is a {\em pointer-label}, an
associated {\em target-label} is declared consisting of the
{\em pointer-label} minus its first `{\tt @}'.  The {\em target-label}
references a virtual field consisting of the target value stored
at the location pointed at by the {\em pointer-label} field's pointer value.
An example\footnote{As `{\tt next}' is a keyword, we use `{\tt successor}'
here.} is:

\begin{indpar}\begin{verbatim}
type list element:
    int value
    ap list element @successor

// Make circular list.
//
ap list element @Y      // `@= local = *DEFERRED*' is implied
ap list element @X:     // `@= local' is implied
    X.value = 1
    X.@successor = @Y
ap list element @Y:
    Y.value = 2
    Y.@successor = @X
//
// Now X.value == 1 and X.successor.value == 2 and
// similarly Y.value == 2 and Y.successor.value == 1,
// while X.@successor == @Y and Y.@successor == @X are
// pointers to local memory.
\end{verbatim}\end{indpar}

A field of
the defined type can only be accessed by code in the scope
of a {\em type-declaration} declaring the field.

An example is:

\begin{indpar}\begin{verbatim}
type my type: *DEFERRED*
ap *READ-WRITE* my type @X    // `@= local' is implied
                    // Legal, my type members need not be declared.
                    // Size and alignment of my type values is
                    // computed at load time.  The allocated value
                    // will be zeroed.
ap ro my type @Y = @X  // Legal, only ap copied.
ap my type @Z:      // Legal, `@= local' is implied
    Z = X           // Legal, the value at @X is copied to
                    // the value at @Z.  However in this
                    // case the value is completely zero.

type my type:       // Definition of my type that was *DEFERRED*.
    *LABEL* origin  // `origin' is set to offset 0
    int I           // Offset of I is 0.
    ***
X.I = 55            // Legal, .I has been declared.  X is
                    // *READ-WRITE*.

type my type:       // Expansion of my type
    *OFFSET* *SIZE*
    int J           // Now X.J == 0
    ***
X.J = 66            // Legal, .J has been declared.

type my type:       // Expansion of my type
    *OFFSET* origin
    int K1
    int K2

// Now X.K1 == X.I == 55; X.K2 == X.J == 66; but you must know
// how offsets are assigned to believe this.
\end{verbatim}\end{indpar}

\subsubsection{Type Subfields}

Subfields are parts of the previously declared number type field.
The bits occupied
by a subfield are given by its {\em bit-range}, where bits are numbered
0, 1, \ldots{} from the low order end of numbers.

A subfield value may have fewer bits than the number-type of the subfield.
For integer types, the value is the low order bits of the integer, with
the high order bits added when the value is read by adding 0 bits
for unsigned integers or copies of the highest order bit for signed integers.
For floating types, the value is missing low order mantissa bits, which
are added as zeros.  If a value outside the representable range is stored,
it is not an error.  Unsigned and two's complement
integer values are truncated, and IEEE floating values
have low order mantissa bits dropped (there is no rounding).  However, it is
a compile error to have a floating type whose sign and exponent parts plus
1 mantissa bit cannot be stored in the subfield value.

{\em Subfield-labels} and {\em field-labels} have the same standing within
{\em reference-expressions}.
Both have associated {\em member-names} made by adding a single
`\TT{.}' to the beginning of the {\em field-label} or {\em subfield-label}.
For example:

\begin{indpar}\begin{verbatim}
type my type:
    uns8     kind        // Object Kind
    [0] bool animal      // True if Animal
    [1] bool vegetable   // True if Vegetable
    flt      weight

my type X:
    // Within this block X is *INIT*.
    X.kind = HIPPOPOTAMUS
        // Also sets animal bit and clears vegetable bit.
    X.weight = 152.34
uns8 kind = X.kind
bool animal = X.animal
bool vegetable = X.vegetable
flt weight = X.weight
\end{verbatim}\end{indpar}

\subsubsection{Type Dimensions}

If a {\em field-declaration} with {\em field-label}\, {\tt F} contains 
a single {\em field-dimension} {\tt [$n$]} then $n$ fields are
allocated to ascending offsets, using zero padding
if necessary to align all $n$ fields.  The labels of these
fields are {\tt F[$i$]} for $0\le i<n$.  If there is a subfield
labeled {\tt S} of the field, {\tt S[$i$]} refers to the
subfield in {\tt F[$i$]}.  For example:

\begin{indpar}\begin{verbatim}
type character attributes:
    uns8 [128]
    [0] bool is graphic

character attributes X:
    int i = 0
    while i < 128:
        X.is graphic[i] = 32 < i && i < 127
        next i = i + 1
bool line feed is graphic = X.is graphic [C#"<LF>"]
bool A is graphic = X.is graphic [C#"A"]
\end{verbatim}\end{indpar}

In a {\em field-declaration}
\underline{two} {\em field-dimensions} {\tt [$n1$][$n2$]} is
treated as syntactic sugar for {\tt [$n1$*$n2$]} with
{\tt F[$i1$][$i2$]} being syntactic sugar for
{\tt F[$i1$*$n2$+$i2$]}.\footnote{Thus arrays are stored in
row major order: last subscript varies fastest, as in C/C++}
Similarly
{\tt [$n1$][$n2$][$n3$]} is
syntactic sugar for {\tt [$n1$*$n2$*$n3$]} with
{\tt F[$i1$][$i2$][$i3$]} being syntactic sugar for
{\tt F[$i1$*$n2$*$n3$*+$i2$*$n2$+$i3$]}.  And so forth for any
number of {\em field-dimensions}.

If a {\em subfield-declaration} with {\em subfield-label}\, {\tt S} contains 
{\em subfield-dimension} {\tt [$n$]} then $n$ subfields are
allocated to the containing field, starting with the bits
designated by the {\em subfield-declaration}'s {\em bit-range}
and adding the number of bits in the {\em bit-range} to each integer
in the {\em bit-range} for each successive subfield.
For example:

\begin{indpar}\begin{verbatim}
type hex digits:
    uns32 container
    [3-0] uns hex digit [8]
        // hex digit[i] is stored in bits [4*i+3, 4*i]

hex digits X:
    int i = 0
    while i < 8:
        X.hex digit[i] = i
        next i = i + 1
// Now X.container == X#"76543210"
\end{verbatim}\end{indpar}

A {\em subfield-declaration} with {\em subfield-label} S
and more than one {\em subfield-dimension} is
treated in the same manner as a {\em field-declaration} with
more than one {\em field-dimension}.  For example,
{\tt [$n1$][$n2$][$n3$]} is
syntactic sugar for {\tt [$n1$*$n2$*$n3$]} with
{\tt S[$i1$][$i2$][$i3$]} being syntactic sugar for
{\tt S[$i1$*$n2$*$n3$*+\EOL $i2$*$n2$+\EOL $i3$]}.

If a {\em field-declaration} with {\em field-label} {\tt F}
has a {\em field-dimension}
and also a subfield with {\em subfield-label} {\tt S}, then
{\tt S[$i$]} references the subfield in the field value {\tt F[$i$]}.
If in addition the subfield has a {\em subfield-dimension},
{\tt S[$i$][$j$]} references the subfield selected by {\tt [$j$]}
in the field value {\tt F[$i$]}.

In all cases `\TT{][}' may be replaced by `\TT{,~}' (the space
after the comma is required), so that,
for example, `{\tt [$i$][$j$]}' is equivalent to `{\tt [$i$, $j$]}'.

\subsubsection{Type Conversions}
\label{TYPE-CONVERSIONS}

When the compiler is confronted with code such as:
\begin{indpar}\begin{verbatim}
T1 v1 = ...
T2 v2 = v1
\end{verbatim}\end{indpar}
where {\tt T1} and {\tt T2} are different types,
the compiler just rewrites the code to:
\begin{indpar}\begin{verbatim}
T1 v1 = ...
T2 v2 = *IMPLICIT* *CONVERSION* ( v1 )
\end{verbatim}\end{indpar}
and compiles the rewritten code.  If you define a function
with the prototype
\begin{indpar} \tt
function T2 r = {\em ma}\QMARK{} *IMPLICIT* *CONVERSION* ( T1 v )
\end{indpar}
the compiler will used this function.  Otherwise the compiler
will try to chain implicit conversions together to get to a
successful compile.  Of course such chaining will only work
if there is at least one {\tt *IMPLICIT* *CONVERSION*} function with
target type {\tt T2}.  If there is more than one such function,
and none have argument type {\tt T1}, ambiguity may lead to a compile error.

You can define {\tt *IMPLICIT* *CONVERSION*} functions
provided at least one of the two types {\tt T1} and {\tt T2}
is user defined, and \underline{not} builtin, and {\tt T2} is not {\tt const}.
There are builtin {\tt *IMPLICIT* *CON\-VER\-SION*} functions in
which both types are builtin: see \itemref{BUILTIN-IMPLICIT-CONVERSIONS}.

The set of {\tt *IMPLICIT* *CONVERSION*} functions defines
a graph, the \key{implicit conversion graph}\label{IMPLICIT-CONVERSION-GRAPH}
in which types are nodes and {\tt *IMPLICIT* *CONVERSION*}
functions are directed edges.
A {\em function-declaration} $d$ of the form
\begin{indpar} \tt
function T2 r = {\em ma}\QMARK{} *IMPLICIT* *CONVERSION* ( T1 v )
\end{indpar}
creats an edge labeled $d$ in this graph from node {\tt T2} to node
{\tt T1}.
This graph \underline{must} be
acyclic.  A path $d_1,d_2,\ldots,d_n$ in this graph denotes a chain
of {\t *IMPLICIT* *CONVERSION*} {\em function-declarations} that together
convert the result type of $d_1$ to the argument type of $d_n$.

When defining an implicit conversion from type {\tt T1} to type
{\tt T2}, each value of type {\tt T1} should be exactly representable
by a value of type {\tt T2}.  This rule should be followed, but
is not checked by the compiler.  This rule is also violated by the
builtin implicit conversions for any integer type to any floating
point type.\pagnote{NUMERIC-IMPLICIT-CONVERSIONS}

And there is one notable exception: conversions from {\tt const}
which are done at compile-time may fail (the failure will be at
compile-time and be a compiler error).  For example, conversions
from {\tt const} to any integer type will fail if the {\tt const}
value cannot be encoded exactly in the integer type.

For types {\tt T1} and {\tt T2} you
can also define an explicit conversion:
\begin{indpar} \tt
function T2 r = {\em ma}\QMARK{} T2 ( T1 v )
\end{indpar}
If the result may not properly represent the value {\tt v}, you
may wish to define instead an unchecked conversion:
\begin{indpar} \tt
function T2 r = {\em ma}\QMARK{} *UNCHECKED* ( T1 v )
\end{indpar}
The compiler will not allow you to define such functions if both
{\tt T1} and {\tt T2} are builtin or if {\tt T2} is {\tt const},
but some such functions are
builtin: see \itemref{BUILTIN-EXPLICIT-CONVERSIONS}.

The types {\tt T1} and {\tt T2} may also be pointer types:
see \pagref{POINTER-IMPLICIT-CONVERSION}.  Or one may be a pointer-type
and one a non-pointer type.  However, {\tt T2} cannot
be {\tt const}, and you cannot define your own {\tt *IMPLICIT* *CONVERSION*}
function if both types are builtin.


\subsection{Pointer Type Declarations}
\label{POINTER-TYPE-DECLARATIONS}

A pointer type has an
\key{associated data type}\label{POINTER-ASSOCIATE}
specified by a pointer type declaration.  The syntax is:

\begin{indpar}
\emkey{pointer-type-declaration}\label{POINTER-TYPE-DECLARATION} ::= \\
\hspace*{0.5in}\ttkey{pointer type} {\em defined-pointer-type-name}
	       \TT{is type} {\em type-name}
\\[0.5ex]
{\em pointer-type-name} ::= see \pagref{POINTER-TYPE-NAME}
\\[0.5ex]
{\em type-name} ::= see \pagref{TYPE-NAME}
\end{indpar}
An {\tt *UNCHECKED*} conversion is implicitly defined from the associated data
type to the given pointer type, and a conversion
is implicitly defined in the other direction.

It is important that there be a 1-1 correspondence between
pointer types and their associated data types.  In particular,
{\tt int} must not be used as the associated data type of
more than one pointer type.  This is why associated data types
are generally user defined types.

A {\em pointer-type-declaration} `{\tt pointer type $P$ is type $D$}'
implicitly declares the functions:
\begin{indpar} \tt
function $P$ Q\$1 T\$1 @p = {\em ma}\QMARK{} *UNCHECKED* ( $D$ d ) \\
function $D$ d = $D$ ( $P$ Q\$1 T\$1 @p )
\end{indpar}
where {\em ma}\QMARK{} denotes the {\em module-abbreviation} of $P$,
if any.
These just copy values changing type.

For example, the following are builtin:

\begin{indpar}\begin{verbatim}
pointer type std dp is type std data for dp
pointer type std ap is type std data for ap
type std data for dp:
    int address
type std data for ap:
    dp ro int @base
    int offset

function dp Q$1 T$1 @r = std *UNCHECKED* ( std data for dp ddp )
function ap Q$1 T$1 @r = std *UNCHECKED* ( std data for ap dap )
function std data for dp r = std data for dp ( dp Q$1 T$1 @ptr )
function std data for ap r = std data for ap ( ap Q$1 T$1 @ptr )
    // These functions just copy the argument value to the
    // result value changing the type of the value.  Here
    // Q$1 is a wild-card that matches any list of qualifier-names,
    // and T$1 is a wild-card that matches any type-name.
\end{verbatim}\end{indpar}

Reading and writing values using a pointer of type $P$
can be accomplished by the functions:

\begin{indpar}[1ex] \tt
reference function T\$1 r =
    {\em ma}\QMARK{} ( $P$ QR\$1 T\$1 @p ) \ttkey{".*"} \\
reference function {\em ma}\QMARK{} ( $P$ QW\$1 T\$1 @p ) \ttkey{".*"} =
    T\$1 r
\end{indpar}
where {\em ma}, if present here, refers to the module in which $P$ is defined.

These functions can be defined after $P$ is defined.
They allow the pointer to be used to read a copy of the
value pointed at, or write the value, but do not allow
members or elements of the value to be accessed
(members and elements of the copy may be accessed).

These functions are implicitly called when the target
of a pointer variable is read or written.  For example:
\begin{indpar}\begin{verbatim}
ap int @p:
    p = 5
        // This translates to:
        //   @p.* = 5
int x = p
  // This translates to:
  //   int x = @p.*
\end{verbatim}\end{indpar}

An alternative strategy is to convert a pointer of type $P1$
to a pointer of type $P2$ that allows members and elements
to be accessed.  Suppose we are given:
\begin{indpar} \tt
pointer type $P1$ is type $D1$ \\
pointer type $P2$ is type $D2$
\end{indpar}

Then we can define a reference function with the prototype:
\begin{indpar} \tt
reference function $P2$ Q\$1 T\$1 @p2 =
    {\em ma}\QMARK{} ( $P1$ Q\$1 T\$1 @p1 ) \ttkey{".@"}
\end{indpar}
which converts a pointer of type $P1$ to a pointer of type $P2$,
where {\em ma}\QMARK{}, if present, refers to a module in which
both $P1$ and $P2$ are defined.
This conversion function is automatically called without any
{\em module-abbreviation} if a value pointed at by a pointer of type $P1$ is to
be accessed, in preference to calling the {\tt .*} functions above.
Then if $P2$ is {\tt dp}, {\tt ap}, {\tt fp}, {\tt av},
or {\tt fv}, the $P2$ pointer can be used to not only read or write
the value, but to also read or write members or elements of the
value.

Thus the above example becomes:
\begin{indpar}\begin{verbatim}
ap int @p:
    p = 5
        // This translates to:
        //   @p.@.* = 5
int x = p
  // This translates to:
  //   int x = @p.@.*
\end{verbatim}\end{indpar}

Since {\tt @p.*} and {\tt @p.@} are syntactically
{\em reference-calls}, these expressions
can only match reference function prototypes, and such matches
ignore the prototype result types, and use only the prototype
argument types.\pagnote{REFERENCE-CALL-DECLARATION-MATCHING}
Thus the inserted calls, which have no
module abbreviation, can be matched only if there
is at most one {\tt ".*"} or {\tt .@} function in the current context
with suitable qualifiers and type (e.g., {\tt Q\$1} and {\tt T\$1})
for a given $P1$.

Because there can be at most one matching {\tt .@} reference function 
declaration, {\tt .@} calls can be chained by the compiler.  In particular,
a {\tt .@} reference function that produces an {\tt ap} result will
be chained to the builtin:
\begin{indpar}\begin{verbatim}
reference function dp Q$1 T$1 @r = std ( ap Q$1 T$1 @p ) ".@":
    std data for ap dap = std data for ap ( @p )
    std data for dp ddp:
        ddp.address = dap.base + dap.offset
    @r = *UNCHECKED* ( ddp )
\end{verbatim}\end{indpar}

You can provide reference function definitions of {\tt .*} or {\tt .@}
with different actual
types in place of {\tt T\$1}, and these will be used in preference
to the definition that has the wildcard {\tt T\$1}.

As a convenience feature, instead of defining {\tt .@}, you
can define a reference function with prototype:
\begin{indpar} \tt
reference function $D2$ d2 = \\
\hspace*{4em} {\em ma}\QMARK{} \ttkey{*POINTER* *ACCESS* *CONVERSION*}
		( $D1$ d1 )
\end{indpar}
where {\em ma} refers to any module in which both $D1$ and $D2$ are defined.
This implicitly defines the reference function:
\begin{indpar} \tt
reference function $P2$ Q\$1 T\$1 @p2 = \\
\hspace*{1in}{\em ma}\QMARK{} ( $P1$ Q\$1 T\$1 @p1 ) ".@": \\
\hspace*{0.3in}$D1$ d1 = $D1$ ( @p1 ) \\
\hspace*{0.3in}$D2$ d2 = *POINTER* *ACCESS* *CONVERSION* ( d1 ) \\
\hspace*{0.3in}@p2 = *UNCHECKED* ( d2 )
\end{indpar}
where {\em ma} is the same module as that of the
{\tt *POINTER* *ACCESS* *CONVERSION*} function, if any.
An example usage is the builtin:
\begin{indpar}\begin{verbatim}
// This function enables conversion of `ap ...' to `dp ...'
// when an ap pointer is being used to access a value or
// member or element of a value.  The dp is the sum of the
// base and offset of the ap.
//
function std data for dp r = std *POINTER* *ACCESS* *CONVERSION*
        ( std data for ap dap ):
    std data for dp ddp:
        ddp.address = dap.base + dap.offset
    r = ddp
\end{verbatim}\end{indpar}

An example implementing a new pointer type is:

\begin{indpar}\begin{verbatim}
type file:
    *READ-WRITE* av uns8 @name
    . . . . .
av *READ-WRITE* file @files @= global [1000]
ap *READ-WRITE* int @number of files @= global

// Implement a file descriptor (fd) that addresses a file
// in files.  The fd contains an index and addresses
// files[index].

type data for fd:
    int index

pointer type fd is type data for fd

reference function ap Q$1 file @r = ( fd Q$1 file @p ) ".@":
    data for fd d = data for fd ( @p )
    ap file *READ_WRITE* @f = @files[d.index]
    @r = @f  // Implicitly converts *READ-WRITE* to Q$1

function fd *READ-WRITE* file @r = allocate fd:
    data for fd d:
        d.index = number of files
    @r = *UNCHECKED* ( d )
    number of files = number of files + 1

fd *READ-WRITE* file @f @= allocate fd
f.@name = ...
. . . . .
av uns8 @n = f.@name
. . . . .
\end{verbatim}\end{indpar}

\subsubsection{Pointer Type Conversions}
\label{POINTER-TYPE-CONVERSIONS}

You can define an implicit conversion of one pointer type
to another, after the manner of Section~\ref{TYPE-CONVERSIONS}.
An example is:

\begin{indpar}\begin{verbatim}
// This function enables implicit conversion of `dp ...' to
// `ap ...', where the latter has the constant 0 for a base
// and the dp value for its offset, provided the dp target is
// *GLOBAL*.
// 
dp *GLOBAL* int std @zero:
    zero = 0
function std ap QG$1 T$1 @r = std *IMPLICIT* *CONVERSION*
        ( std dp QG$1 T$1 @p ):
    std data for dp ddp = std data for dp ( dp QG$1 T$1 @p )
    std data for ap dap:
        dap.@base  = std @zero
        dap.offset = ddp.address
    @r = *UNCHECKED* ( dap )
\end{verbatim}\end{indpar}

As a convenience feature, we can define a
{\tt *POINTER* *IMPLICIT* *CONVERSION*} (non-reference) function instead.
 Suppose we are given:
\begin{indpar} \tt
pointer type $P1$ is type $D1$ \\
pointer type $P2$ is type $D2$
\end{indpar}
Then this function has prototype:
\begin{indpar}\label{POINTER-IMPLICIT-CONVERSION} \tt
function $D2$ d2 = {\em ma}\QMARK{} \ttkey{*POINTER* *IMPLICIT* *CONVERSION*}
                  ( $D1$ d1 )
\end{indpar}
where {\em ma} refers to any module in which both $D1$ and $D2$ are defined.
This implicitly defines the function:
\begin{indpar} \tt
function $P2$ Q\$1 T\$1 @p2 = \\
\hspace*{1in}{\em ma}\QMARK{} *IMPLICIT* *CONVERSION* ( $P1$ Q\$1 T\$1 @p1 ): \\
\hspace*{0.3in}$D1$ d1 = $D1$ ( @p1 ) \\
\hspace*{0.3in}$D2$ d2 = *IMPLICIT* *ACCESS* *CONVERSION* ( d1 ) \\
\hspace*{0.3in}@p2 = *UNCHECKED* ( d2 )
\end{indpar}
where {\em ma} is the same module as that of the
{\tt *IMPLICIT* *ACCESS* *CONVERSION*} function, if any.

One can define an {\tt *UNCHECKED*} function to convert
$P1$ values to $P2$ values.  As a convience, this can be
done by defining:
\begin{indpar} \tt
function $D2$ d2 = {\em ma}\QMARK{}  \ttkey{*POINTER* *UNCHECKED* *CONVERSION*}
			( $D1$ d1 )
\end{indpar}
which implicitly defines the function:
\begin{indpar} \tt
function $P2$ Q\$1 T\$1 @p2 = {\em ma}\QMARK{} \ttkey{*UNCHECKED*}
	( $P1$ Q\$1 T\$1 @p1 ): \\
\hspace*{0.3in}$D1$ d1 = $D1$ ( @p1 ) \\
\hspace*{0.3in}$D2$ d2 = *POINTER* *UNCHECKED* *CONVERSION* ( d1 ) \\
\hspace*{0.3in}@p2 = *UNCHECKED* ( d2 )
\end{indpar}

An example is the builtin:
\begin{indpar}\begin{verbatim}
// This function enables *UNCHECKED* conversion of `ap ...' to
// `dp ...' where the latter is the sum of the base and offset
// of the ap.
//
function std data for dp r = std *POINTER* *UNCHECKED* *CONVERSION*
        ( std data for ap dap ):
    std data for dp ddp:
        ddp.address = dap.base + dap.offset
    r = ddp
\end{verbatim}\end{indpar}

Lastly, one can define an explicit pointer conversion function with
prototype:
\begin{indpar}
function $P2$ Q\$1 T\$1 @p2 = {\em ma}\QMARK{} $P2$ ( $P1$ Q\$1 T\$1 @p1 )
\end{indpar}

\subsection{Inline Function Declarations}
\label{INLINE-FUNCTION-DECLARATIONS}

The syntax of a function declaration is:

\begin{indpar}[0.1in]
\emkey{function-declaration}\label{FUNCTION-DECLARATION}
    \begin{tabular}[t]{rl}
    ::= &  {\em function-prototype} \TT{:} \\
	& \TT{~~~~~}{\em statement}\PLUS{} \\
    $|$ &  {\em function-prototype}~ \TT{:}~ \ttkey{*DEFERRED*} \\
    \end{tabular}
\\[2ex]
\emkey{function-prototype}\label{FUNCTION-PROTOTYPE} ::= \\
\hspace*{0.25in}
    \begin{tabular}[t]{@{}rl}
        & {\em function-specializer}\QMARK{}~ \ttkey{function}~
          {\em prototype-result-list}~ \TT{=} \\
	& \TT{~~~~~} {\em module-abbreviation}\QMARK{}~
	             {\em prototype-pattern} \\
    $|$ & {\em function-specializer}\QMARK{}~ \ttkey{function}~
          {\em module-abbreviation}\QMARK{}~ {\em prototype-pattern} \\
    \end{tabular}
\\[2ex]
\emkey{function-specializer}\label{FUNCTION-SPECIALIZER} ::=
	\TT{macro} $|$ \TT{constant} $|$ \TT{inclusion}
\\[2ex]
\emkey{prototype-result-list}\label{PROTOTYPE-RESULT-LIST} ::= \\
\hspace*{0.5in}
    {\em prototype-result-declaration}
    \{ \TT{,} {\em prototype-result-declaration} \}\STAR{}
\\[0.5ex]
\emkey{prototype-result-declaration}\label{PROTOTYPE-RESULT-DECLARATION} \\
\hspace*{0.5in}\begin{tabular}[t]{rl}
    ::= & {\em prototype-result-variable-declaration} \\
    $|$ & {\em prototype-next-variable-declaration} \\
    \end{tabular}
\\[0.5ex]
{\em module-abbreviation} ::= see \pagref{MODULE-ABBREVIATION}
\\[0.5ex]
\emkey{prototype-result-variable-declaration}%
    \label{PROTOTYPE-RESULT-VARIABLE-DECLARATION} ::= \\
\hspace*{0.5in}\begin{tabular}{rl}
	    & {\em type-name} {\em target-variable} \\
	$|$ & {\em pointer-type-name}
              \{ {\em qualifier-name}\STAR{} {\em pointer-type-name}
	      \}\STAR{} \\
	& ~~~~~ {\em qualifier-name}\STAR{}
	        {\em type-name} {\em pointer-variable}
	\end{tabular}
\\[0.5ex]
{\em type-name} ::= see \pagref{TYPE-NAME}
\\[0.5ex]
{\em qualifier-name} ::= see \pagref{QUALIFIER-NAME}
\\[0.5ex]
{\em pointer-type-name} ::= see \pagref{POINTER-TYPE-NAME}
\\[0.5ex]
{\em variable-name} ::= see \pagref{VARIABLE-NAME}
\\[0.5ex]
{\em target-variable} ::= see \pagref{TARGET-VARIABLE}
\\[0.5ex]
{\em pointer-variable} ::= see \pagref{POINTER-VARIABLE}
\\[0.5ex]
\emkey{prototype-next-variable-declaration}%
    \label{PROTOTYPE-NEXT-VARIABLE-DECLARATION}
      ::= \ttkey{next} {\em variable-name}
\\[0.5ex]
\emkey{prototype-argument-declaration}\label{PROTOTYPE-ARGUMENT-DECLARATION} \\
\hspace*{0.5in}\begin{tabular}[t]{@{}rl@{}}
    ::= & {\em prototype-result-variable-declaration}
          \{ \TT{?=} {\em default-value} \}\QMARK{} \\
    $|$ & \TT{macro} {\em variable-name}
          \{ \TT{?=} {\em default-value} \}\QMARK{} \\
    $|$ & {\em prototype-result-variable-declaration}
          \TT{!=} {\em required-value} \\
    \end{tabular}
\\[0.5ex]
\emkey{default-value} ::= {\em expression}
\\[0.5ex]
\emkey{required-value} ::= {\em constant-expression}
\\[0.5ex]
{\em expression} ::= see \pagref{EXPRESSION}
\\[0.5ex]
{\em constant-expression} ::= an {\tt const} valued expression as
    defined on \pagref{CONSTANT-EXPRESSION}
\\[0.5ex]
\emkey{prototype-pattern}\label{PROTOTYPE-PATTERN}
    ::= {\em parenthesized-pattern-argument-list}\STAR{}~
        {\em pattern-term}\PLUS{}
\\[0.5ex]
\emkey{pattern-term}\label{PATTERN-TERM}
    ::= {\em function-term-name}~ {\em pattern-argument-list}\STAR{}
\\[0.5ex]
{\em function-term-name} ::= see \pagref{FUNCTION-TERM-NAME}
\\[0.5ex]
\emkey{pattern-argument-list}\label{PATTERN-ARGUMENT-LIST} \\
\hspace*{0.5in}
    \begin{tabular}[t]{@{}rl}
    ::= & \TT{(} {\em prototype-argument-declaration}~
	     \{ \TT{,} {\em prototype-argument-declaration} \}\STAR{} \TT{)} \\
    $|$ & \TT{[} {\em prototype-argument-declaration}~
	     \{ \TT{,} {\em prototype-argument-declaration} \}\STAR{} \TT{]} \\
    \end{tabular}
\\[0.5ex]
\emkey{parenthesized-pattern-argument-list}%
    \label{PARENTHESIZED-PATTERN-ARGUMENT-LIST} ::= \\
\hspace*{0.5in}
    {\em pattern-argument-list} with parentheses \TT{(~)}
    (and \underline{not} square brackets \TT{[~]})
\end{indpar}
\begin{enumerate}\label{FUNCTION-DECLARATION-RULES}
\item
A {\em prototype-pattern} {\em function-term-name} must not be
an initial segment of any other {\em function-term-name}
in the same {\em prototype-pattern}.
\item
{\em Function-term-names} (in a {\em prototype-pattern})
may not be {\em member-names}\pagnote{MEMBER-NAME}
(compare with {\em reference-function-declaration}%
\pagnote{REFERENCE-FUNCTION-DECLARATION}).
\item
{\em Pattern-argument-lists} appearing before the first
{\em function-term-name} may not use square \TT{[~]} brackets
(compare with {\em reference-function-declaration}%
\pagnote{REFERENCE-FUNCTION-DECLARATION}).
\item
There must be a {\em parenthesized-pattern-argument-list} that
is not omittable (it must have a {\em prototype-argument-declaration}
that has \underline{no} {\em default-value}) either immediately
before or immediately after the first {\em function-term-name}
in a {\em prototype-pattern}.  This distinguishes a
{\em function-call} from a {\em reference-expression}:
see Rule~\ref{PARENTHESIZED-ARGUMENT-LIST-RULE} on
page~\pageref{PARENTHESIZED-ARGUMENT-LIST-RULE}.
\item
Result and argument {\em variable-names}
in a {\em function-prototype} must not begin with a {\em module-abbreviation}.
\item
\label{PROTOTYPE-NEXT-RESULT}
For a {\em prototype-result-declaration} of the form `\TT{next} $v$',
$v$ must be the {\em vari\-able-name} in a {\em prototype-argument-declaration}
of the form `\dots{} {\em type-name} $v$', and
any actual argument associated to the {\em prototype-argument-declaration}
by some {\em function-call}
must be a {\em reference-expression} that
does not have the form `{\tt next} {\em variable-name}'.
\item If a {\em prototype-result-declaration}
has $N>0$ {\em pointer-type-names}, the {\em pointer-variable}
it declares must begin with exactly $N$ `\TT{@}'s.
\item
Result and argument {\em variable-names}
in a {\em function-prototype} must
be distinct, with an exception for the previous note.
\item
In a {\em pattern-argument-list}
a {\em prototype-argument-declaration} with no {\em de\-fault-value} cannot
follow a {\em prototype-argument-declaration} with a {\em default-value}.
\item
The first {\em prototype-argument-declaration}
in a {\em pattern-argument-list} that is at the very beginning
of a {\em prototype-pattern}, \underline{before} the first
{\em function-term}, must not have a {\em default-value}.
I.e., these {\em pattern-argument-lists} cannot be omitted from
{\em function-calls}.
\item
If the first {\em function-term-name} in the {\em prototype-pattern}
is a {\em type-name} or {\em pointer-type-name},
the {\em function-declaration} must have
a {\em prototype-result} with exactly
one {\em prototype-result-variable-declaration}
that has for its type this same {\em type-name} or has for its pointer type
this same {\em pointer-type-name},
and the {\em prototype-pattern} may not have any
{\em parenthesized-pattern-argument-lists} before the first
{\em function-term}.  The function
declared is called a \key{explicit type conversion function}%
\label{EXPLICIT-TYPE-CONVERSION-FUNCTION}, and a {\em function-call}
to the function is called an \key{explicit type conversion}%
\label{EXPLICIT-TYPE-CONVERSION}.
\item
A wild-card\pagnote{WILD-CARD} name of the form {\tt T\$\ldots}
is treated in a {\em function-prototype} as a {\em type-name}.
A wild-card name of the form {\tt P\$\ldots} is treated as a
{\em pointer-type-name}.
A wild-card name of the form {\tt Q\ldots\$\ldots} is treated as a
{\em qualifier-name} and \underline{must not} be combined with
other {\em qualifier-names} in the same
{\em prototype-result-variable-declaration}
or {\em prototype-argument-declaration}.
\item
{\em Function-declarations} with {\em function-specifiers} declare
\skey{special-function}s.  These may not compile run-time code,
and all their {\em prototype-result-variable-declarations}
must be of the form `{\tt const} {\em target-variable}.
These functions are referred to as \skey{macro function}s,
\skey{constant function}s, and \skey{inclusion function}s, respectively.
\item
A {\tt *DEFERRED*} {\em function-declaration} may \underline{not} be
a special function.

\end{enumerate}

An example of an inline function declaration and an inline function call is:
\begin{indpar}\begin{verbatim}
function F ( int x ?= 5 ) G ( int y ) H ( int z ?= 7 ) I ( int w ):
    . . . . . . . . . .
F I ( 8 ) G ( 6 )    // Equivalent to F ( 5 ) G ( 6 ) H ( 7 ) I ( 8 )
\end{verbatim}\end{indpar}

The {\em function-term-names} in the declaration are matched to those
in the call, but need not have the same order in the call, except for
the first {\em function-term-name} which must be the same in the
declaration and the call.  Thus the {\em call-terms} of the call
are re-ordered to match the order of the {\em pattern-terms} of the
declaration.  If one of the {\em pattern-terms} is omitted in the
call, but its arguments have {\em default-values},
the {\em pattern-term} with its
{\em default-values} will be inserted into the call
(here {\tt H ( 7 )} is inserted).
Similarly with an {\em argument-list} that is omitted
(here {\tt ( 5 )} is inserted).

For an argument
list in the prototype to match an argument list in the call, both
must be surrounded by the same brackets; either both have {\tt (~)}
or both have {\tt [~]}, except that implied parentheses in the
call are treated as {\tt (~)} during matching.

As an example of this last,
\\[0.5ex]
\centerline{
{\tt r = x + y}
}
\\
is treated for matching purposes is as
\\[1ex]
\centerline{
{\tt ( r ) "=" ( ( x ) "+" ( y ) )}
}

Note that {\em quoted-marks} and {\em quoted-separators}
in {\em function-term-names} may appear with or without quotes in
{\em call-term-names}.\pagnote{CALL-TERM-NAME}  Thus we have the example:
\begin{indpar}\begin{verbatim}
function int z = ( int x ) "@@" ( int y ):
    . . . . . . . . . .
int v = 5 @@ 6       // Legal
int w = 5 "@@" 6     // Legal
\end{verbatim}\end{indpar}

However, quoting an operator will cause it to be not recognized as
an operator.  For example:
\\[0.5ex]
\centerline{
{\tt x + y * z}
~~~parses as~~~
{\tt \{ \{ "x" \}, "+", \{ \{ "y" \}, "*", \{ "z" \} \} \}} \\
} \\
whereas \\
\centerline{
{\tt x "+" y * z}
~~~parses as~~~
{\tt \{ \{ "x", "+", "y" \}, "*", \{ "z" \} \}}
}
In the latter, {\tt \{ "x", "+", "y" \}} cannot be recognized as
a {\em function-call} because the arguments {\tt "x"} and {\tt "y"} are
not bracketed (i.e., are not {\tt \{ "x" \}} and {\tt \{ "y" \}}),
and will also not be recognized as a {\em reference-expression}
(because {\tt "+"} cannot be in a {\em variable-name} or
begin a {\em member-name}) or
{\em constant}.

A {\em pattern-term} with the syntax:
\begin{indpar}
\emkey{boolean-pattern-term}\label{BOOLEAN-PATTERN-TERM} ::= \\
\hspace*{1in} {\em function-term-name} \TT{(}
        \TT{bool} {\em variable-name}
	\TT{?=} {\em default-value} \TT{)}
\end{indpar}

triggers special syntax in a call that matches the prototype.
In the call:
\begin{center}
\begin{tabular}{rcl}
{\em function-term-name} & is equivalent to
                         & {\em function-term-name} \tt ( TRUE ) \\
\TT{no} {\em function-term-name} & is equivalent to
                         & {\em function-term-name} \tt ( FALSE ) \\
\TT{not} {\em function-term-name} & is equivalent to
                         & {\em function-term-name} \tt ( FALSE ) \\
omitted {\em function-term-name} & is equivalent to
                         & {\em function-term-name}
			   \TT{(} {\em default-value} \TT{)} \\
\end{tabular}
\end{center}
Thus the example:
\begin{indpar}\begin{verbatim}
function F ( int x ) OPTION ( bool y ?= TRUE )
    . . . . . . . . . .
F ( 5 )            // Equivalent to F ( 5 ) OPTION ( TRUE )
F ( 5 ) OPTION     // Equivalent to F ( 5 ) OPTION ( TRUE )
F ( 5 ) no OPTION  // Equivalent to F ( 5 ) OPTION ( FALSE )
\end{verbatim}\end{indpar}

A function prototype result may be named `\TT{next} $v$' if
the prototype has an argument named $v$, in which case a {\em function-call}
matching the prototype must match the prototype argument $v$ to a
{\em reference-expression} $e$ that
does not have the form `\TT{next} {\em variable-name}'.
Then the {\em assignment-result}
corresponding to the prototype `\TT{next} $v$' may be omitted, and will
be taken to be `\TT{next} $e$' if $e$ is a {\em variable-name}
naming a stack \TT{co} variable for which `\TT{next} $e$' is legal,
and will otherwise be taken to be simply the {\em reference-expression} $e$.

For example:

\begin{indpar}\begin{verbatim}
function next x = inc ( int x ):
    next x = x + 1
. . . . . . . . . .
int y = ...
inc ( y )  // Equivalent to `next y = y + 1'.
ap *READ-WRITE* int @z:
    z = ...
inc ( z )  // Equivalent to `z = z + 1'.
\end{verbatim}\end{indpar}

If a {\em required-value} is given in a prototype, the call must
have an equal {\tt const} valued actual argument value
in order for the call to match the prototype.
Note that the argument variable type need not be {\tt const},
as {\tt const} values can be converted to run-time values:
equality will be checked after conversion to the argument type.
Matches to prototypes with more {\em required-values}
are preferred over matches to prototypes with less {\em required-values}.
Thus the example:
\begin{indpar}\begin{verbatim}
function F ( int x ) G ( int y != 5 ):  // First F declaration
    . . . . . . . . . .
function F ( int x ) G ( int y ?= 5 ):  // Second F declaration
    . . . . . . . . . .
int z = 5
F ( 8 )            // Matches only second F declaration
F ( 8 ) G ( 5 )    // Matches preferred first F declaration
F ( 8 ) G ( 6 )    // Matches only second F declaration
F ( 8 ) G ( z )    // Matches only second F declaration
                   // (z is not const valued).
\end{verbatim}\end{indpar}

A {\em prototype-argument-declaration} with the syntax:
\begin{indpar}
\emkey{prototype-argument-declaration}\label{MACRO-ARGUMENT-DECLARATION} ::= \\
\hspace*{1in} \TT{macro} {\em variable-name}
                         \{ \TT{?=} {\em default-value} \}\QMARK{}
\end{indpar}
causes the argument value in a call to be the \underline{parse}
of the actual argument, which is a {\tt const} value.  If the
{\em default-value} is used, it is evaluated as a {\em constant-expression}.

When a \key{macro function} is called it must return a {\tt const} result
that is a parsed expression which replaces
the {\em function-call}.  For example:
\begin{indpar}\begin{verbatim}
macro function const r = sum ( macro a1, macro a2 ?= { 1 } ):
    r = { a1, "+", a2 };
    
int x = ...
int y = sum ( x, 5 ) // Same as: int y = x "+" 5
                     // Parsed equivalent:
                     //     { "int" "y" } "=" { { x } "+" { 5 } }
                     // a1 is { x }, a2 is { 5 }
int y = sum ( x )    // Same as: int y = x "+" 1
                     // Parsed equivalent:
                     //     { "int" "y" } "=" { { x } "+" { 1 } }
                     // a1 is { x }, a2 is { 1 }
\end{verbatim}\end{indpar}

When a \key{constant function}\label{CONSTANT-FUNCTION} is called
its must return a {\tt const} result that replaces
the {\em function-call} if the {\tt const} value is not a map,
and effectively replaces the {\em function-call} if the {\em const}
value is a map.  Examples:
\begin{indpar}\begin{verbatim}
constant function const r = sum ( const a1, const a2 ):
    r = a1 + a2;

const x = 10
const y = sum ( x, 5 )  // Sets y to 15
                        // a1 is 10, a2 is 5, r is 15
                        // sum ( x, 5) can be thought of as
                        // being replaced by 5

constant function const r = list ( const a1, const a2 ):
    r = { a1, a2 }

const z = list ( 4, 5 )  // Sets z to { 4, 5 }
    // list ( 4, 5 ) can be thought of as being replaced by:
    // { { 4, 5 }, ".initiator" = "{", ".terminator" = "}" }[0]
    // which evaluates to { 4, 5 }
\end{verbatim}\end{indpar}

The {\tt constant} {\em function-specializer} effectively does nothing
but promise that the function will not compile run-time code.

A \emkey{constant-expression}\label{CONSTANT-EXPRESSION}
is an {\em expression} that is either
a {\em constant} or a {\em function-call} to a {\tt constant} function.
{\em Constant-expressions} are used to compute parameters that must be
known at compile-time.

An \key{inclusion function} declaration can only be matched to
a {\em function-call} at statement level in a {\em call-assign\-ment-statement}.
When an \key{inclusion function} is called it must return a {\tt const} result
that is a parsed list of {\em statements} that replaces
the {\em call-assignment-statement}.
See Section~\itemref{INCLUSIONS} for examples.

Arguments to special functions \underline{need not} have the {\tt const}
type.  The values of the arguments cannot be accessed by the functions,
but their types can be.

A `{\tt *DEFERRED*}' {\em function-declaration} permits
inline functions defined between it and a later
non-{\tt *DEFERRED*} companion {\em function-declaration} to call the
function.  An example is:
\begin{indpar}\begin{verbatim}
function F2 ( const i): *DEFERRED*
function F1 ( const i):
    if i != 0:
        <do F1 thing>
        F2 ( i - 1 )

F1 ( 1 )   // Compile Error: Call F2(0) cannot be expanded.

function F2 ( const i )
    if i != 0:
        <do F2 thing>
        F1 ( i - 1 )

F1 ( 5 )   // Legal, expands to:
           //    <do F1 thing>
           //    <do F2 thing>
           //    <do F1 thing>
           //    <do F2 thing>
           //    <do F1 thing>
           // Would not be legal if the deferred
           // function declaration were omitted,
           // as then no F2 declaration would be
           // visible to the statements of F1.
\end{verbatim}\end{indpar}
Here the statements of {\tt F1} compile in the context
of the declaration of {\tt F1} and need the {\tt *DEFERRED*}
declaration of {\tt F2} in that context to enable these
statements to call {\tt F2}.  Given that a call is enabled,
the situation where the statements of {\tt F2} are provided later
is permitted.

A {\tt *DEFERRED*} declaration and its companion non-{\tt *DEFERRED*}
declaration must have identical prototypes, except:
\label{COMPANION-DECLARATION}
\begin{itemize}
\item {\em Default-values} and {\em required-values} may appear
only in the {\tt *DEFERRED*} declaration
and be omitted in the companion, but not vice-versa.
\item If {\em default-values} and {\em required-values} appear
in both the {\tt *DEFERRED*} declaration and its companion,
they must evaluate to the same {\em const} value.  They need not
have the same {\em constant-expressions}, but note
that the two {\em constant-expressions} are each evaluated where
their prototype is declared, and therefore are evaluated in
two different contexts.
\end{itemize}

A {\tt *DEFERRED*} inline {\em function-declaration} may have at
most one companion.

The prototype of an inline {\em function-declaration} is visible
to the {\em statements} of that same declaration, and therefore
an inline function can call itself without having any {\tt *DEFERRED*}
companion.

Recursion in inline function calls must be limited by {\tt const}
variables such as the counter {\tt i} in the above example,
for if it is not, there
will be a compile error when the compiler decides the inline nesting
is too deep or the code generated by one statement is too much.

A special function can\underline{not} be {\tt *DEFERRED*}.

\subsubsection{Inline Call-Declaration Matching}
\label{INLINE-CALL-DECLARATION-MATCHING}

Each {\em function-call} in a statement must be matched to a single
{\em function-declaration}, else compilation of the statement fails
with a compile error.

The first step in processing
a {\em statement} is to visit in bottom-to-top left-to-right order
all the {\em expressions} in the {\em statement} and apply the following
algorithm with evaluates {\em constant-expressions}, analyzes
{\em reference-expressions}, and processes macros and inclusions:

\bigskip

\centerline{\bf Bottom-Up Expression Algorithm}
\begin{enumerate}

\item This algorithm is applied to an {\em expression} $E$, and
terminates after any step that annotates $E$.

\item\label{CONSTANT-STEP}
If $E$ is a {\em constant}\pagnote{CONSTANTS} other than
a {\em rational-constant}, evaluate $E$
to a {\tt const} value $C$, annotate $E$
with $C$ and with the type {\tt const}
({\em Rational-constants} are evaluated as {\em function-calls} to
a {\tt constant} function in Step~\ref{CONSTANT-FUNCTION-STEP} below.)

\item\label{REFERENCE-EXPRESSION-STEP}
If $E$ is a {\em reference-expression}, processing depends upon whether
the {\em reference-expres\-sion} is compile-time or run-time.
First we consider the case where there are no
{\em reference-calls}\pagnote{REFERENCE-CALL} in the
{\em reference-expression}.

Then the {\em reference-expression} begins with a {\em variable-name}
(not a {\em function-variable-name}) and is compile time if that
variable has type {\tt const} and run-time otherwise.
The according to the rule of
Reference Expressions, \itemref{REFERENCE-EXPRESSIONS},
if the {\em reference-expression} is compile time compute its reference pointer
and annotate $E$ with that, and if run-time compute the type of its
reference pointer and annotate $E$ with that.  Also for compile-time
loading {\em reference-expressions}, dereference the reference pointer
to get a {\tt const} value $C$, and annotate $E$ with $C$.

For compile-time {\em reference-offsets} not involved in {\em reference-calls},
any index {\em expressions} must have previously been annotated with
a {\tt const} value, else it is a compile error.

For run-time {\em reference-offsets} not involved in {\em reference-calls},
any index {\em expressions} are annotated with the \TT{int} target type.

{\em Reference-calls} are handled as follows:

If the {\em reference-expression} $E$ begins with a
{\em function-variable-name}\label{FUNCTION-VARIABLE-NAME-STEP},
find the {\em reference-declaration} $D$ associated with
the {\em function-variable-name}.  If the $E$ is not loading, exclude
any {\em load} {\em reference-declaration}, and if $E$ is not storing,
exclude any {\em store} {\em reference-declaration}.  If no
{\em reference-declaration} is found (e.g., because $E$ is storing
and there is only a {\tt load} declaration), it is a compile-error.
Then annotate the root of $E$ with $D$.

For {\tt load} or {\tt store}
$D$, the root {\em function-variable-name} must be the
\underline{entire} {\em reference-expression}, else there is a
compile error.  In this case, annotate a compile-time $E$ with 
a pseudo reference pointer indicating that to load or store one
must call the function $F$ of $D$, and annotate a run-time $E$ with
a pseudo virtual reference pointer whose target type is the
result type of $F$ for {\tt load} $D$ and the input type of $F$
for {\tt store} $D$.
\footnote{A virtual reference pointer points
at a location in the local or global stack or points at a location
storing a pointer.  A pseudo virtual pointer
is merely associated with a function to load a value or a function to store
a value.}
For compile-time loading $E$, execute $F$
to get a {\tt const} value $C$ and annotate $E$ with $C$.

For {\tt point} $D$, $E$ must be run-time
(a {\tt point} $D$ cannot have a {\tt const} type {\em reference-base}
or result).  Then $E$'s reference pointer
type is the type of the value returned by the function $F$ of $D$ --
annotate the root of $E$ with this real reference pointer type.

The other {\em reference-call} case consists of an already processed
{\em reference-base} with a known reference pointer if compile-time
or reference pointer type if run-time
and its following unprocessed {\em reference-offset}.  With this
information a search is made for a matching
{\em reference-function-declaration} $D$, and if one is found,
the {\em reference-offset} it matches becomes processed.
If the $E$ is loading, $D$ cannot be a {\em store} declaration,
and if $E$ is storing, $E$ cannot be a {\em load} declaration.  If no
{\em reference-declaration} is found, it is a compile-error.
If a {\tt load} or {\tt store} declaration is found and the matching
{\em reference-offset} is not at the very end of $E$, it is a
compile error.
If $D$ is found annotate the {\em reference-call} with $D$,
and annotate each run-time index {\em expression}
with the {\tt int} target type.
If a compile-time index is \underline{not}
annotated with a {\tt const} value, it is a compile error.


Note that to get a match for run-time $E$, the type of the
{\em reference-base} reference pointer \underline{cannot} be virtual;
to match it must be the exact type of the {\em reference-pattern-base}
\pagnote{REFERENCE-CALL-DECLARATION-ARGUMENT-MATCHING}.

For {\tt load} or {\tt store} $D$,
annotate a compile-time $E$ with 
a pseudo reference pointer indicating that to load or store one
must call the function $F$ of $D$, and annotate a run-time $E$ with
a pseudo virtual reference pointer whose target type is the
result type of $F$ for {\tt load} $D$ and the input type of $F$
for {\tt store} $D$.
For compile-time loading $E$, dereference the reference pointer
for the {\em reference-base} and pass this as an argument to an
execution of $F$ to get a {\tt const} result $C$, and then
annotate $E$ with $C$.

For {\tt point} $D$, $E$ must be run-time
(a {\tt point} $D$ cannot have a {\tt const} type {\em reference-base}
or result).  Then the processed part of $E$'s reference pointer
type is the type of the value returned by the function $F$ of $D$ --
annotate the processed part of $E$ with this real reference pointer type.

For all \underline{run-time}
{\em reference-expressions}, whether or not they contain
{\em reference-calls}, the following is true.
For a pointing {\em reference-expression} the reference pointer it
computes must be real and its type must have a normal `real' pointer type.
For a loading or storing {\em reference-expression} the reference
pointer it computes may be (pseudo) virtual and its type may have a
`(pseudo) virtual'
pointer type, but the only thing that matters in this case is the
type of the value pointed at, which will be a normal `real' type.
In the case of a loading {\em reference-expression} the reference
pointer type must allow values to be read (e.g., it cannot have
the {\tt *INIT*} qualifier), and for a storing 
{\em reference-expression},
the reference pointer type must allow values to be stored
(e.g., it cannot have the {\tt co} qualifier), else there is a compile
error.

\item\label{MODULE-PROPAGATION-STEP}
If the \underline{entire} {\em expression} $E$ has the form: \\
\hspace*{2in}{\em module-abbreviation} \TT{(} {\em subexpression} \TT{)} \\
where the parentheses may \underline{not}
be implied, move the {\em module-abbreviation}
to the beginning of the \underline{parsed} {\em subexpression}, and
repeat this step for the modified {\em expression}.
See \pagref{MA-SYNTACTIC-SUGAR} for an example.

\item\label{CONSTANT-FUNCTION-STEP}
If $E$ is a {\em function-call},
search for \underline{constant} {\em function-declarations}
matching $E$.  If one is found,
evaluate the declaration's function to get a {\tt const} value $C$,
and annotate $E$ with $C$ and the {\tt const} type.

\item\label{MACRO-FUNCTION-STEP}
If $E$ is a {\em function-call},
Search for \underline{macro} {\em function-declarations}
matching $E$.  If one is found,
evaluate the declaration's function to get a {\tt const} value $R$,
replace $E$ by $R$, and go to Step 1.

Note that macro arguments that are {\em constant-expressions}
(those annotated with a {\tt const} value) or {\em reference-expressions}
are processed before this step.

\item\label{INCLUSION-FUNCTION-STEP}
If $E$ is a {\em function-call}
that is top level in a {\em call-assignment-statement} $S$,
search for \underline{inclusion} {\em function-declarations}
matching $E$.

Otherwise evaluate the declaration's function to {\tt const} return values.
The first return value replaces $S$ (not $E$).

Subsequent return values are assigned to $S$'s {\em assignment-results}
in left-to-right order.
Thus if $S$
has $N$ {\em assignment-results} (all of which must be {\tt const} variables),
then the execution must return at
least $N+1$ results (all of which must be {\tt const} values).
If there are excess results, discard them.  If there are too few,
it is a compile error.

If $S$ has been replaced, terminate this algorithm.

Note that inclusion arguments that are {\em constant-expressions}
(those annotated with a {\tt const} value), {\em reference-expressions},
or macros are processed before this step.

\end{enumerate}

The second step in processing a {\em statement} is to visit in top-down order
all the {\em expressions} $E$ in the {\em statement}
and locate for each $E$ that are {\em function-calls}
(and not annotated with a {\tt const} value by the Bottom-Up Algorithm above)
a matching {\em function-declaration}.  Or more specifically,
a {\em function-declaration} whose {\em function-prototype} matches
the {\em function-call}.  In this step all \underline{non-special}
{\em function-declarations} that are in scope are included in the search
(special {\em function-declarations} were processed by the above
Bottom-Up Expression Algorithm).

Furthermore in this step each $E$ has a target type $T$ (or types),
and {\em function-prototypes} that match the expression are required to
have a result of this type (or results of these types).

In an {\em expression-assignment-statement}%
\pagnote{EXPRESSION-ASSIGNMENT-STATEMENTS} each right-side {\em expression}
has a corresponding left-side {\em assignment-result} which is a
{\em reference-expression} that is annotated with a reference pointer type
which when dereferenced gives the right-side {\em expression's} target type.

In a {\em call-assignment-statement}%
\pagnote{CALL-ASSIGNMENT-STATEMENTS} in which $E$ is the {\em function-call}
on the statement's right-side, the statement's
left-side {\em assignment-results} are {\em reference-expressions} that
taken together give a list of the {\em function-call's} target types.

For an {\em expression} that is a {\em function-call} argument,
the declaration matched to the {\em function-call} specifies the
target type of the argument {\em expression}.  For example, in
`{\tt int z = x + 5}' the target type of {\tt +} is {\tt int},
the declaration matched to `{\tt x +  5}' (the only one with an {\tt int}
result type) has {\tt int} result
and argument types, so {\tt int} is the target type of `{\tt x}' and `{\tt 5}'.

For an index of a {\em reference-expression}, the Bottom-Up 
Algorithm above has annotated the index {\em expression} with its target type.

As a special case, in a relational expression such as `{\tt x < y + 5}'
all the operands are assigned the same target type by the following
procedure.
If one of the operands is
an explicit type conversion\pagnote{EXPLICIT-TYPE-CONVERSION},
the type of the explicit type conversion
becomes the target type of all the operands
(as in `{\tt x < flt ( y + 5 )}').
Otherwise, if
one of the operands is a {\em reference-expression},
its type is tested as the target type of all the operands,
and if successful, its type is used
(in `{\tt x < y + 5}',
the type of `{\tt x}' becomes the target type of `{\tt y + 5}'),
If several operands are {\em reference-expressions}, this succeeds if
one of these has a type into which the types of the others can be
implicitly converted.

Consider the case of {\em expression} $C$ which is a {\em function-call}
containing an argument {\em expression} $E$.  The various
{\em function-declarations} that might match $C$ specify various
target types for $E$.  Some of these target types may be the same,
so if we find matches for $E$ with a given target type, we should
remember what we found so we do not re-compute the match for
that target type if it is needed again.  Therefore, when we find a
{\em function-declaration} $D$ matching $E$ for target type $T$, we annotate
$E$ with $T\mapsto D$.  These annotations may then be used to compile
the {\em statement} after this third step is completed.

Given all this, when the third step visits an {\em expression} $E$ with
target type $T$ the third step executes:


\bigskip

\centerline{\bf Top-Down Expression Algorithm}
\begin{enumerate}

\item This algorithm is applied to an {\em expression} $E$ and its
target type $T$ found by
top-to-bottom left-to-right transversal of the {\em expressions} of the
current statement.  It annotates {\em expressions} with maps from
possible target types to declarations containing code that can execute
the {\em expressions},
When this algorithm searches for a declaration matching an {\em expression},
it uses the Declaration Search Algorithm below.

\item If $E$ already has an annotation $T\mapsto \ldots$,
terminate this algorithm.  In what follows, processing of $E$ is
terminated whenever $E$ is annotated with $T\mapsto \ldots$.

\item If $E$ is annotated with a {\tt const} value
(from the Bottom-Up Step), then if $T$ equals {\tt const},
annotate $E$ with $T\mapsto{*EXACT*}$.
Otherwise search the implicit conversion
graph\pagnote{IMPLICIT-CONVERSION-GRAPH}
for some shortest path $D_1,D_2,\ldots,D_n$ from $T$ to {\tt const},
and if one is found annotate $E$ with $T\mapsto D_1,D_2,\ldots,D_n$,
or if not found,
annotate $E$ with $T\mapsto {\tt *FAIL*}$.

\item If $E$ is a
{\em reference-expression}\pagnote{REFERENCE-EXPRESSIONS},
annotated with a reference pointer type that points at a value
of type $T'$,
then if $T$ equals $T'$ annotate $E$ with $T\mapsto{*EXACT*}$.
Otherwise search the implicit conversion
graph\pagnote{IMPLICIT-CONVERSION-GRAPH}
for some shortest path $D_1,D_2,\ldots,D_n$ from $T$ to $T'$,
and if one is found annotate $E$ with $T\mapsto D_1,D_2,\ldots,D_n$,
or if not found,
annotate $E$ with $T\mapsto {\tt *FAIL*}$.

\item If $E$ is a {\em function-call}, search for \underline{non-special}
{\em function-declarations}
that match $E$.
If none are found,
annotate $E$ with $T\mapsto{\tt *FAIL*}$.
If more than one is found (of highest rank),
annotate $E$ with $T\mapsto{\tt *AMBIGUOUS*}$.
Otherwise if just one {\em function-declaration} $D$ of highest rank was found,
annotate $E$ with $T\mapsto D$.

If $E$ is the top level {\em function-call}
in a {\em call-assignment-statement}, and the latter has
more than one {\em assignment-result}, then $T$ is replaced by a list
$T_1,T_2,\ldots,T_m$ of target types (the types of the
{\em assignment-results}), and the search for
{\em function-declarations} is limited to those whose prototypes have
at least $m$ results with the first $m$ of these being of types
$T_1,T_2,\ldots,T_m$ respectively.

\end{enumerate}

\bigskip

The search algorithm used by the above is:

\bigskip

\centerline{\bf Declaration Search Algorithm}
\begin{enumerate}
\item This algorithm examines all ({\em reference-}){\em function-declarations}
in the current context\pagnote{CONTEXT} that meet criteria specified by the
search and applies the
Call-Declaration Matching Algorithm for
{\em function-declarations} (see \itemref{INLINE-CALL-DECLARATION-MATCHING})
of the Reference Call-Declaration Matching Algorithm for
{\em reference-function-declarations}
(see \itemref{REFERENCE-CALL-DECLARATION-MATCHING})
to each.
Search criteria can restrict the search to, for example, {\tt macro}
{\em function-declarations}, or to give another example,
to all non-special {\em function-declarations} with a given target type
(type of their first result).
\item
After examining all the appropriate declarations, this algorithm has
a set of declarations satisfying the (Reference)
Call-Declaration Matching Algorithm.
If the set is empty, this algorithm reports failure.  Otherwise all but
the highest ranking matches are discarded.  If there is only one match
left, this algorithm reports success along with the single highest
ranking matching declaration.
If there are more than one highest ranking match, this algorithm reports
ambiguity failure.

\end{enumerate}

The matching algorithm used by the above to match a {\em function-call}
with a {\em function-declara\-tion} is as follows.  For the corresponding
algorithm matching a {\em reference-call} to a
{\em reference-function-declaration} see
\itemref{REFERENCE-FUNCTION-DECLARATIONS}.

\bigskip

\centerline{\bf Call-Declaration Matching Algorithm}
\begin{enumerate}
\item\label{CALL-DECLARATION-MODULE-ABBREVIATION}
If the call begins with a {\em module-abbreviation}
and the {\em prototype-pattern} in the {\em function-declaration}
either does not have a preceding {\em module-abbreviation},
or is preceded by one that names a different module from that of the call,
the call-declaration match fails.

If the {\em function-call} begins with a {\em module-abbreviation}
and {\em prototype-pattern} is preceded by a {\em module-abbreviation}
identifying the same module, or
if the {\em function-call} does not begin with a {\em module-abbreviation}
and {\em prototype-pattern} is not preceded by a {\em module-abbreviation}
(both are non-external),
the match is marked as \key{module proficient}\label{MODULE-PROFICIENT}.

In what follows, any {\em module-abbreviation} beginning the
{\em function-call} is ignored, and the remainder of the {\em function-call}
is matched to the {\em function-declaration}'s prototype.

\item\label{CALL-DECLARATION-KEY}
The \key{key} of a {\em function-declaration}
is the number of argument lists before
the first {\em function-term-name} in its {\em prototype-pattern}
followed by that first
{\em function-term-name}.  For example, the key of
`{\tt (\ldots) "+" (\ldots)}' is `{\tt () "+"}'.

The {\em function-call} must begin with the key of the
{\em function-declaration}, else the call-declaration match fails.

This implies that argument lists before the first {\em call-term-name}
in a {\em function-call} can\underline{not} be omitted and must be bracketed
by actual or implied parentheses.

When matching two {\em function-term-name} \underline{lexemes}, if the one from
the {\em prototype-pattern} is {\tt "} quoted, the
one in the {\em function-call} may be quoted or not quoted.

The first {\em function-term-name} in the call may or may not be followed by
{\em call-argument-lists}.


\item\label{CALL-DECLARATION-TERM-NAMES}
The remainder of the {\em function-call}, the part after any
{\em call-argument-lists} following the first {\em function-term-name},
is scanned for {\em prototype-pattern}
{\em function-term-names} other than the first one, and also for
the words `{\tt no}' and `{\tt not}'.  At each point in the scan
one of the following must be found: (1) a {\em function-term-name} from
the {\em prototype-pattern}, other than the first such, or
(2) the word `{\tt no}', or (3) the word `{\tt not}', or
(4) a bracketed argument list (with explicit or
implicit brackets).
If none of these is found at some point in the scan,
the call-declaration match fails.  If a {\em function-term-name} is
found more than once, the call-declaration match fails.
Every `{\tt no}' and `{\tt not}' must immediately precede a
{\em function-term-name}, else the call-declaration match fails.

If the scan succeeds, the {\em function-call} is divided into
{\em call-terms}, each beginning with a {\em function-term-name}
possibly preceded by `{\tt no}' or `{\tt not}', and ending with
argument lists (that may be omitted).
If there are argument lists before the first {\em function-term-name}
(in the key), the situation is treated as
if both prototype and call began with identical virtual
{\em function-term-names}.

Then each {\em call-term} in the {\em function-call} is matched to
the {\em pattern-term} with the same name in the {\em function-declaration}.

\item\label{BOOLEAN-CALL-TERMS}
If a {\em call-term} begins with `{\tt no}' or `{\tt not}',
the {\em call-term} must have no argument lists and be matched to a
{\em boolean-pattern-term}\pagnote{BOOLEAN-PATTERN-TERM},
else the call-declaration match fails.
In this case the beginning `{\tt no}' or `{\tt not}' is removed and the
argument list `{\tt ( FALSE )}' is appended to the {\em call-term}.

If a {\em call-term} that does \underline{not}
begin with `{\tt no}' or `{\tt not}'
matches a {\em boolean-pattern-term}
and has no argument lists, the
argument list `{\tt ( TRUE )}' is appended to the {\em call-term}.

(By the rules below, if a {\em boolean-pattern-term} is not matched to
any {\em call-term}, it will be given its {\em default-value}.)

\item\label{CALL-TERM-MATCHING}
A {\em call-term}
must match its corresponding prototype {\em pattern-term} according
the rules that follow.  Failure of any call-prototype term match
causes the prototype-call match to fail.

\item\label{CALL-DECLARATION-CALL-TERM-ADJUSTMENT}
For a {\em call-term} to match its corresponding {\em pattern-term},
both must have the same number of {\em argument-lists}, the same brackets,
and the same number of
arguments in corresponding {\em argument-lists}, \underline{after}
the {\em call-term} has been \key{adjusted}.  The following are
permitted adjustments.

For every {\em pattern-term} that has no corresponding {\em call-term}
(because its {\em function-term-name} was not found in the call),
a {\em call-term} consisting of just the {\em pattern-term}'s
{\em function-term-name} is appended to the {\em function-call}.
After this the {\em call-terms} are re-ordered so their order
matches that of their associated {\em pattern-terms}.

A {\em call-term} {\em argument-list} with implied parentheses
is treated as if it had {\tt (~)} parentheses.

If in a left-to-right scan of a {\em call-term},
a {\em call-argument-list} with {\tt (~)} is expected but instead
a {\tt [~]} bracketed {\em call-argument-list} or
the end of the {\em call-term} is found,
an empty list {\tt ()} is inserted into the {\em call-term}.

If a {\em call-argument-list} is shorter than the
corresponding {\em pattern-argument-list}, and all omitted
arguments at the end of the {\em call-argument-list} have {\em default-values}
in the {\em pattern-argument-list}, the {\em default-values} corresponding
to the omitted arguments are added to
the end of the {\em call-argument-list}.
The {\em default-values} are compiled in the context of the
{\em function-declaration} and not the context of the {\em function-call}:
see \pagref{DEFAULT-CONTEXT}.

At this point the {\em pattern-argument-lists} in the prototype
{\em pattern-term} must match in order all the {\em call-argument-lists}
in the {\em call-term} in type of bracket and number
of arguments, else the call-declaration match fails.

\item If all the above is successful, then {\em actual-arguments}
in the call are matched to corresponding {\em prototype-argument-declarations}
in the {\em function-declaration} according to the rules that follow.
Failure of any of these matches causes
the call-declaration match to fail.

\item\label{CALL-DECLARATION-TARGET-MATCHING}
This section is skipped for special functions (functions whose
{\em prototype-result} has the form `{\tt macro} {\em variable-name}',
`{\tt constant} {\em variable-name}', or
`{\tt inclusion} {\em variable-name}').

The types in the {\em protocol-result-variable-declarations} are
matched left-to-right to the target types for these results.
Any wildcards\pagnote{WILD-CARD} in a
{\em protocol-result-variable-declaration}
are filled in from the corresponding target type, left-to-right.
If a wildcard gets more
than one value from this process, the call-declaration match fails.

Then if any prototype result type is not identical to its corresponding
assignment target type, the call-declaration match fails
(i.e., there is \underline{no} implicit conversion of function result
types).

\item\label{CALL-DECLARATION-ARGUMENT-MATCHING}
{\em Prototype-argument-declarations} are matched to
an {\em actual-arguments} and processed left to right.

If a {\em prototype-argument-declaration} $PAD$ is matched
to an {\em actual-argument} $AA$ and $PAD$ has a wildcard,
$AA$ must be {\em reference-expression} or a {\em constant-expression},
(i.e., annotated with a {\tt const} value by the Bottom-Up Algorithm)
else the
call-declaration match fails.  The wildcard is assigned from
information in the {\em reference-expression}'s
type (the type of value the reference pointer points at) or
{\em constant-expression}'s type (which is just {\tt const}).

If different values are assigned to the same wildcard by this
process (by different prototype-actual argument matches, or by
assignments made in Step~\ref{CALL-DECLARATION-TARGET-MATCHING})
the call-declaration match fails.

\item\label{CALL-DECLARATION-UNASSIGNED-WILDCARDS}
If any {\em prototype-argument-declaration} wildcards are unassigned
at this point,
the call-declaration match fails.

\item\label{CALL-DECLARATION-REQUIRED-VALUES}
If a {\em prototype-argument-declaration} has a {\em required-value},
its matching {\em actual-argument} must be a {\em constant-expression} with
a value equal to the {\em required-value} (which is itself the result
of a {\em constant-expression} evaluated in the context of the
{\em function-declaration}), after both are converted
to the argument type specified by the {\em prototype-argument-declaration},
else the call-prototype
match fails.  Note that the argument type \underline{need not} itself
be {\tt const}.

If the argument type is {\tt const} and the values being compared are
maps, the maps must be identical (they are compared as pointers and
not as lists of elements).

\item\label{CALL-DECLARATION-ARGUMENT-TYPING}
This section is skipped for special functions.

Matches between {\em prototype-argument-declaration} types
and acceptable {\em actual-argu\-ment} subexpression target types
are then checked, except for {\tt macro} arguments (that require
no run-time typing).  Specifically, if a {\em prototype-argument-declaration}
specifies a target type $T'$ for an {\em actual-argument} {\em expression} $E'$,
the Declaration Search Algorithm
is applied recursively to $E'$ with target type $T'$ to get
an annotation $T'\mapsto\ldots$ on $E'$.

Then if any argument $T'$ is mapped to {\tt *FAIL*} or {\tt *AMBIGUOUS*}
the call-declaration match fails.

If any is mapped to {\tt *EXACT*}, the call-prototype map is
marked as \key{conversion proficient}.  Note that only a single
argument needs to be {\tt *EXACT*} in order for the entire
call-declaration match to be marked conversion proficient.

\item\label{CALL-DECLARATION-RANK-COMPUTATION}
If the call-declaration match has been successful, it is assigned
a \key{rank} that is the sum of:
\begin{itemize}
\item the number of required arguments the prototype has
\item the negative of the number of {\tt T\$\ldots} wildcards
the prototype has; a wildcard name appearing more than once in
the prototype is counted only once
\item a very large number if the match is conversion proficient
\item an even larger number if the match is module proficient
\end{itemize}

\end{enumerate}

The following are examples using the builtin prototypes
\begin{indpar}
{\tt function N r = std (N v1) "+" ( N v2 )} \\
{\tt function bool r = std (N v1) "==" ( N v2 )} \\
{\tt function flt64 r = std flt64 (N v1)}
\end{indpar}
which exist for every builtin number type {\tt N}.
\begin{indpar}[1em]\begin{verbatim}
int32 x = ...
flt64 r1 = x + 5
    // Target type flt64 selects N = flt64 for "+".
    // Implicit conversions flt64 <--- int32 and
    // flt64 <--- const exist.
bool b1 = ( x == 5 )
    // Target type of "==" is bool.  Reference expression x selects
    // N = int32 as target type for "==" operands, which works
    // because implicit conversion int32 <--- const exists.
bool b2 = ( x == 5.5 )
    // Ditto, but when evaluated in the compiler with target type int32,
    // std *IMPLICIT* *CONVERSION* ( 5.5 ) fails and gives a
    // compile error, as 5.5 cannot be represented as an int32.
flt64 y = 5.5
bool b3 = ( x == y )
    // Reference expression y selects N = flt64 as target type
    // for "==" operands, which works because implicit conversion
    // flt64 <--- int32 exists.  Reference expression x selects
    // N = int32, which fails because implicit conversion
    // int32 <--- flt64 does NOT exist.
bool b4 = ( flt64 ( x ) == 5 )
    // The explicit type conversion function flt64 selects
    // N = flt64 which works because flt64 <--- const exists.
\end{verbatim}\end{indpar}

\subsection{Reference Function Declarations}
\label{REFERENCE-FUNCTION-DECLARATIONS}

A \key{reference function} is a function that can be
called as part of evaluating a {\em reference-expression}.
This part is called a {\em reference-call}\label{REFERENCE-CALL}.


A {\em function-variable-name} appearing at the beginning of
a {\em reference-expression} as the root is a {\em reference-call}.

A compound {\em reference-expression} can be a {\em reference-call}.

Note that if a {\em reference-expression} contains a
{\em module-abbreviation}, it is at the very beginning and
is part of the root ({\em function-}){\em variable-name}.

The syntax of a {\em reference-function-declaration} is:

\begin{indpar}[0.1in]
\emkey{reference-function-declaration}\label{REFERENCE-FUNCTION-DECLARATION}
	::= \\
\hspace*{2em}
    \begin{tabular}[t]{rl}
        &  {\em reference-function-prototype} \TT{:} \\
	& \TT{~~~~~}{\em statement}\PLUS{} \\
    $|$ &  {\em reference-function-prototype}~ \TT{:}~ \ttkey{*DEFERRED*} \\
    \end{tabular}
\\[2ex]
\emkey{reference-function-prototype}\label{REFERENCE-FUNCTION-PROTOTYPE} \\
\hspace*{0.25in}
    \begin{tabular}[t]{rl}
        ::= & \ttkey{load reference function} \\
	    & \TT{~~~~}{\em prototype-result-variable-declaration}~ \TT{=}~
            	{\em function-variable-name} \\
        $|$ & \ttkey{store reference function} \\
	    & \TT{~~~~}~ {\em function-variable-name} \TT{=}~
            	{\em prototype-result-variable-declaration} \\
        $|$ & \ttkey{point reference function} \\
	    & \TT{~~~~}{\em prototype-result-variable-declaration}~ \TT{=}~
            	{\em function-variable-name} \\
        $|$ & \ttkey{load reference function} \\
	    & \TT{~~~~}{\em prototype-result-variable-declaration}~ \TT{=}~
	        {\em reference-prototype-pattern} \\
        $|$ & \ttkey{store reference function} \\
	    & \TT{~~~~}~ {\em reference-prototype-pattern} \TT{=}~
	        {\em prototype-result-variable-declaration} \\
        $|$ & \ttkey{point reference function} \\
	    & \TT{~~~~}{\em prototype-result-variable-declaration}~ \TT{=}~
	        {\em reference-prototype-pattern} \\
    \end{tabular}
\\[0.5ex]
{\em reference-function-specifier} ::=
    \ttkey{load} $|$ \ttkey{store} $|$ \ttkey{point}
\\[0.5ex]
{\em prototype-result-variable-declaration} ::=
    see \pagref{PROTOTYPE-RESULT-VARIABLE-DECLARATION}
\\[0.5ex]
{\em function-variable-name} ::= see \pagref{FUNCTION-VARIABLE-NAME}
\\[0.5ex]
\emkey{reference-prototype-pattern}\label{REFERENCE-PROTOTYPE-PATTERN}
    ::= {\em reference-pattern-base}~ {\em reference-pattern-offset}
\\[0.5ex]
\emkey{reference-pattern-offset}\label{REFERENCE-PATTERN-OFFSET}
    \begin{tabular}[t]{rl}
    ::= & {\em member-name} \\
    $|$ & {\em member-name}~ {\em reference-pattern-index-list} \\
    $|$ & {\em reference-pattern-index-list} \\
    \end{tabular}
\\[0.5ex]
\emkey{reference-pattern-base} ::=
    \TT{(} {\em prototype-result-variable-declaration}~ \TT{)}
\\[0.5ex]
\emkey{reference-pattern-index-list} ::= \\
\hspace*{0.5in}
    \TT{[} {\em reference-pattern-index-declaration}
           \{ \TT{,} {\em reference-pattern-index-declaration} \}\STAR{} \TT{]}
\\[0.5ex]
\emkey{reference-pattern-index-declaration} ::=
    {\em prototype-result-variable-declaration}
\\[0.5ex]
{\em member-name} ::= see \pagref{MEMBER-NAME}
\\[0.5ex]
{\em pattern-argument-list} ::= see \pagref{PATTERN-ARGUMENT-LIST}
\end{indpar}
\begin{enumerate}
\item
A {\em reference-function-declaration} is compile-time if
its {\em prototype-result-variable-declara\-tion} before or after the
\TT{=} sign in its {\em reference-function-prototype}
has type {\tt const}, and is run-time otherwise.
{\em Reference-pattern-index-declarations} have type {\tt const}
if and only if the {\em reference-function-declaration} is compile-time.
\item
A {\tt point} {\em reference-function-declaration}
\underline{cannot} be compile-time.
\item
A {\em function-variable-name} begins with a {\em module-abbreviation}
if and only if it is external (just like other {\em variable-names}).
\item
A {\em reference-function-declaration} \underline{not} containing
a {\em function-variable-name} is external if and only if the
target type of its {\em reference-pattern-base} is external
(the full type is a pointer type to the target type).  In this case
the {\em reference-function-declaration} \underline{must} be within
the same module (file) as the {\em type-declaration} of this target type.
\item
The {\em reference-pattern-base} must be
followed by
a {\em member-name}\pagnote{MEMBER-NAME} or
{\em square-bracketed-pattern-argument-list}.
\item
Default values, required values, and {\tt macro} arguments
are not permitted.
\item
A wild-card\pagnote{WILD-CARD} name of the form {\tt T\$\ldots}
is treated in a {\em reference-function-prototype} as a {\em type-name}.
A wild-card name of the form {\tt P\$\ldots} is treated as a
{\em pointer-type-name}.
A wild-card name of the form {\tt Q\ldots\$\ldots} is treated as a
{\em qualifier-name} and \underline{must not} be combined with
other {\em qualifier-names} in the same
{\em prototype-result-variable-declaration}.
\item At most two {\em reference-function-declarations} in a context
may have the same {\em function-variable-name}, and in this case,
one must have the {\tt load} {\em reference-function-specifier},
and the other must have the {\tt store}
{\em reference-function-specifier}.
\item At most two {\em reference-function-declarations} in a context
may have the same {\em reference-pattern-base} argument type and
{\em member-name}, and in this case,
one must have the {\tt load} {\em reference-function-specifier},
and the other must have the {\tt store}
{\em reference-function-specifier}.
\item At most two {\em reference-function-declarations} in a context
may have the same {\em reference-pattern-base} argument type and
have a {\em square-bracketed-pattern-argument-list}, and in this case,
one must have the {\tt load} {\em reference-function-specifier},
and the other must have the {\tt store}
{\em reference-function-specifier}.
\end{enumerate}

\subsubsection{Reference Call-Declaration Matching}
\label{REFERENCE-CALL-DECLARATION-MATCHING}

A {\em reference-expression} is one of three types:
\begin{itemize}
\item \key{Loading} ~~ The {\em reference-expression} begins with a
{\em target-variable} (that does \underline{not} begin with `\TT{@}')
and is used to load a value from the referenced location.
\item \key{Storing} ~~ The {\em reference-expression} begins with a
{\em target-variable} (that does \underline{not} begin with `\TT{@}')
and is used to store a value into the referenced location.
\item \key{Pointing} ~~ The {\em reference-expression} begins with a
{\em pointer-variable} (that begins with `\TT{@}')
and is used to compute a pointer to the referenced location.
\end{itemize}

In the case of a {\em function-variable-name} reference call,
the {\em function-variable-name} is just located in the current
context just like any other {\em variable-name}, and may be
a {\em pointer-variable} of a {\em target-variable}.
The {\em function-variable-name} begins the {\em reference-expression}
and is the root of the {\em reference-expression}.
There are two cases:
\begin{itemize}
\item {\bf Load or Store} ~~
The {\em reference-function-declarations}
declaring the {\em function-variable-name} have {\tt load}
or {\tt store} {\em reference-function-specifiers} (there may be
two declarations, one {\tt load} and one {\tt store}).
The {\em function-variable-name} must be 
the entire {\em reference-expression}
(there can be no {\em reference-offsets}).
If the {\em reference-expression} is loading (or storing), there
must be a {\tt load} (or {\tt store}) {\em reference-function-declaration}
declaring the {\em function-variable-name}, and the declared function will
be called to load (or store) a value in the referenced location.
The {\em reference-expression} \underline{cannot} be pointing.
\item {\bf Point} ~~
There is only one {\em reference-function-declaration}
declaring the {\em function-vari\-able-name} and it has the {\tt point}
{\em reference-function-specifier}.
The {\em reference-expression} may be loading, or storing, or pointing.
The declared function is called and its result is the real refererence pointer
of the {\em reference-expression} root.  The {\em reference-expression}
may have {\em reference-offsets} that modify this reference pointer.
A {\tt point} {\em reference-function-declaration} \underline{cannot}
be compile-time.
\end{itemize}

In the case of a {\em reference-offset}, the part of the
{\em reference-expression} before the {\em reference-offset} is
the {\em reference-base} matched to the {\em reference-pattern-base}.
At compile time the type of the reference pointer produced by the
{\em reference-base} has been computed by recursion, and at run-time
the reference pointer has already been computed.

\bigskip

\centerline{\bf Reference-Call-Reference-Declaration Matching Algorithm}
\begin{enumerate}
\item\label{REFERENCE-CALL-REFERENCE-DECLARATION-OFFSET-MATCHING}
The {\em reference-offset} and the {\em  reference-pattern-offset} must
match in that
\begin{enumerate}
\item
If one has a {\em member-name}, both must have the same {\em member-name},
else the call-declaration match fails.
\item
If one has an {\em index-list}, both must have {\em index-lists}
with the same number of elements
else the call-declaration match fails
(but the types of the elements are not involved in matching).
\end{enumerate}

\item\label{REFERENCE-CALL-DECLARATION-ARGUMENT-MATCHING}
The {\em reference-base} in the call is matched to the
{\em reference-pattern-base} in the declaration.
If the latter has wildcards, the wildcards are assigned
information in the {\em reference-bases}'s type.

If one wildcard is assigned two or more different values, or zero values,
the call-declaration match fails.

If after this has been done, the type of the {\em reference-base}
does not exactly match the type of the {\em reference-pattern-base},
the call-declaration match fails.

\item\label{REFERENCE-CALL-DECLARATION-RANK-COMPUTATION}
If the call-declaration match has been successful, it is assigned
a \key{rank} that is the sum of:
\begin{itemize}
\item the negative of the number of {\tt T\$\ldots} wildcards
the prototype has; a wildcard name appearing more than once in
the prototype is counted only once
\item a very large number if the match {\em reference-offset} has
both a {\em member-name} and an {\em index-list}
\end{itemize}

\end{enumerate}


Example:

\begin{indpar}\label{REFERENCE-FUNCTION-EXAMPLE}\begin{verbatim}
// The *UNCHECKED* function used below is a builtin function
// that performs a variety of conversions which violate type
// checking.  Here it has the prototype:
//
//    av Q$ T$ @r = std *UNCHECKED*
//        ( ap Q$ T$ @p, int offset, int lower, int upper )
//
// that takes the ap @p, adds the offset argument to the
// pointer offset, and returns this as an av with bounds
// lower and upper.

// In my vector X, a vector with flt64 elements is located
// at X.offset from the address of X and allows index range
// from 0 through X.length-1.
//
type my vector:
    int offset        // Offset of first element in bytes.
    int length        // Number of elements.
    align 64
    *LABEL* first     // Offset of first element in bits.

point reference function ap Q$1 flt64 @x =
        ( ap Q$1 my vector @v ) [ int index ]:
    av Q$1 flt64 @p = *UNCHECKED*
            ( @v, v.offset, 0, v.length )
        // See *UNCHECKED* above.
    @x = @p[index]

type my data:
    *INCLUDE* my vector
    flt64[2]

ap *READ-WRITE* my data @D:    // `@= local' is implied
    D.offset = D.first / 8     // 8 converts bits to bytes.
    D.length = 2

D[0] = 5.5      // Computes and uses pointer @D[0]
D[1] = -7.33    // Computes and uses pointer @D[1]
flt64 x = D[0]  // Now x == 5.5
flt64 y = D[1]  // Now y == -7.33
flt64 z = D[2]  // Run time error: 2 >= upper bound of av
                // that equals D.length.

D[2] = 1.0      // Run-time error: bounds limit exceeded.
\end{verbatim}\end{indpar}


\subsection{Inclusions}
\label{INCLUSIONS}

An example of an inclusion is:
\begin{indpar}[1em]\begin{verbatim}
// Create int V and iterate for V = 0, 1, 2, ..., LIMIT-1.
//
//     for ( V, LIMIT ):
//         STATEMENTS*
//
// is equivalent to:
//
//     int V = 0
//     while V < LIMIT:
//         STATEMENTS*
//         V += 1
//
inclusion function const r = for ( macro V, macro LIMIT ):
    r = { { { "int" } + V, "=", { 0 } },
          { { "while", { V, "<", LIMIT } },
            com *SUBBLOCK* +
                { { "next" } + V, "+=", { 1 } } } }

// Compute sum = 1 + 2 + ... + 15
//
int sum = 0
for ( x, 15 ):
    next sum += x + 1

// The above for ... statement is expanded to:
//
//     int x = 0
//     while x < 15:
//         next sum += x + 1
//         next x += 1
//
// because:
//
//   com *SUBBLOCK* equals:
//     { { { "next", "sum" }, "+=", { { "x" }, "+", { 1 } } },
//       ".initiator" = ":", ".terminator" = *INDENTED-PARAGRAPH* }
    
\end{verbatim}\end{indpar}

Although the value of an inclusion is to be a sequence of
\underline{parsed} {\em statements}, it is not necessary to
include some of the annotations in these.
Specifically, it is \underline{not} necessary to
include the {\tt .position} or
the following {\tt .initiator}s or {\tt .terminator}s:

\begin{center} \tt
{\rm \bf Unnecessary Annotations}\label{UNNECESSARY-ANNOTATIONS}
\\[1ex]
\begin{tabular}{l@{~~~~~~~~~~}l}
\underline{.initiator} & \underline{.terminator}
\\[1ex]
\tt *LOGICAL-LINE* & \tt "<LF>" \\
\tt "(" & \tt ")" \\
\end{tabular}
\end{center}

because the {\tt .position} of the function call will be added
if no {\tt .position} is given,
logical lines can be identified from context, and
{\tt ()} bracketed subexpressions are equivalent to
subexpressions with implied brackets (i.e., with no
{\tt .initiator} or {\tt .terminator}).

However, any {\tt .separator} and the following must be included:

\begin{center} \tt
{\rm \bf Necessary Annotations}
\\[1ex]
\begin{tabular}{l@{~~~~~~~~~~}l}
\underline{.initiator} & \underline{.terminator}
\\[1ex]
\tt ":" & \tt *INDENTED-PARAGRAPH* \\
\tt "[" & \tt "]" \\
\tt "\{" & \tt "\}" \\
\end{tabular}
\end{center}

In the above example, {\tt com *SUBBLOCK*} evaluates to the
subblock in the `{\tt for \ldots}' statement, and this subblock
has {\tt ".initiator" = ":"} and {\tt ".terminator" = *INDENTED-PARA\-GRAPH*},
which are the necessary annotations that are carried over into
the concatenation
{\tt com *SUBBLOCK* + \{\ldots\}}.

The {\em include-assignment-statement} can be used to return a list
of parsed {\em statements}:

\begin{indpar}
\emkey{include-assignment-statement}\label{INCLUDE-ASSIGNMENT-STATEMENT} ::= \\
\hspace*{0.3in}
    \begin{tabular}[t]{rl}
    & \TT{const} {\em target-variable} \TT{=} \TT{*INCLUDE*}
    	{\em include-argument-list}\QMARK{} \TT{:} \\
    & \TT{~~~~}{\em statement}\STAR{} \\
    $|$ & \TT{const} {\em target-variable} \TT{=} \\
    & ~~~~~~~~\TT{*INCLUDE*}
    	{\em include-argument-list}\QMARK{} \TT{:}
	{\em restricted-statement} \\
    \end{tabular}
\\[0.5ex]
\emkey{include-argument-list} ::= \TT{( )} $|$
	\TT{(} {\em include-argument}
	\{ \TT{,} {\em include-argument} \}\STAR{} \TT{)}
\\[0.5ex]
\emkey{include-argument} ::= {\em word} beginning with a capital {\em letter}
\\[0.5ex]
\emkey{restricted-statement} ::= see \pagref{RESTRICTED-STATEMENT}

\end{indpar}

An {\em include-statement} is executed at compile time;
its {\em statements} are parsed and the parser output is
returned.

Each {\em include-argument} must be a {\tt const} variable assigned
a value before the {\em include-state\-ment} compiles.
Everywhere this variable
appears in the parsed {\em statements} of the {\em include-statement},
the value of the variable is substituted for the variable name.

Substitution for {\em include-arguments} obeys the following rules:
\begin{itemize}
\item \label{INCLUDE-SPLICING} If the {\em include-argument}
value is a list, and if the
instance being substituted is an element of a list,
the {\em include-argument} list is spliced into the instance containing
list.  However any {\em include-argument} dictionary entries are
discarded.
\\[0.5ex]
Thus if {\tt X = \{"A", "B", ".separator" = ","\}} then \\
\hspace*{2em}{ \tt
"Y", "=", \{ "X", "C" \} {\rm becomes} "Y", "=", \{ "A", "B", "C" \}
} \\
and \\
\hspace*{2em}{ \tt
"Y", "=", \{ "X", "C", ".separator" = "," \}} \\
becomes \\
\hspace*{2em}{ \tt
"Y", "=",
\{ "A", "B", "C", ".separator" = "," \}
} \\
The {\em include-argument} value list may be empty.
If {\tt X = \{\}} then \\
\hspace*{2em}{ \tt
"Y", "=", \{ "foo", "X" \} {\rm becomes} "Y", "=", \{ "foo" \}
} \\
If you do not want a list valued {\em include-argument} to be spliced in,
use {\tt (~)} parentheses around the instance being substituted.
Thus if {\tt X = \{"A", "*",  "B"\}} then \\
\hspace*{2em}%
     \begin{tabular}{l}
     \tt "Y", "=", \{ ("X"), "+", 1 \} \\
     becomes \\
     \tt "Y", "=", \{ ("A", "*", "B"), "+", 1 \}
     \end{tabular}

\item Otherwise the non-list value of the {\em include-argument} replaces the
instance in the parsed {\em statement}.
Thus if {\tt X = "A"} then \\
\hspace*{2em}{\tt
"Y", "=", \{ "X", "*", 2 \} {\rm becomes} "Y", "=", \{ "A", "*", 2 \}
}
\end{itemize}

So the above example {\tt for} inclusion could have written as:
\begin{indpar}[1em]\begin{verbatim}
function inclusion r = for ( macro V, macro LIMIT ):
    const P = com *SUBBLOCK*
    r = *INCLUDE* ( V, LIMIT, P ):
        int V = 0
        while V < LIMIT:
            P
            next V += 1
\end{verbatim}\end{indpar}


\subsection{Out-of-Line Function Declarations}
\label{OUT-OF-LINE-FUNCTION-DECLARATIONS}

An out-of-line function prototype is a limited subset of
an inline function prototype which ensures that there is
a single ordered list of arguments.  To obtain a more
flexible interface, an out-of-line function call should
be embedded in an inline function that pre-processes the
arguments.

The syntax of an out-of-line function declaration is:

\begin{indpar}
\emkey{out-of-line-function-declaration}%
	\label{OUT-OF-LINE-FUNCTION-DECLARATION} ::= \\
\hspace*{0.5in}
    \begin{tabular}[t]{rl}
        &  {\em out-of-line-function-prototype} \TT{:} \\
	& \TT{~~~~~}{\em statement}\PLUS{} \\
    $|$ &  {\em out-of-line-function-prototype} \TT{:}
    		\ttkey{*DEFERRED*}~ {\em foreign-function-name}\QMARK{} \\
    \end{tabular}
\\[2ex]
\emkey{out-of-line-function-prototype}%
	\label{OUT-OF-LINE-FUNCTION-PROTOTYPE} ::= \\
\hspace*{0.25in} \ttkey{out-of-line function}~
          \{ {\em prototype-result-list}~ \TT{=}~ \}\QMARK{} \\
\hspace*{0.5in}{\em out-of-line-function-name}~
	      {\em parenthesized-pattern-argument-list}\QMARK{}
\\[0.5ex]
\emkey{out-of-line-function-name} ::=
    {\em module-abbreviation}\QMARK{} {\em basic-name}
\\[0.5ex]
\emkey{foreign-function-name}\label{FOREIGN-FUNCTION-NAME}
	::= {\em quoted-string}
\\[0.5ex]
{\em prototype-result-list} ::= see \pagref{PROTOTYPE-RESULT-LIST}
\\[0.5ex]
{\em module-abbreviation} ::= see \pagref{MODULE-ABBREVIATION}
\\[0.5ex]
{\em basic-name} ::= see \pagref{BASIC-NAME}
\\[0.5ex]
{\em parenthesized-pattern-argument-list} ::=
    see \pagref{PARENTHESIZED-PATTERN-ARGUMENT-LIST}

\begin{enumerate}
\item
The rules for inline {\em function-declarations} on
\pagref{FUNCTION-DECLARATION} must be followed where applicable.
\item
{\em Out-of-line-function-declarations} must be top level; they
\underline{cannot} be inside subblocks.
\item
{\tt macro} and required arguments are not allowed.
\item
Wild-cards are not allowed.
\item Functions with {\em foreign-function-names} are called \key{foreign}
and are {\tt *DEFERRED*} but have \underline{no} companions.
Foreign functions are called using
their associated {\em out-of-line-function-name}.
\item
Arguments and results of foreign C and C++ functions cannot 
have user defined types or user defined pointer types,
but may builtin pointer types ({\tt dp}, {\tt ap}, {\tt fp}, etc.)
pointing at builtin or user defined target types.
\item
The rules for inline `{\tt *DEFERRED*}'
{\em function-declarations} and
their companions on \pagref{COMPANION-DECLARATION}
must be followed for
{\tt *DEFERRED*} \underline{non-foreign}
{\tt out-of-line-function-de\-clar\-ations}
and their companions.
\end{enumerate}
\end{indpar}

An out-of-line functions can be called with a normal
{\em function-call}\pagnote{FUNCTION-CALL}.

Unlike inline functions, an out-of-line function can
be called from a statement for which only a {\tt *DEFERRED*} declaration
of the out-of-line function is visible.  A missing companion
declaration is not a compile-time error, but will be a
run-time error if the function is actually called at run-time.

Like inline functions, a {\tt *DEFERRED*}
non-foreign {\em out-of-line-function-declaration}
can have only one companion.
If\label{OUT-OF-LINE-EXTERNAL-COMPANION}
a {\tt *DEFERRED*} non-foreign {\em out-of-line-function-declaration}
is ex\-ternal,\pagnote{EXTERNAL-FUNCTION}
its companion may be anywhere in the scope of the declaration,
including in another module or another module's body that imports
the declaration's module.
This allows a module to call out-of-line functions defined by
a companion in another module that imports the first module.

\subsubsection{Function Type Declarations}
\label{FUNCTION-TYPE-DECLARATIONS}

A function type whose values are pointers to out-of-line
functions may be declared by:

\begin{indpar}
\emkey{function-type-declaration}\label{FUNCTION-TYPE-DECLARATION} ::= \\
\hspace*{0.5in}
    \ttkey{type} {\tt function-type-name} \TT{is}
                 {\em function-type-prototype}
\\[0.5ex]
\emkey{function-type-name} ::= {\em type-name}
\\[0.5ex]
{\em type-name} ::= see \pagref{TYPE-NAME}
\\[0.5ex]
\emkey{function-type-prototype}%
	\label{FUNCTION-TYPE-PROTOTYPE} ::= \\
\hspace*{0.25in} \ttkey{function}~
        \{ {\em prototype-result-list}~ \TT{=} \}\QMARK{}~
	\TT{()}~ {\em parenthesized-pattern-argument-list}\QMARK{}
\begin{enumerate}
\item
{\em Function-type-declarations} must be top level; they
\underline{cannot} be inside subblocks.
\end{enumerate}
\end{indpar}

Here the {\em function-type-prototype} is just like an
{\em out-of-line-function-prototype} except that the
{\em out-of-line-function-name} is replaced by {\tt ()} and
the word `{\tt out-of-line}' is omitted as being superfluous.

The only operations defined on function type values are copying them,
comparing them with {\tt ==} and {\tt !=}, and
calling them.  A call to such a value must be a
{\em call-expression}\pagnote{CALL-EXPRESSION} and
must be the right side (after the {\tt =})
of a {\em call-assignment-state\-ment}.\pagnote{CALL-ASSIGNMENT-STATEMENTS}.

A function constant can be declared by:
\begin{indpar}
\emkey{function-constant-declaration}%
    \label{FUNCTION-CONSTANT-DECLARATION} ::= \\
\hspace*{0.5in}
    \begin{tabular}[t]{rl}
        &  {\em function-type-name} {\em function-constant-name} \TT{:} \\
	& \TT{~~~~~}{\em statement}\PLUS{} \\
    $|$ &  {\em function-type-name} \\
        &  \TT{~~~~~}{\em function-constant-name} \TT{:}
    	   \TT{*DEFERRED*} {\em foreign-function-name} \\
    \end{tabular}
\\[0.5ex]
\emkey{function-constant-name} ::= {\em target-variable}
\\[0.5ex]
{\em target-variable} ::= see \pagref{TARGET-VARIABLE}
\\[0.5ex]
{\em foreign-function-name} ::= see \pagref{FOREIGN-FUNCTION-NAME}
\begin{enumerate}
\item
{\em Function-constant-declarations} must be top level; they
\underline{cannot} be inside subblocks.
\item
The first line of a {\em function-constant-declaration}
behaves like an {\em out-of-line-func\-tion-declaration}
first line made by replacing
`{\em function-type-name} {\em function-con\-stant-name}'
by the {\em function-type-prototype} specified by the
{\em function-type-name} and:
\begin{enumerate}
\item adding `{\tt out-of-line}' to the beginning
\item
replacing the {\tt ()} by the {\em function-constant-name}
\end{enumerate}
\item Non-foreign {\tt *DEFERRED*} function constants are not allowed.
\end{enumerate}
\end{indpar}


The {\em function-constant-name} is declared as a run-time {\tt co}
variable whose
value has the type named by the {\em function-type-name}.
Internally, this value is a run-time pointer to the out-of-line function.
In the \TT{*DEFERRED*} case this value is a pointer to the named
foreign function.

Functions accessed by function type pointers must be called by:
\begin{indpar}
\emkey{call-expression}\label{CALL-EXPRESSION} ::= \\
\hspace*{0.25in}
	\ttkey{call}~ {\em function-expression}~
	     {\em parenthesized-call-argument-list}\QMARK{}
\\[0.5ex]
\emkey{function-expression} ::= {\em reference-expression}
\\[0.5ex]
{\em reference-expression} ::= see \pagref{REFERENCE-EXPRESSION}
\\[0.5ex]
{\em parenthesized-call-argument-list} ::=
    see \pagref{PARENTHESIZED-CALL-ARGUMENT-LIST}
\begin{enumerate}
\item
The {\em function-expression} must evaluate to 
a function-type value.
\end{enumerate}
\end{indpar}



\subsection{Module and Body Declarations}
\label{MODULE-AND-BODY-DECLARATIONS}

A \key{module} is a file whose first statement is a {\em module-declaration}:

\begin{indpar}
\emkey{module-declaration}\label{MODULE-DECLARATION}
    \begin{tabular}[t]{rl}
    ::= & {\em simple-module-declaration} \\
    $|$ & {\em simple-module-declaration}\TT{:} \\
	& \TT{~~~~}{\em import-clause}\STAR{} \\
    \end{tabular} \\
\emkey{simple-module-declaration} ::= \TT{module} {\em module-name}
        \TT{as} {\em module-abbreviation} \\
\emkey{module-name}\label{MODULE-NAME} ::= {\em quoted-string} \\
{\em module-abbreviation} ::= see \pagref{MODULE-ABBREVIATION} \\
\emkey{import-clause}\label{IMPORT-CLAUSE}
    ::= \ttkey{import} {\em module-name} \TT{as} {\em module-abbreviation}

\begin{enumerate}

\item
A {\em module-declaration} may only appear as the first statement
of a module file.

\item
In a {\em module-declaration} all {\em module-abbreviations} must be
distinct, and all {\em module-names} must be distinct.
\end{enumerate}
\end{indpar}

The compiler maps {\em module-names} to POSIX file names in an
implementation dependent manner.  The file that contains the
module cannot contain anything else.

The {\em module-abbreviation} associated with a {\em module-name}
may differ in different files.  Specifically, the {\em module-abbreviation}
for a module used in the module's own module file need not be the same
as the {\em module-abbreviations} used for the module in files
that import the module.

The module \TT{"standard"}\index{standard@\TT{"standard"}} with
module abbreviation \ttkey{std} is builtin and contains the builtin types and
functions.  The {\em import-clause}
\begin{center}
{\tt import }\TT{"standard"}{\tt{} as \ttkey{std}}
\end{center}
is implied in every {\em module-declaration} and
{\em body-declaration}.

A \key{body} is a file whose first statement is a {\em body-declaration}:

\begin{indpar}
\emkey{body-declaration}\label{BODY-DECLARATION} ::=
    \begin{tabular}[t]{l}
    \TT{body }{\em body-name}\TT{ of }{\em module-name}\TT{:} \\
    \TT{~~~~}{\em body-clause}\STAR{} \\
    \end{tabular}
\\[0.5ex]
\emkey{body-name} ::= {\em quoted-string}
\\[0.5ex]
{\em module-name} ::= see \pagref{MODULE-NAME}
\\[0.5ex]
\emkey{body-clause} ::= {\em import-clause} $|$ {\em after-clause}
\\[0.5ex]
{\em import-clause} ::= see \pagref{IMPORT-CLAUSE}
\\[0.5ex]
\emkey{after-clause} ::= \ttkey{initialize after }{\em body-name}

\begin{enumerate}

\item
A {\em body-declaration} may only appear as the first statement
of a body file.

\item
In a {\em body-declaration} the {\em module-abbreviations} of imported
modules must be distinct and must be different from the
{\em module-abbreviation} used by the body's module,
and all {\em module-names} and {\em body-names} must be distinct.
\end{enumerate}

\end{indpar}

The compiler maps {\em body-names} to POSIX file names in an
implementation dependent manner.  The file that contains the
body cannot contain anything else.

A \key{body} is an extension of the module named in the first
line of the {\em body-declaration}.

A body implicitly imports the module it extends.  Within the
body that module has the same {\em module-abbreviation} that it
had in the module's own file.  The other modules imported in the
module's own file are \underline{not} implicitly imported
to the body.  The body must import whatever other modules it uses
explicitly.

The {\em after-clauses} name other bodies, not necessarily in
the same module,
and determine the order in which bodies are initialized:
see \itemref{PROGRAM-INITIALIZATION}.

\subsubsection{Program Initialization}
\label{PROGRAM-INITIALIZATION}

A module is initialized by executing its top level {\em statements}
in the order in which they appear in the module.  Similarly
a body is initialized by executing its top level {\em statements}
in the order in which they appear in the body.

The order in which modules and bodies are initialized is determined
by the following rules.
\begin{enumerate}
\item If a module or body imports another module, the imported module
is initialized before the importing module or body.
\item A module is initialized before any of its bodies.
\item If a body contains an {\em after-clause}, the body
is initialized after the body named in the {\em after-clause}.
\end{enumerate}

The conceptual directed graph whose nodes are modules and bodies
and whose arrows connect each module or body to the modules and
bodies it must be initialized after is called
the `\key{initialization graph}'\label{INITIALIZATION-GRAPH}
and \underline{must be acyclic}.

\section{Parser Output}
\label{PARSER-OUTPUT}

The output produced by the parser when it parses code is as
follows.  In the following \ttkey{*LOGICAL-LINE*} and
\ttkey{*INDENTED-PARAGRAPH*} name special constants.

Recall that the input is a sequence of logical lines.  Also,
{\em rational-constants}\pagnote{RATIONAL-CONSTANTS}
are not produced by the parser: they are parsed as an operator
name {\em word} followed by a {\em quoted-string}.

For a logical line, the parser produces a list with the
annotations: \\
\hspace*{0.5in}{\tt ".initiator" => *LOGICAL-LINE*, ".terminator" => "<LF>"} \\
The list elements are strings and numbers representing lexemes, and
lists representing subexpressions.

Recall that an indented paragraph may appear at the end of a logical line.

For an indented paragraph the parser produces a list
which has the annotations: \\
\hspace*{0.5in}{\tt ".initiator" => ":",
                    ".terminator" => *INDENTED-PARAGRAPH*} \\
The list elements are logical lines.

For an explicitly bracketed subexpression the parser produces a list which has
the annotations: \\
\hspace*{0.5in}{\tt ".initiator" => "(", ".terminator" => ")"} \\
or \\
\hspace*{0.5in}{\tt ".initiator" => "[", ".terminator" => "]"} \\
The list elements are strings and numbers representing lexemes, and
lists representing subexpressions.

For an implicitly bracketed subexpression the parser produces a list which has
\underline{no} {\tt .initiator} and {\tt .terminator} annotations.
The list elements are strings and numbers representing lexemes, and
lists representing subexpressions.

The parser does \underline{not} introduce implied brackets where there
are explict or implied brackets, but will introduce implied brackets
surrouding quoted strings.  For example,
\begin{indpar}
{\tt x + y} parses as {\tt \{ \{ "x" \}, "+", \{ "y" \} \}} \\
{\tt ( x ) + y} \begin{tabular}[t]{@{}l@{}}
		parses as \\
                \tt \{ \{ "x", ".initiator" => "(", ".terminator" => ")" \}, \\
		\tt ~~"+", \{ "y" \} \} \\
                \end{tabular} \\
{\tt ( x, "y" )} \begin{tabular}[t]{@{}l@{}}
		parses as \\
                \tt \{ \{ "x" \}, \{ \{ "y", ".type" => "<Q>" \} \}, \\
		\tt ~~".initiator" => "(", ".terminator" => ")", \\
		\tt ~~".separator" => "," \} \\
                \end{tabular}
\end{indpar}

Operators that are separators, such as `\TT{,}', are not included as elements
of a list, but become a \ttkey{.separator} annotation of the list.  Thus,
\begin{indpar}
{\tt ( x, y )} parses as \begin{tabular}[t]{@{}l@{}}
                \tt \{ "x", "y", \\
		\tt ~~".separator" => ",", \\
		\tt ~~".initiator" => "(", \\
		\tt ~~".terminator" => ")" \} \\
                \end{tabular}
\end{indpar}

Quoted strings become a list with the string as a single element
and a {\tt .type} annotation equal to {\tt "<Q>"}
(recall that {\tt <Q>} in a quoted string represents the double quote {\tt "}).
Thus the lexeme {\tt "Hello"} becomes: \\
\centerline{\tt \{ "Hello", ".type" => "<Q>" \} }

Operator operands become lists in parser output;
for example, the statement `{\tt X = Y}' outputs
`{\tt \{ \{ "X" \}, "=", \{ "Y" \} \}}'.

An example is given in Figure~\ref{PARSER-OUTPUT-EXAMPLE}%
\pagnote{PARSER-OUTPUT-EXAMPLE}.

\begin{boxedfigure}[!p]
\begin{indpar}[1em]


Parser Input:
\begin{indpar}[1em]\begin{verbatim}
if X < Y:
    X = Y
    Y = Y + 5 * Z
    A 1, B = B, A 1
    const P = "HOHO"
    const Q = 5 + P
    const R = ( 5 + Q )
\end{verbatim}\end{indpar}

\medskip

Parser Output:
\begin{indpar}[1em]\begin{verbatim}
{ "if",
  { { "X" }, "<", { "Y" } },
  { { { "X" }, "=", { "Y" },
      ".initiator" => *LOGICAL-LINE*, ".terminator" => "<LF>" },
    { { "Y" }, "=",
      { { "Y" }, "+", { { 5 }, "*", { "Z" } } },
      ".initiator" => *LOGICAL-LINE*, ".terminator" => "<LF>" },
    { { { "A", 1 }, { "B" }, ".separator" => "," },
      "=",
      { { "B" }, { "A", 1 }, ".separator" => "," },
      ".initiator" => *LOGICAL-LINE*, ".terminator" => "<LF>" },
    { { "const", "P" }, "=", { { "HOHO", ".type" => "<Q>" } },
      ".initiator" => *LOGICAL-LINE*, ".terminator" => "<LF>" },
    { { "const", "Q" }, "=",
      { { 5 }, "+", { "P" } },
      ".initiator" => *LOGICAL-LINE*, ".terminator" => "<LF>" },
    { { "const", "R" }, "="
      { { 5 }, "+", { "Q" },
        ".initiator" => "(", ".terminator" => ")" },
      ".initiator" => *LOGICAL-LINE*, ".terminator" => "<LF>" },
    ".initiator" => ":", ".terminator" => *INDENTED-PARAGRAPH*
  },
  ".initiator" => "*LOGICAL-LINE*", ".terminator" => "<LF>"
}

\end{verbatim}\end{indpar}
\end{indpar}

\caption{Parser Output Example}
\label{PARSER-OUTPUT-EXAMPLE}
\end{boxedfigure}

\section{Scope}
\label{SCOPE}

A {\em declaration} has a \key{scope},
that is the set of statements in which any
names or prototypes defined by the {\em declaration}
are recognized.

Generally the scope of a {\em declaration} includes the {\em statements}
in any {\em block} at the end of the {\em statement}
containing the {\em declaration} (recall that a {\em statement} is a
logical line that can end in a {\em block}), and
all {\em statements} following the {\em statement} containing
the {\em declaration} up to the end of the smallest {\em block}
containing the {\em declaration}.

The \key{context}\label{CONTEXT} of a statement is the set of declarations
whose scope the statement is in.

A \key{top-level} {\em declaration} is a {\em declaration} that is
\underline{not} in a {\em statement} inside any {\em block}.
The scope of a top-level {\em declaration} lasts to the end of the
file containing the {\em declaration}.
The scope of a top-level {\em declaration} in a module file is extended
to include each body file of the module.

Some {\em declarations} are \key{external}\label{EXTERNAL}.
These must be top-level declarations in a module (and \underline{not}
in a body).
The scope of an external
{\em declaration} is extended to include all modules and bodies that
import the module containing the {\em declaration}.

A {\em result-variable-declaration} or
{\em block-variable-declaration}
is external if the {variable-name} declared begins with a
{\em module-abbreviation}.

A {\em reference-function-declaration} containing a
{\em function-variable-name}
is external if the {func\-tion-variable-name} begins with a
{\em module-abbreviation}.

A {\em next-variable-declaration}
is external if the {variable-name} declared begins with a
{\em module-abbreviation}.  However, the {\em next-variable-declaration}
must be in the same module file as the {\em result-variable-declaration}
whose variable name it shares.

A {\em type-declaration}, {\em pointer-type-declaration}, or
{\em function-type-declaration}
\label{EXTERNAL-TYPE-NAME}
is external if the {\em type-name}, {\em pointer-type-name},
or {\em function-type-name}
declared begins with a
{\em module-abbrev\-i\-a\-tion}.

A {\em function-declaration}
or {\em out-of-line-function-declar\-a\-tion}
is external\label{EXTERNAL-FUNCTION}
if the {\em prototype-pattern} in the {\em declaration}
is immediately preceded by a {\em module-abbreviation}.

A {\em reference-function-declaration} containing a
{\em prototype-reference-base}
is external if the target type of the {prototype-reference-base} is
external.

{\em Prototype-result-declaration} and {\em prototype-argument-declaration}
{\em variable-names} cannot begin with a {\em module-abbreviation},
and therefore these {\em declarations} can never be external.

In general, a deferred declaration
in a module may have a companion in that module
or in a body of that module, but not in modules or bodies that import
the declaration's module.
As one exception, a deferred external {\em out-of-line-function-declaration}
may have its companion
anywhere within the scope of the original declaration.
As a second exception, a deferred {\em type-declaration} must have its
companion in the same file as the deferred {\em type-declaration}.
Note that a deferred {\em type-declaration} may have only one
companion, but the companion may have many expansions in the
scope of the companion (the companion is the root of its expansion tree:
see \itemref{DEFINED-TYPE-EXPANSIONS}).

{\em Type-declarations} that end with the {\tt *EXTERNAL*}
sub-declaration must have external {\em type-names}
(beginning with a {\em module-abbreviation}).
Expansions of such a {\em type-declaration} may appear
anywhere within scope of the initial root {\em type-declaration}\pagnote{ROOT},
but must have a {\em type-name} that references the same module
as the {\em type-declaration} they are expanding (they need not use the same
{\em module-abbreviation} to do so).

If two {\em type-declarations} declaring the same {\em defined-type-name}
have overlapping scope, they must follow the expansion tree rules
of \itemref{DEFINED-TYPE-EXPANSIONS}.
The scope of a {\tt *LABEL*} {\em type-subdeclaration}
consists of the {\em type-subdeclarations} following it in its
{\em type-declaration} and of the entirety of all
{\em type-declarations} that are descendents
of its {\em type-declaration} in the {\em defined-type-name}'s
expansion tree.

A {\em module-abbreviation} that makes a {\em declaration} external
must abbreviate the module in which the {\em declaration} occurs,
with the exception of expansions of {\em type-declar\-ations}
that end with the {\tt *EXTERNAL*} sub-declaration\pagnote{*EXTERNAL*}
and companions of deferred
{\em out-of-line-function-declarations}.\pagnote{OUT-OF-LINE-EXTERNAL-COMPANION}

If two difference declarations of a {\em variable-name} have overlapping
scope, one of these must necessarily include the other,
and the declaration with the smaller scope is said to 
`\key{hide}'\label{HIDE} the other declaration.

The same applies to {\em type-names}, {\em pointer-type-names},
{\em function-type-names}, {\em function-variable-names}, and
{\em function-constant-names}, except that hiding does not
apply to {\em type-declarations} that expand previous
{\em type-declarations}.

All these names have the property that a name with a {\em module-abbreviation}
is \underline{not} the same name as that name with the {\em module-abbreviation}
dropped.  E.g., `{\tt mom X}' is not the same name as `{\tt X}' if
{\tt mom} is a {\em module-abbreviation}.

The hiding rules do \underline{not}
apply to {\em out-of-line-function-names} or {\em function-term-names}.
{\em Module-abbreviations} may be omitted from {\em function-calls}
without changing the function called, as long as there is no
ambiguity (see Step~\ref{CALL-DECLARATION-MODULE-ABBREVIATION}
of the Call-Declaration Matching Algorithm,
\pagref{CALL-DECLARATION-MODULE-ABBREVIATION}).

A {\em next-variable-declaration} is allowed
within the scope of a previous declaration of its {\em variable-name},
including {\em next-variable-declaration} of the same {\em variable-name},
if it is not within a smaller block than the previous declaration.
Note that a {\em next-variable-declaration} has
the same syntax as a particular kind of {\em reference-expression}, and its use
as an implicitly {\tt *INIT*}\pagnote{INIT-FORCING} {\em reference-expression}
is allowed within a subblock of the {\em block-assignment-state\-ment}
or {\em loop-assignment-statement} that assigns a value to the
declared {\tt next} variable.
Also note that {\em next-variable-declarations} can be implied
in {\em block-assignment-statements}\pagnote{BLOCK-NEXT-PROMOTION}
and {\em loop-assignment-statements}\pagnote{LOOP-NEXT-PROMOTION}.

Function prototypes \underline{cannot} hide each other.  If the
current context contains two function declarations whose prototypes
both match a call, the call is ambiguous and in error,
even if the scope of one declaration is within
the scope of the other.

{\em Statement-labels} ({\em block-labels},
{\em exit-labels}, and {\em loop-labels}), have as their scope
the block in which they are defined.  It is a compile
error if {\em statement-labels} hide each other.

When a {\em function-call} to an inline function is expanded,
the context of the expansion is \underline{not} the current context but
rather the context of the inline {\em function-declaration}
that provided the {\em statements} executed by the call.
Also the context in which any {\em default-value} expression
provided by a {\em function-declaration} is compiled\label{DEFAULT-CONTEXT}
is the \underline{not} the current context but
rather the context of that {\em function-declaration}.

Similarly when a {\em reference-call} to a reference function is expanded,
the context of the expansion is \underline{not} the current context but
rather the context of the inline {\em reference-function-declaration}
that provided the {\em statements} executed by the call.

Code produced by inclusions during {\em statement} compilation
is compiled in the context of the {\em statement} replaced by the
code.  See Inclusions (\pagref{INCLUSIONS}).

An example is:
\begin{indpar}\begin{verbatim}
module "my_own_module" as mom:
    // `import "standard" as std' is implied
    import "George's_own_module" as gom
    // gom contains:
    //    function int32 z = gom ( int32 x ) "+" ( int32 y )

int32 mom my constant = 44
int32 my constant = 55

int32 x1 = mom my constant // == 44
int32 x2 = my constant     // == 55

function int32 y = mom my function ( int32 x ): // [A]
    ... function body omitted ...
function int32 y = my function ( int32 x ):     // [B]
    ... function body omitted ...

int32 y1 = mom my function ( 100 )  // Uses [A]
int32 y2 = my function ( 100 )      // Compile error:
                                    // ambiguity between [A] and [B]

function int32 z = my inline function ( int32 x, int32 y ):
    int32 z1 = gom ( x + y )
        // Uses gom's + operator.
        // Compiles as as `gom (x) "+" (y)'.
    int32 z2 = std ( x + y )
        // Uses builtin std's + operator.
        // Compiles as as `std (x) "+" (y)'.
    z  = z1 + z2 
        // Compiles as `z = ( (x) "+" (y) )'.
        // Compile error, ambiguous: both std + operator
        // and gom's + operator match the call to "+".
\end{verbatim}\end{indpar}\label{EXTERNAL-INTERNAL-EXAMPLE}

More specifically,
when a function declaration is used, the {\em module-abbreviation}
beginning the function call may be omitted if the function declaration is
the only function declaration within scope that matches the usage,
according to Step~\ref{CALL-DECLARATION-MODULE-ABBREVIATION}
of the Call-Declaration Matching Algorithm,
\pagref{CALL-DECLARATION-MODULE-ABBREVIATION}.
Thus given:
\begin{indpar}\begin{verbatim}
function int32 y = mom my external function ( int32 x ):
    ... function body omitted ...
\end{verbatim}\end{indpar}
the lines:
\begin{indpar}\begin{verbatim}
int32 y = mom my external function ( x )
int32 y = my external function ( x )
\end{verbatim}\end{indpar}
are equivalent if no {\em function-declarations}
\begin{indpar}\tt
function int32 r = $ma$ my external function ( int32 v ) \\
function int32 r = my external function ( int32 v )
\end{indpar}
are in the current context, where $ma$ is a module abbreviation for a module
other than {\tt "my\_own\_module"}.

\section{Lifetimes}
\label{LIFETIMES}

The \key{lifetime} of a variable, i.e., a piece of memory,
is the time interval from the time that the variable
is allocated to the time that
the variable is deallocated.  The compiler tracks lifetimes by assigning each
variable a lifetime type and for variables in the local stack
a separate lifetime depth.

The possible variable lifetimes are:
\begin{indpar}[0.2in]
\begin{tabular}{lp{5.0in}}
\key{global} &
	The variable is stored in the global stack\pagnote{GLOBAL-STACK}.
	The variable lifetime starts when the variable is created
	and stops when the program terminates.
	\\[1ex]
	&
	Global variables are \underline{external} variables created by 
	a {\em result-variable-declaration} or {\em next-variable-declaration}
	of an {\em assignment-state\-ment}, or by an {\em allocation-call}
	to the {\tt global} allocator function.

\\[1ex]
\key{local} &
	The variable is stored in the local stack\pagnote{LOCAL-STACK}.
	The variable lifetime starts when the variable is created
	and stops when the scope of the declaration creating the
	variable ends.
	\\[1ex]
	&
	Local variables are \underline{non}-external variables created by
	a {\em result-variable-declaration} or
	{\em next-variable-declaration}
	of an {\em assignment-state\-ment},
	or by a {\em prototype-argument-result-declaration} or
	{\em prototype-argument-variable-declaration} during a
	function call,
	or by an {\em allocation-call}
	to the {\tt local} allocator function.
\\[1ex]
\key{heap} &
	The variable is stored in the heap (i.e., garbage collectible memory).
	The variable lifetime starts when the variable is allocated
	to the heap, and stops when the variable can no longer
        be referenced by following a chain of pointer values
        the root of which is a global variable or is a local variable
        with a lifetime that has not yet terminated.
\end{tabular}
\end{indpar}

A pointer value has a pointer type that may have a \key{lifetime qualifier}
which tells something about the lifetimes of the target variables in the
datum the pointer points at.  The possible lifetime qualifiers are:

\begin{indpar}[0.2in]
\begin{tabular}{lp{4.5in}}
\ttkey{*GLOBAL*}	& The target variables are in the global stack.
\\[1ex]
\ttkey{*HEAP*}		& The target variables are either in the heap
			  or they are in the global stack.
\\[1ex]
		        & Note: allowing {\tt *HEAP*} pointers to point
			  into the global stack requires the garbage
			  collector to be able to distinguish global stack
			  and heap addresses and treat them differently.
\\[1ex]
{\bf (undeclared)}	& The pointer type has no lifetime qualifiers.
                          There are two cases:
\\[1ex]
{\bf ~~~~(local)}	& The compiler knows that the target variables are
                          in the local stack, and also knows the lexical
			  depth of the statement that created the variables.
\\[1ex]
{\bf ~~~~(anywhere)}	& The compiler does \underline{not} know whether
			  the target variables are in the global stack,
			  the local stack, or the heap.  However, the
			  compiler does know that the lifetime of the
			  target variables contains the lifetime of the
			  variable holding the pointer value.
\end{tabular}
\end{indpar}

A pointer value whose type has the {\tt *GLOBAL*} lifetime qualifier
is called a \key{global pointer}. 
A pointer value whose type has the {\tt *HEAP*} lifetime qualifier
is called a \key{heap pointer}. 
A pointer value with undeclared pointer type that is known
to point at target variables in the local stack is called a
\key{local pointer}. 
A pointer value with undeclared pointer type that is not known to be
a local pointer is called an \key{anywhere pointer}.

Somewhat similarly for variables.
A \key{pointer variable} is a variable storing a pointer.
A variable whose type is a pointer type with
the {\tt *GLOBAL*} lifetime qualifier
is called a \key{global pointer variable}. 
A variable whose type is a pointer type with
the {\tt *HEAP*} lifetime qualifier
is called a \key{heap pointer variable}. 
A variable whose type is a pointer type with
undeclared lifetime qualifier
is called an \key{undeclared pointer variable}. 

We also divide variables into the following three classes:
\begin{indpar}[0.2in]
\begin{tabular}{lp{3.5in}}
\key{target variables} &
	The variable is located in the target datum of a pointer.
\\[1ex]
\key{local non-target variables} &
	The variable is stored in the local stack
	and is \underline{not} a target variable.
\\[1ex]
\key{global non-target variables} &
	The variable is stored in the global stack
	and is \underline{not} a target variable.
\end{tabular}
\end{indpar}

The {\tt null} allocator function\pagnote{NULL} is special in that
it can set a pointer of any lifetime type to a particular address
that addresses a block of virtual memory that is inaccessible, and
causes a memory fault when accessed.  A pointer allocated by {\tt null}
is always a global, heap, or local pointer, depending on whether
the pointer's type has a {\tt *GLOBAL*} or {\tt *HEAP*} qualifier
or is undeclared, and is never an anywhere pointer.
The lifetime assigned to target variables of a pointer allocated by {\tt null}
is a convenient fiction, since such variables can never be referenced.

The following rules prevent a pointer to a target with a given lifetime
from being stored in a variable with a longer lifetime.
The first of these rules govern global and heap pointers and
pointer variables and are:
\begin{indpar}[0.2in]
\begin{tabular}{p{0.5in}p{5.0in}}
\key{(L1)}	& A global pointer value
                  can be stored in any global pointer variable.
\end{tabular}

\begin{tabular}{p{0.5in}p{5.0in}}
\key{(L2)}	& A heap pointer value
                  can be stored in any heap pointer variable.
\end{tabular}

\begin{tabular}{p{0.5in}p{5.0in}}
\key{(L3)}
		& A global pointer value
                  can be stored in any heap pointer variable.
\\[1ex]
		& Note: This requires the garbage collector to be able
		  to distinguish global stack
		  and heap addresses and treat them differently.
\end{tabular}

\begin{tabular}{p{0.5in}p{5.0in}}
\key{(L4)}	& A value read from a global pointer variable is a
		  global pointer.
\end{tabular}

\begin{tabular}{p{0.5in}p{5.0in}}
\key{(L5)}	& A value read from a heap pointer variable is a
		  heap pointer (has pointer type with {\tt *HEAP*}
		  qualifier), even if in fact it points at the
		  global stack.
\end{tabular}

\begin{tabular}{p{0.5in}p{5.0in}}
\key{(L6)}	& Undeclared pointer variables that are in the target
                  of a global pointer are global pointer variables.
\\[1ex]
		& Undeclared pointer variables that are in the target
                  of a heap pointer are heap pointer variables.
\\[1ex]
		& In other words, a lifetime qualifier of a pointer $P$
		  is added to the type of any undeclared pointer variables
		  in the target of $P$.
\end{tabular}


\end{indpar}

An example is:
\begin{indpar}\begin{verbatim}
type list element:
    ap list element @successor
        // When in the global stack, @successor has *GLOBAL*
        // lifetime qualifer implied by (L6).

// In the following, `@= global' is implied because the pointers
// are *GLOBAL*.

ap *GLOBAL* list element @list empty @= null
    // $list empty is now a global pointer

// Circular list:
//
ap *GLOBAL* list element @last:  // `@= global' is implied
    last.@successor = @list empty
    // Last element is pointed at by last.@successor
    // First element is pointed at by last.successor.@successor
    // Empty list has last.@successor == @list empty

// Put two elements in list.
//
ap *GLOBAL* list element @X  // `@= global = *DEFERRED*' is implied
ap *GLOBAL* list element @Y  // `@= global = *DEFERRED*' is implied

ap *GLOBAL* list element @X:
    // Put X on empty list
    X.@successor = @X
    last.@successor = @X
    // List now consists of (X)
ap *GLOBAL* list element @Y:
    // Add Y to end of list
    Y.@successor = last.successor.@successor 
    last.successor.@successor = @Y
    last.@successor = @Y
    // List now consists of (X, Y)
\end{verbatim}\end{indpar}

A local pointer is tagged automatically by the compiler with the
lexical depth of the {\em statement} that created the pointer.  Top level
{\em statements} have lexical depth 1.  {\em Statements} in a subblock
of a top level {\em statement} have lexical depth 2, and so forth.
Details, including how to handle inline function calls, are below.


\begin{indpar}[0.2in]

\begin{tabular}{p{0.5in}p{5.0in}}
\key{(L7)}	& A pointer into the local stack
		  created by an {\em allocation-call}
		  in an {\em assignment-statement} of depth $D$
		  is a local pointer of depth $D$.
\end{tabular}

\begin{tabular}{p{0.5in}p{5.0in}}
\key{(L8)}	& A local pointer of depth $D$ may be stored in
		  an undeclared local non-target pointer variable
		  that is \underline{not} an {\tt out-of-line}
		  function argument variable (it may be an inline
		  function argument variable).  The compiler
		  then annotes the pointer variable as holding a local
		  pointer of depth $D$.
\end{tabular}

\begin{tabular}{p{0.5in}p{5.0in}}
\key{(L9)}	& A pointer value read from an
		  an undeclared non-target pointer variable
		  that is annotated as holding a local pointer of depth $D$
		  is a local pointer of depth $D$.
\end{tabular}

\begin{tabular}{p{0.5in}p{5.0in}}
\key{(L10)}	& A local pointer of depth $D$ may be stored in
		  an undeclared target pointer variable
		  that is in the target of a
		  local pointer of depth $D$.
\end{tabular}

\begin{tabular}{p{0.5in}p{5.0in}}
\key{(L11)}	& A pointer value read from an
		  an undeclared target pointer variable
		  in the target of a local pointer of depth $D$
		  is a local pointer of depth $D$.
\end{tabular}

\end{indpar}

Note that local pointers cannot be stored in global non-target variables
or in pointer variables in the target of a global or heap pointer.
If a local non-target variable holds a local pointer $P$ of depth $D$,
all the undeclared target pointer variables reachable by tracing
undeclared target pointer variable values starting at $P$ necessarily hold
local pointers of depth $D$.  So in a network of
data completely connected by local pointers, all these local pointers
have the same depth.

An example is:
\begin{indpar}\begin{verbatim}
type list element:
    ap list element @successor

ap list element @list empty @= null
    // Depth 1 null value.

// In the following, `@= local' is implied because the pointers
// are (lifetime) undeclared.

// Circular list:
//
ap list element @last:  // `@= local' is implied
    last.@successor = @list empty
    // Last element is pointed at by last.@successor
    // First element is pointed at by last.successor.@successor
    // Empty list has last.@successor == @list empty

// Put two elements in list.
//
ap list element @X  // `@= local = *DEFERRED*' is implied
ap list element @Y  // `@= local = *DEFERRED*' is implied

// Note: @last, @X, @Y, last.@successor, X.@successor, etc.
// all have depth 1

ap list element @X:
    // Put X on empty list
    X.@successor = @X
    last.@successor = @X
    // List now consists of (X)
ap list element @Y:
    // Add Y to end of list
    Y.@successor = last.successor.@successor 
    last.successor.@successor = @Y
    last.@successor = @Y
    // List now consists of (X, Y)
\end{verbatim}\end{indpar}

The last kind of pointer is the \key{anywhere pointer}.
{\em Out-of-line} argument undeclared pointer variables
must be anywhere pointers.  The rules are:

\begin{indpar}[0.2in]

\begin{tabular}{p{0.5in}p{5.0in}}
\key{(L12)}	& If a global or heap pointer is stored in an
                  undeclared local non-target pointer variable
		  (specifically including {\em out-of-line}
		  argument undeclared pointer variables),
		  the value stored becomes an anywhere pointer,
		  and the compiler
		  annotes the pointer variable as holding
		  an anywhere pointer.
\end{tabular}

\begin{tabular}{p{0.5in}p{5.0in}}
\key{(L13)}	& If an anywhere pointer is stored in an
                  undeclared local non-target pointer variable
		  (specifically including {\em out-of-line}
		  argument undeclared pointer variables),
		  the value stored becomes an anywhere pointer,
		  and the compiler
		  annotes the pointer variable as holding
		  an anywhere pointer.
\end{tabular}

\begin{tabular}{p{0.5in}p{5.0in}}
\key{(L14)}	& A pointer value read from an
		  an undeclared non-target target pointer variable
		  that is annotated as holding an anywhere pointer
		  is an anywhere pointer.
\end{tabular}

\begin{tabular}{p{0.5in}p{5.0in}}
\key{(L15)}	& A pointer value read from an
		  an undeclared target pointer variable
		  in the target of an anywhere pointer
		  is an anywhere pointer.
\\[1ex]
		& Note that because of (L6) the pointer value may actually
		  point at the global stack or the heap.
\\[1ex]
		& Note that because of (L11) the pointer value may actually
		  point at the local stack.
\end{tabular}

\end{indpar}

Note that an anywhere pointer can only be stored in local non-target
variables, and any undeclared target pointer variable value
that is reachable from
an anywhere pointer becomes an anywhere pointer when it is read.

The rules for assigning depth to {\em statements} are as follows:
\begin{indpar}[0.2in]
\begin{tabular}{p{0.4in}p{5.0in}}
\key{(S1)}	& A {\em statement} that is not inside any other statement
                  (i.e., is not in a sub-block; i.e., is top-level)
		  is assigned depth 1.
\end{tabular}

\begin{tabular}{p{0.4in}p{5.0in}}
\key{(S2)}	& A {\em statement} that is inside a sub-block $S$ at the end
                  of an {\em assignment-statement} of depth $D$, and
		  is not also
		  inside a sub-block of $S$, is assigned depth $D+1$.
\end{tabular}

\begin{tabular}{p{0.4in}p{5.0in}}
\key{(S3)}	& An \underline{inline} {\em function-call} is treated
                  as creating a sub-block immediately inside
		  the {\em statement} containing the {\em function-call}.
		  The argument and result variables created by the inline
		  {\em function-prototype} are treated as having been
		  created by this {\em statement}.
\\[1ex]
		& Thus if an inline function is called from a {\em statement}
		  of depth $D$, the {\em statements} in the sub-block $S$ at the
		  end of the inline function declaration that are not inside
		  a sub-block of $S$ will have depth $D+1$ and the
		  argument and result variables of the inline function
		  declaration will have depth $D$.
\\[1ex]
		& Note: If an inline function is called from a {\em statement}
		  of depth $D$, the depth $D'$ of the function's declaration
		  must such that $D'\leq D$, since the calling {\em statement}
		  must be in the scope of the declaration.
\end{tabular}
\end{indpar}

Note that because of (S1) and (S2) and the fact that an
\underline{\tt out-of-line} function declaration must be top level,
the sub-block $S$ at the end of an {\tt out-of-line}
declaration is assigned depth 2.

The last example modified to use inline functions is:
\begin{indpar}\begin{verbatim}
type list element:
    ap *READ-WRITE* list element @successor
        // List elements must be *READ-WRITE*

ap *READ-WRITE* list element @list empty @= null
    // Depth 1 null value.

// In the following, `@= local' is implied because the pointers
// are (lifetime) undeclared.

// Circular list:
//
ap *READ-WRITE* list element @last:  // `@= local' is implied
    last.@successor = @list empty
    // Last element is pointed at by last.@successor
    // First element is pointed at by last.successor.@successor
    // Empty list has last.@successor == @list empty

// Put two elements in list.
//
ap *READ-WRITE* list element @X  // `@= local = *DEFERRED*' is implied
ap *READ-WRITE* list element @Y  // `@= local = *DEFERRED*' is implied

// Note: @last, @X, @Y, last.@successor, X.@successor, etc.
// all have depth 1

// Add element to end of circular list:
//
function add ( ap *READ-WRITE* list element @element ):
    // element depth is taken from actual argument
    if last.@successor == @list empty:
        element.@successor = @element
    else:
        element.@successor = last.successor.@successor
        last.successor.@successor = @element
    last.@successor = @element

// Put elements in list.
//
add ( @X )           // X is first element
add ( @Y )           // Y is second element
\end{verbatim}\end{indpar}

A {\em reference-expression} with \underline{no} {\em reference-calls}
that computes a pointer assigns to that
pointer the lifetime qualifiers given for the root of the
{\em reference-expression}.  E.g., a pointer to a member of the
target of a global pointer is a global pointer.  When the
{\em reference-expression} does \underline{not} contain a
{\em reference-call}, this makes sense because a member of the
target of a global pointer is contained by the target of the global
pointer.

A {\tt point reference function} assigns lifetime qualifiers according
to instructions in its {\em reference-function-prototype}.  By using
wildcards the prototype may copy root lifetime qualifiers to the
result or change these qualifiers.

The garbage collector must be able to find all heap pointer variables
in the local and global stacks.  Since anywhere pointer variables in
the local stack may also point at heap data, the garbage collector
must also be able to find them.


\section{Memory Management}
\label{MEMORY-MANAGEMENT}

Space for variables allocated by {\em variable-declarations}
is allocated to the currently executing out-of-line function
frame or to the stack after this frame: see
\pagref{VARIABLE-ALLOCATION} and \pagref{LOOP-ALLOCATION}
for details.

Pointers to the heap (\skey{heap pointer}s) normally use the stub-body concept:
the heap pointer points not at the body of a heap datum, but instead at a
stub which begins with a body pointer at the body.  This can be
used in a variety of garbage collection schemes.  All these
schemes require that some special action be taken when a heap
pointer is read into a stack variable, or when
a heap pointer is written into a heap datum, or when any location
in the stack or heap that stores a heap pointer has its value
changed.

However instead of using stub-body, heap pointers can optionally be
interpreted as pointing directly at the heap datum.

Specifically, the compiler recognizes the following options:

\begin{indpar}

\ttkey{copying-gc}, \ttkey{marking-gc}, \ttkey{counting-gc}, or \ttkey{no-gc}
\begin{indpar}
These options specify garbage collection (\key{GC})
algorithm being used.
With {\tt no-gc}, there is no heap and no garbage collection.
The garbage collection algorithms are described below.
\end{indpar}

\ttkey{separate-stub} or \ttkey{integrated-stub}
\begin{indpar}
Heap pointers always point at a stub.
With the {\tt separate-stub} option, heap pointers point at a stub that is
separate from the heap datum body, and the first word of the stub points at the
body.  With the {\tt integrated-stub} option,
the body is immediately after the
stub, though the stub may begin with a forwarding pointer
that points at the true location of both the stub and the body
(this is done in {\tt copying-gc}).
\end{indpar}

\ttkey{read-gc} or \ttkey{write-gc}
\begin{indpar}
These are sub-options of GC, indicating whether the GC is
read-oriented or write-oriented.  See the descriptions
of GC below.
\end{indpar}

\ttkey{deallocation-allowed} or \ttkey{deallocation-forbidden}
\begin{indpar}
These are sub-options of GC, indicating whether a datum body can be
deallocated without the datum being garbage collected.  With the
{\tt separate-stub} option, the pointer to the body merely points
at inaccessible memory.  With the {\tt integrated-stub} option, the
{\tt copying-gc} option allows the datum to consist of just a forwarding
pointer pointing at inaccessible memory, but other {\tt \ldots-gc}
options do not support deallocation without the datum being garbage collected.
\end{indpar}

\end{indpar}

All kinds of GC run interleaved with non-GC execution.
These compiler options control default inline functions that do the
following during non-GC execution:
\begin{itemize}
\item Read a non-pointer from a heap datum.
\item Read a pointer from a heap datum.
\item Write a pointer to a heap datum.
\item Write a non-pointer to a heap datum.
\item Write a pointer to a non-loop iteration stack variable.
\item Write a pointer to a loop iteration stack variable.
\item Deallocate a location that contains a pointer.
\end{itemize}

The three kinds of GC are discussed in detail in the following sub-sections.


\subsection{Copying Garbage Collection}
\label{COPYING-GARBAGE-COLLECTION}

In copying garbage collection the stub of a datum is the datum's
first word.  When the datum is first allocated, this
stub points at itself.  Then during GC the body will be
copied and for a time have two stubs, the stub in the old
body that was the source of the copy, and the stub of the
new body that was the destination of the copy.  Both will
point at the new body, and the new body will hold the
datum itself, while the old body will no longer be accessed
except for its stub.

GC works in cycles.  At the start of each cycle, all heap
data are in a contiguous virtual memory space called the
old space.  A new large contiguous virtual memory space
is allocated called the new space.  The boundary address
between these can be use to tell if a body is in old space
or new space: just compare the body pointer with the boundary
address.  The object of the GC cycle is to copy all active
data from old space to new space, update all active heap pointers
to point at new space stubs, and then discard old space
completely.

GC performs a basic operation on heap pointers which
we will call \key{pointer-update}.  In this a heap pointer is
checked to see if it points at new space, and if not,
is replaced by a pointer that points at new space.
If the heap pointer points at a body pointer in old space
that itself points at old space, the body pointed at is
moved to new space, and the heap pointer is replaced by
a pointer to the body in new space.  If the heap pointer
points at a body pointer in old space that points at new space, the
heap pointer is simply replaced by that body pointer.

When a new body is created, it is allocated to new space.
Places for new or copied bodies in new space are
allocated at the `end' of new space.

GC goes through new space from beginning to end updating
all the pointers in bodies it encounters.  This is called
`scavenging'.  At any time there is an address that is the
boundary between the scavenged bodies at the beginning
of new space and the non-scavenged bodies at the end of
new space.  This address can be use to tell if a new space
body has been scavenged.

The root pointers of GC are in the global memory (memory
allocated at load time) and the stack.

The GC can be either read-oriented or write-oriented.

A read-oriented GC updates heap pointers when they are read
from bodies by non-GC execution.
The GC begins by updating all heap pointers in global memory
and the stack, and from this point on, all pointers in global
memory and the stack
point to new space and no special action is required when
a pointer is written to a body (which itself will be in new
space) by non-GC execution.

A write-oriented GC updates heap pointers when they are
written into scavenged bodies by non-GC execution. 
After \underline{all} objects in new space have been scavenged,
the GC updates all pointers in global memory and the stack,
and if this does \underline{not}
move any bodies to new space, GC is done; otherwise
GC resumes scavenging.  Heap pointers in global memory and the stack need
not be updated during non-GC execution, and no special action is taken
when reading a heap pointer from a body.

The advantage of write-oriented over read-oriented is
that write operations are less frequent than read
operations and therefore write-oriented may be more
efficient.  The disadvantage is that in order to finish, the GC
must update all pointers in the local stack while
non-GC execution is changing the local stack.
This could be done by having GC update pointers from the bottom
to the top of the local stack, and terminate GC if the non-GC execution
pops the local stack so it no longer includes non-updated pointers.

It is possible to implement a deallocate operation
which deallocates a body, except for its body pointer.
A deallocated body has a body pointer pointing at
a large area of inaccessible virtual memory, so a
memory fault will occur if the body is accessed.
To copy a deallocated body one just makes a copy
of just the body pointer without changing this body pointer,
which is left pointing at inaccessible memory.
The update operation must do extra work to detect
deallocated bodies if they are permitted.

The {\tt no-stub} option may \underline{not} be used with
copying GC.

\subsection{Marking Garbage Collection}

In marking GC, stubs are allocated to a separate space
from bodies, and bodies are not copied during GC.
Bodies are copied by a separate activity called
compaction that is independent of GC.  The advantages
are that there is less body copying and also that less memory
space is required.  Also deallocated bodies do not
require the update operation to do extra work.

The simplest marking GC uses stubs that begin with
a body pointer followed by two list pointers (for doubly linked lists),
a marked flag, and a scavenged flag (the flags can generally
be put in the same words as the list pointers).  There are two lists
of stubs: an old space list and a new space
list.  To move a stub from old space to new space,
it is unlinked from the old space list and linked
onto the end of the new space list, and its marked
flag is set.  When a datum is scavenged, its scavenged
flag is set.

Otherwise marking GC is just like copying GC.

A variant has only one list pointer associated with
the stub and there is just one stub list.  The
marked and scavenged flags are used as before.
At its end, GC goes through the list of all stubs
and frees unmarked stubs along with their bodies.
However, the list of stubs to be scavenged must
be maintained separately, typically as a list of
vectors whose elements point at stubs to be scavenged.
When a stub is first marked it is put on the list
of stubs to be scavenged.

\subsection{Counting Garbage Collection}

In counting GC each stub has a reference
count.  The fundamental non-GC operation is storing
a pointer P in a location.  The required steps are:
\begin{center}
\begin{tabular}{rl}
(1) & save the location's previous value S \\
(2) & add one to the reference count of the stub pointed at by P \\
(3) & subtract one from the reference count of the stub pointed at by S; \\
    & if that reference count is now zero, collect the stub and its body \\
(4) & store P in the location
\end{tabular}
\end{center}

This operation must be used when a pointer location is updated
in the stack or in a body.  There is also an operation for
deallocating a location containing a pointer, which omits steps
(2) and (4).

Bodies may or may not be allocated separately from stubs.
If separate (the {\tt stub} option),
deallocated bodies may be implemented and
bodies may be compacted separately from GC.
Or the {\tt no-stub} option \underline{may} be used with
counting GC.

Of course reference counting GC cannot collect data containing
pointer loops, such as circular lists.

\subsection{Locating Global and Local Heap Pointers}

A list of global and local variables that contain heap
pointers needs to be made available to the garbage collector.
As per the Lifetimes section\pagnote{LIFETIMES}, these are
pointers of declared {\tt *HEAP*} type plus anywhere pointers.

From the point of view of the garbage collector, variables
are held in two stacks: the \key{global stack}\label{GLOBAL-STACK} and
the \key{local stack}\label{LOCAL-STACK}.  These
stacks are each a sequence of blocks.  Each block has at its
beginning a \key{block type} ID which references load time data that tells
the length of the block and contains a map specifying which words of the block
contain heap pointers.  Some types of blocks contain a vector
of similar elements, and for these there is a separate count of the number of
vector elements at the beginning of the block and the block type data
only specifies that length of an element and
which words of the element contain heap pointers.

An out-of-line function call\label{OUT-OF-LINE-LOCALS}
begins by allocating a block in the
local stack to hold
its local {\tt co} variables.  All the variables are allocated
at the beginning of the call execution, so this block does not vary
in size or layout during the function call execution.  Executions
of `{\tt @= local}' during the function call will add a block to the
local stack if the allocated memory size cannot be determined at
compile time.  At the end of the out-of-line function call, all
the blocks it allocated to the local stack are deallocated.

In the case of a statement containing `{@= local}' in a
loop iteration, execution of the statement will re-use the block
allocated by the last execution of that statement, unless that block
is too small, in which case a new block of at least twice the size
of the last block will be allocated.  This scheme allocates at most
4 times as much memory as is actually used by the statement during
any of its executions.

When a block is allocated it is zeroed.  This
allows the garbage collector to avoid variables containing
heap pointers that have not yet been set.

The execution of each module and body file initialization is
treated the same as an execution of an out-of-line function
call, except that at load time, before initialization,
a block holding the external variables of each module is
allocated to the global stack\label{GLOBAL-MEMORY}.  This allows addresses of
external variables to be computed at load time.

Statements containing {\tt @= global} can be executed anytime
and allocate blocks to the global stack.

Blocks in the global stack are never deallocated.

\section{Non-Function Operators}

Some operators map onto functions.  For example, \\
\centerline{{\tt x + y} maps onto {\tt x "+" y}}

However the following operators do \underline{not} map onto functions:

\begin{itemlist}[0.2in]
\item[prefix \TT{type}]
\item[prefix \TT{pointer type}] \vspace*{-0.15in}
\item[prefix \TT{function}] \vspace*{-0.15in}
\item[prefix \TT{macro function}] \vspace*{-0.15in}
\item[prefix \TT{constant function}] \vspace*{-0.15in}
\item[prefix \TT{inclusion function}] \vspace*{-0.15in}
\item[prefix \TT{load reference function}] \vspace*{-0.15in}
\item[prefix \TT{store reference function}] \vspace*{-0.15in}
\item[prefix \TT{point reference function}] \vspace*{-0.15in}
\item[prefix \TT{out-of-line function}] \vspace*{-0.15in}
\item[afix infix \TT{is type}] \vspace*{-0.15in}
\item[afix infix \TT{is function}] \vspace*{-0.15in} ~\\
See Declarations\pagnote{DECLARATIONS}.

\item[prefix \TT{call}] ~\\
See Call-Expression\pagnote{CALL-EXPRESSION}

\item[prefix \TT{if}]
\item[prefix \TT{else if}] \vspace*{-0.15in}
\item[initial \TT{else}] \vspace*{-0.15in}
\item[afix right \TT{:}] \vspace*{-0.15in} ~\\
See Conditional Statements\pagnote{CONDITIONAL-STATEMENTS}.

\item[afix subblock]
\item[postfix subblock] \vspace*{-0.15in} ~\\
See Assignment Statements\pagnote{ASSIGNMENT-STATEMENTS}
and Conditional Statements\pagnote{CONDITIONAL-STATEMENTS}.

\item[prefix \TT{loop}]
\item[prefix \TT{while}] \vspace*{-0.15in}
\item[prefix \TT{until}] \vspace*{-0.15in}
\item[prefix \TT{exactly} \ldots{}~\TT{times}] \vspace*{-0.15in}
\item[prefix \TT{at most} \ldots{}~\TT{times}] \vspace*{-0.15in} ~\\
See {\em iteration-control}\pagnote{ITERATION-CONTROL}.

\item[infix \TT{=}] ~\\
See Assignment Statements\pagnote{ASSIGNMENT-STATEMENTS}.

\item[infix \TT{+=}]
\item[infix \TT{-=}] \vspace*{-0.15in}
\item[infix \TT{*=}] \vspace*{-0.15in}
\item[infix \TT{/=}] \vspace*{-0.15in}
\item[infix \TT{|=}] \vspace*{-0.15in}
\item[infix \TT{\&=}] \vspace*{-0.15in}
\item[infix \TT{\textasciicircum=}] \vspace*{-0.15in}
\item[infix \TT{<{}<{}=}] \vspace*{-0.15in}
\item[infix \TT{>{}>{}=}] \vspace*{-0.15in} ~\\
The statement `{\tt x += y}' is syntactic sugar for `{\tt next x = x + y}'
if {\tt x} is a local {\tt co} variable, and for
`{\tt x = x + y}' otherwise.

Similarly for the other operators of the form `\TT{$B$=}'
where $B$ is a binary operator,
the statement `{\tt x $B$= y}' is syntactic sugar for
`{\tt next x = x $B$ y}' or `{\tt x = x $B$ y}'.

\item[infix \TT{@=}] ~\\
See Allocation Call\pagnote{ALLOCATION-CALL}.

\item[infix \TT{-{}-{}-{}>}] ~\\
See Abbreviation Statements\pagnote{ABBREVIATION-STATEMENT}.

\item[nofix \TT{,}] ~\\
Becomes a {\tt .separator} annotation on a list.  See
the operator separator format\pagnote{SEPARATOR-FORMAT}.

\item[infix \TT{if}]
\item[infix afix \TT{else}] \vspace*{-0.15in} ~\\
Must be used in an {\em else-expression} with target
type $T$ which has the syntax:
\begin{indpar}[0.2in]
\emkey{else-expression} ::=
    {\em if-expression}~ \{ \ttkey{else}~ {\em if-expression} \}\STAR{}~
    \ttkey{else}~ {\em T-expression} 
\\[0.5ex]
\emkey{if-expression} ::=
    {\em T-expression}~ \ttkey{if}~ {\em bool-expression}
\\[0.5ex]
{\em bool-expression} ::=
    \begin{tabular}[t]{@{}l@{}}
    {\em expression} with target type {\tt bool}
	if $T$ is \underline{not} {\tt const} \\
    and otherwise target type {\tt const}
    \end{tabular}
\\[0.5ex]
{\em T-expression} ::= {\em expression} with target type $T$
\end{indpar}
The {\em bool-expressions} are evaluated left to right until one
evaluates to {\tt true} or {\tt TRUE}.
Then the corresponding {\em $T$-expression}
(the one in the same {\em if-expression} as the {\em bool-expression})
is evaluated and returned.  If all {\em bool-expressions} evaluate to
{\tt false} or {\tt FALSE}, the {\em $T$-expression} after the last {\tt else}
is evaluated and returned.

\item[infix \TT{BUT NOT}] ~\\
`{\tt x BUT NOT y}' is syntactic sugar for `{\tt x AND ( NOT ( y ) )}'.

\item[infix \TT{AND}] ~\\
`{\tt x AND y}' is syntactic sugar for `{\tt y if x else FALSE}'.

\item[infix \TT{OR}] ~\\
`{\tt x OR y}' is syntactic sugar for `{\tt TRUE if x else y}'.

\item[prefix \TT{NOT}] ~\\
`{\tt NOT x}' is syntactic sugar for `{\tt FALSE if x else TRUE}'.

\end{itemlist}

\section{Builtin Abbreviations}

{\em Module-abbreviations} are automatically deduced for function
calls, but not for data types, pointer types, or variables used
as global constants, such as \TT{true} or \TT{false}.
In order to avoid having to
input a {\em module-abbreviation} with every type name, 
{\em abbreviation-statements} are used (\pagref{ABBREVIATION-STATEMENT}).
The following are the builtin abbreviations:
\begin{center}
\tt
\begin{tabular}{rcl}
int		& \ABV & std int \\
intd		& \ABV & std intd \\
intq		& \ABV & std intq \\
int8		& \ABV & std int8 \\
int16		& \ABV & std int16 \\
int32		& \ABV & std int32 \\
int64		& \ABV & std int64 \\
int128		& \ABV & std int128
\\[1ex]
uns		& \ABV & std uns \\
unsd		& \ABV & std unsd \\
unsq		& \ABV & std unsq \\
uns8		& \ABV & std uns8 \\
uns16		& \ABV & std uns16 \\
uns32		& \ABV & std uns32 \\
uns64		& \ABV & std uns64 \\
uns128		& \ABV & std uns128
\\[1ex]
bool		& \ABV & std bool \\
true		& \ABV & std true \\
false		& \ABV & std false
\\[1ex]
TRUE		& \ABV & std TRUE \\
FALSE		& \ABV & std FALSE \\
NONE		& \ABV & std NONE \\
UNDEF		& \ABV & std UNDEF \\
*LOGICAL-LINE*		& \ABV & std *LOGICAL-LINE* \\
*INDENTED-PARAGRAPH*	& \ABV & std *INDENTED-PARAGRAPH* \\
\\[1ex]
flt		& \ABV & std flt \\
fltd		& \ABV & std fltd \\
fltq		& \ABV & std fltq \\
flt8		& \ABV & std flt8 \\
flt16		& \ABV & std flt16 \\
flt32		& \ABV & std flt32 \\
flt64		& \ABV & std flt64 \\
\\[1ex]
dp		& \ABV & std dp \\
ap		& \ABV & std ap \\
fp		& \ABV & std fp \\
av		& \ABV & std av \\
fv		& \ABV & std fv \\
\end{tabular}
\end{center}

\section{Constant Functions and Compiler Constants}

Constant functions have {\tt const} results
and do not produce run-time code.\pagnote{CONSTANT-FUNCTION}
The functions described in the
following sections are builtin constant functions.

Some compilation related functions and
constants are in the `{\tt compiler}' module,
which is abbreviated here as `{\tt com}'.

Unless stated otherwise, builtin constant functions
obey the following rules:
\begin{enumerate}
\item
Boolean values are represented by the special constants
{\tt TRUE} and {\tt FALSE}.
\item
Errors in arguments, such as passing a {\tt string} when a
{\tt number} or {\tt rational} is required, result in the
function doing nothing but returning
the {\tt UNDEF} special constant and producing
a compiler error message.
\item
If a result or argument is said to be an integer, it may
be either a {\tt number} with an integral value, or a
{\tt rational} with denominator {\tt 1}.
\item
A \ttkey{number} is a {\tt const} value representable by a
{\em number-constant}.\pagnote{NUMBER-CONSTANT}.

A function (e.g., {\tt "+"} or {\tt "=="})
with at least one {\tt number} argument will
convert all {\tt rational} arguments to {\tt numbers}
before using them, will do all internal calculations with
{\tt numbers} and not {\tt rationals},
and will return any numeric results as {\tt numbers}.

{\tt Number} values too positive or negative to store
are converted to {\tt +Inf} or {\tt -Inf}.
{\tt Number} values too small to store
are converted to {\tt +0} or {\tt -0}, preserving the
sign of the value.
\end{enumerate}

\subsection{Compile Time General Functions}

{\tt constant function const r = std (const v1) \ttkey{"=="} ( const v2 )} \\
{\tt constant function const r = std (const v1) \ttkey{"!="} ( const v2 )}
\begin{indpar}
If any argument is a number and the other is rational,
the rational is converted to a number before the comparison.
Otherwise comparisons of {\tt const} values of different types treat
the values as unequal.
\end{indpar}

{\tt constant function const r = std \ttkey{type} ( const v1 )}
\begin{indpar}
Returns the type of {\tt v1} as one of the strings: \\
\hspace*{0.5in}{\tt
"special" ~  "number" ~ "rational" ~ "string" ~ \tt "map"}
\end{indpar}


\subsection{Compile Time Numeric Functions}

Unless specified otherwise,
if one argument is a number and the others are rational,
the rational arguments are converted to numbers before
the function executes.

{\tt constant function const r = std \ttkey{number} ( const v1 )} \\
{\tt constant function const r = std \ttkey{rational} ( const v1 )}
\begin{indpar}
These convert their argument to a number or rational.  If
the argument is a string, it must have the format of
a number or rational constant (rational operator followed
by quoted string).
If the argument is a map, the map must have two elements
that are strings, with the first being a rational operator
and the second being the quoted string it operates on.
Map annotations are ignored, so the map may be
\TT{`~'} quoted.  E.g.,
\begin{indpar}\begin{verbatim}
`B# "1.1"'    { "B#", "1.1" }
\end{verbatim}\end{indpar}


A conversion
error produces an {\tt UNDEF} result and an error message.
Note that finite numbers can always be converted to rationals,
and rationals can always be converted to numbers, though these
may be {\tt +Inf} or {\tt -Inf}.
\end{indpar}

{\tt constant function const r = std \ttkey{"+"} ( const n1 )} \\
{\tt constant function const r = std \ttkey{"-"} ( const n1 )} \\
{\tt constant function const r = std (const n1) \ttkey{"+"} ( const n2 )} \\
{\tt constant function const r = std (const n1) \ttkey{"-"} ( const n2 )} \\
{\tt constant function const r = std (const n1) \ttkey{"*"} ( const n2 )} \\
{\tt constant function const r = std (const n1) \ttkey{"/"} ( const n2 )}
\begin{indpar}
Standard arithmetic operators on numbers or rationals {\tt n1} and {\tt n2},
done using IEEE number or rational arithmetic.
For numbers, dividing by {\tt 0},
adding {\tt +Inf} to {\tt -Inf}, a {\tt NaN} argument, etc.~return
{\tt NaN} and \underline{no} compiler error message.
For rationals, dividing by {\tt 0} returns {\tt UNDEF} and outputs a
compiler error message.
\end{indpar}

{\tt constant function const r = std (const i1) \ttkey{"\&"} ( const i2 )} \\
{\tt constant function const r = std (const i1) \ttkey{"|"} ( const i2 )} \\
{\tt constant function const r = std (const i1) \ttkey{"\textasciicircum"}
                            ( const i2 )} \\
{\tt constant function const r = std (const i1) \ttkey{"<{}<"} ( const i2 )} \\
{\tt constant function const r = std (const i1) \ttkey{">{}>"} ( const i2 )}
\begin{indpar}
Standard bitwise operators on integers {\tt i1} and {\tt i2}
that are treated as two's complement.  For the shift operators
{\tt "<{}<}" and {\tt ">{}>"}, {\tt i2}, the amount of the shift,
must not be negative.  Overflows for number {\tt <{}<} shift
produce an {\tt UNDEF} result and a compiler error message,
as do non-integer arguments.
\end{indpar}

{\tt constant function const r = std (const n1) \ttkey{"=="} ( const n2 )} \\
{\tt constant function const r = std (const n1) \ttkey{"!="} ( const n2 )} \\
{\tt constant function const r = std (const n1) \ttkey{"<"} ( const n2 )} \\
{\tt constant function const r = std (const n1) \ttkey{"<="} ( const n2 )} \\
{\tt constant function const r = std (const n1) \ttkey{">"} ( const n2 )} \\
{\tt constant function const r = std (const n1) \ttkey{">="} ( const n2 )}
\begin{indpar}
Standard comparison operators on numbers or rationals {\tt n1} and {\tt n2}.
Infinities are treated as actual numbers with absolute value
larger than any real number: e.g., if {\tt x} is not a {\tt NaN},
`{\tt x <= +Inf}' is always
{\tt TRUE} and `{\tt x == +Inf}' is {\tt TRUE} iff {\tt x} is {\tt +Inf}.
If an argument is a {\tt NaN}, all comparisons return {\tt FALSE}
except {\tt !=} which returns {\tt TRUE}, but there is \underline{no} compiler
error message.
\end{indpar}

{\tt constant function const r1, const r2 = std \ttkey{floor} \\
\hspace*{0.5in}(const n1, const n2 ?=~1 )} \\
{\tt constant function const r1, const r2 = std \ttkey{ceiling} \\
\hspace*{0.5in}(const n1, const n2 ?=~1 )} \\
{\tt constant function const r1, const r2 = std \ttkey{truncate} \\
\hspace*{0.5in}(const n1, const n2 ?=~1 )} \\
{\tt constant function const r1, const r2 = std \ttkey{round} \\
\hspace*{0.5in}(const n1, const n2 ?=~1 )}
\begin{indpar}
These divide {\tt n1} by {\tt n2} and return {\tt r1} as the
result rounded to an integer and {\tt r2} as the remainder.
Here {\tt floor} rounds toward negative infinity, {\tt ceiling}
rounds towards positive infinity, {\tt truncate} rounds toward
zero, and {\tt round} rounds to the nearest integer, or to the
even integer if there are two nearest integers.

If an argument is a number, return {\tt NaN}s if the divisor is
zero, an argument is a {\tt NaN}, or {\tt n1} is an infinity, but
do \underline{not} output a compiler error message.  If both
arguments are rationals and the divisor is zero, return
{\tt UNDEF} and output a compiler error message.
\end{indpar}

{\tt constant function const r = std} \ttkey{numerator} {\tt ( const r1 )} \\
{\tt constant function const r = std} \ttkey{denominator} {\tt ( const r1 )}
\begin{indpar}
These functions return the numerator and denominator of {\tt r1},
which must be a rational.
Both numerator and denominator are integer {\tt rationals}.
\end{indpar}

{\tt constant function const r = std} \ttkey{is nan} {\tt ( const v1 )} \\
{\tt constant function const r = std} \ttkey{is infinite} {\tt ( const v1 )} \\
{\tt constant function const r = std} \ttkey{is finite} {\tt ( const v1 )}
\begin{indpar}
Return {\tt TRUE} if {\tt v1} is a NaN number ({\tt is nan}),
is {\tt +Inf} or {\tt -Inf} ({\tt is infinite}), or
is a number that is neither of these ({\tt is finite}), and {\tt FALSE}
otherwise.  {\tt v1} must be a number or a rational;
if it is a rational, it is converted to a number before it is tested.
\end{indpar}

\subsection{Compile Time String Functions}

{\tt constant function const r = std} \ttkey{"\#"} {\tt ( const s )}
\begin{indpar}
Returns the length of string {\tt s} as a non-negative integer
{\tt number}.\footnote{The length of a {\tt string} cannot
be above $2^{48}$ while
{\tt numbers} can precisely store integers up to $2^{53}$.}
Note that {\tt \#} is a prefix operator.
\end{indpar}

{\tt constant function const r = std} (const s1) \ttkey{"+"} {\tt ( const s2 )}
\begin{indpar}
Returns the concatenation of string {\tt s1}
and string {\tt s2}.
\end{indpar}

{\tt constant function const r = std} \ttkey{sprintf}
    {\tt ( \begin{tabular}[t]{@{}l}
            const format, const a1 = "", \\
	    const a2 = "", const a3 = "", \\
	    const a4 = "", const a5 = "" )
	    \end{tabular} }
\begin{indpar}
Returns the string made by calling the UNIX {\tt sprintf} function as per: \\
\hspace*{1in}{\tt sprintf ( format, a1, a2, a3, a4, a5 )} \\
where {\tt format} is a string.  Not all of the data arguments
{\tt a1}, {\tt a2}, {\tt a3}, {\tt a4}, and {\tt a5}
need be used by the {\tt format}.
Data arguments may be numbers or strings.
Rational data arguments are converted to numbers first.  Map data arguments
are not allowed.
\end{indpar}

{\tt constant function const r = std (const s1) \ttkey{"=="} ( const s2 )} \\
{\tt constant function const r = std (const s1) \ttkey{"!="} ( const s2 )} \\
{\tt constant function const r = std (const s1) \ttkey{"<"} ( const s2 )} \\
{\tt constant function const r = std (const s1) \ttkey{"<="} ( const s2 )} \\
{\tt constant function const r = std (const s1) \ttkey{">"} ( const s2 )} \\
{\tt constant function const r = std (const s1) \ttkey{">="} ( const s2 )}
\begin{indpar}
Standard lexigraphic comparison operators on strings {\tt s1} and {\tt s2}.
Characters are compared by comparing their {\tt UTF-8} representations
as strings of unsigned 8-bit bytes.  With exceptions for unnormalized
{\tt UTF-8} encodings,\footnote{
An unnormalized {\tt UTF-8} encoding for a character is one taking
more bytes than necessary.  For example, {\tt NUL} with UNICODE code {\tt 0},
can be encoded in 1-byte if normalized, or in 2-, 3-, or 4- bytes
unnormalized.}
this is equivalent to comparing the characters
by comparing their UNICODE codes as unsigned 32-bit integers.
\end{indpar}

{\tt constant function const r = std} \ttkey{explode} {\tt ( const s )}
\begin{indpar}
Returns a map that is a vector whose elements are unsigned integer {\tt numbers}
equal to the UNICODE codes of the characters of string {\tt s}.
\end{indpar}

{\tt constant function const r = std} \ttkey{implode} {\tt ( const m )}
\begin{indpar}
Given a map {\tt m} that is a vector whose elements are unsigned integer
{\tt numbers}
that are UNICODE codes of characters, return the string whose characters
are those specified by the map elements in the order specified by the map.
\end{indpar}

{\tt constant function const r = std} \ttkey{compile re} ( const s )
\begin{indpar}
Compile the regular expression represented by the string {\tt s}
and return an integer that references the compiled expression.

Regular expressions are those recognized by the {\tt pcre32}
subroutine library for linux: see {\tt pcrepattern[3]} in
the linux documentation.  The only line ends recognized
by {\tt \textbackslash R} and {\tt \$} are LF, CR, and CRLF (no other
{\tt pcre32} options are used).  By default {\tt \textasciicircum}
matches the beginning of the string being matched and {\tt \$} matches the end.
This can be changed by the {\tt (?i)} option setter in the
regular expression.
\end{indpar}

{\tt function} \ttkey{free re} ( const i )
\begin{indpar}
Free the memory used by the compiled regular expression
referenced by the integer {\tt i}.  Does nothing if {\tt i}
does not reference a compiled regular expression.
\end{indpar}

{\tt constant function const r = std} \ttkey{match re} ( const i, const s  )
\begin{indpar}
Matches the string {\tt s} to the compiled regular expression
referenced by the integer {\tt i}.
Returns a map {\tt r} that is a vector of substrings matched.
If there is no match this is an empty list.  If there is
a match, {\tt r[0]} is the string matched.  If there are
subpattern matches, {\tt r[i]} is the string matched by the
{\tt i}'th subpattern.

During matching {\tt s} is stored as an exploded vector of
unsigned 32-bit unicode values.  Matched strings are
subvectors which are imploded to make {\tt const} string values.
\end{indpar}

{\tt constant function const r = std} \ttkey{scan} ( const s  )
\begin{indpar}
Scan the string {\tt s} and return a map that is a vector
containing the list of lexemes in {\tt s}.  Brackets and
operators are not specially recognized and are returned
as strings.  Quoted strings inside {\tt s} are returned
as vector elements that are maps of the form: \\
\hspace*{0.2in}{ \tt \{~{\rm \em represented-string},
	         ".type" => "<Q>" \}}

Syntax errors produce compiler error messages and
return {\tt UNDEF}.
\end{indpar}

{\tt constant function const r = std} \ttkey{parse brackets} ( const s  )
\begin{indpar}
Equivalent to {\tt `{\rm \em value-of-}s'}.
See {\em phrase-constants}: \pagref{PHRASE-CONSTANT}.

Specifically, parse the string {\tt s} recognizing brackets
but not recognizing operators and return a map.
Syntax errors produce compiler error messages and
return {\tt UNDEF}.
\end{indpar}

{\tt constant function const r = std} \ttkey{unparse brackets}
	( const v, const f ?= "\%0.16g"  )
\begin{indpar}
Inverse of {\tt parse brackets}.  Return a string $S$ such
that {\tt ` "$S$" '} equals {\tt v} with numeric rounding differences.
Numbers are printed in $S$ using {\tt f} as a printf format.
\end{indpar}

{\tt constant function const r = std} \ttkey{parse} ( const s  )
\begin{indpar}
Equivalent to {\tt \{* {\rm \em value-of-}s *\}}.
See {\em expression-constants}: \pagref{EXPRESSION-CONSTANT}.

Specifically, parse the string {\tt s} and return a map.
Syntax errors produce compiler error messages and
return {\tt UNDEF}.
\end{indpar}

{\tt constant function const r = std} \ttkey{unparse}
	( const v, const f ?= "\%0.16g"  )
\begin{indpar}
Inverse of {\tt parse}.  Return a string $S$ such
that {\tt \{* "$S$" *\}} equals {\tt v} with numeric rounding differences.
Numbers are printed in $S$ using {\tt f} as a printf format.
\end{indpar}

\subsection{Compile Time Map Functions}

A {\tt const} map value is actually a pointer to the map,
and not the whole map itself.
A {\em map-constant} creates a new map, distinct from every
other map (so you can have multiple different empty maps).

A map may be read-write or read-only.\label{READ-ONLY-MAP}
Read-only maps cannot
be modified.  Each {\em map-constant} makes a separate read-only
map that can be made read-write permanently or temporarily by
the following:

{\tt constant function const r = std} \ttkey{read-write} {\tt ( const m )} \\
{\tt constant function const r = std} \ttkey{read-only} {\tt ( const m )}
\begin{indpar}
Makes the map {\tt m} read-write or read-only and returns {\tt m}.

When the map is created by a {\em map-constant}, it is made read-only.
\end{indpar}

Each map {\em dictionary-entry} can be separately made read-write or
read-only.  When created, the entry is read-only.  This can be
changed by the following:

{\tt constant function const r = std} \ttkey{read-write}
                                      {\tt ( const m, const s )} \\
{\tt constant function const r = std} \ttkey{read-only}
                                      {\tt ( const m, const s )} %
\label{READ-ONLY-DICTIONARY-FUNCTION}
\begin{indpar}
Makes the map label {\tt s} (a string) of the map {\tt m}
read-write or read-only, and returns {\tt m}.  The dictionary entry
labelled {\tt s} in the map {\tt m} can be written if it is
read-write and the whole map is separately read-write.

When a value is first written at a label, the label is created
for the map and set to read-write.

In addition, the compiler will mark some map labels as \key{protected}.
Such entries are read-only to the code being compiled, and may either be
permanently read-only or may be written only by the compiler
during compilation.
\end{indpar}

{\tt constant function const r = std} \ttkey{"\#"} {\tt ( const m )}
\begin{indpar}
Returns the length of the vector part of the map {\tt m}
as a non-negative integer
{\tt number}.\footnote{The length of a {\tt map} cannot
be above $2^{48}$ while
{\tt numbers} can precisely store integers up to $2^{53}$.}
Note that {\tt \#} is a prefix operator.
\end{indpar}

{\tt constant function const r = std} \ttkey{labels} {\tt ( const m )}
\begin{indpar}
Returns a list of the {\em dictionary-labels}
(see \pagref{DICTIONARY-LABEL}) of map {\tt m}.
The {\em dictionary-labels} are strings.  The list may be empty.
\end{indpar}


{\tt constant reference function const r = std}
    {\tt ( const m ) [ const s ?=~NONE ]} \\
{\tt constant reference function std}
    {\tt ( const m ) [ const s ?=~NONE ] = const v}
\begin{indpar}
Here {\tt m} is map and {\tt m[s]} is used to reference a
vector element or dictionary entry of {\tt m} as follows:
\begin{enumerate}
\item If the value of {\tt s} is a non-negative non-rational integer number,
the {\tt s}+1'st element
of the vector of {\tt m} is referenced.  If this is being read and
it does not exist, {\tt NONE} is returned and there is no compile
error.
If the element is being written but does not exist, or the map
is read-only, a compile error results; otherwise the element
value is changed.
\item If the value of {\tt s} is a negative non-rational integer,
{\tt s} is replaced by {\tt \# m + s}, and things
are as in the last paragraph (note {\tt \# m + s < \# m}).  The element
does not exist if {\tt \# m + s < 0}.
\item If the value of {\tt s} is a string, the dictionary entry
of {\tt m} with label {\tt s} is referenced.  If this is being read and
it does not exist, {\tt NONE} is returned.  If it is being written and
it does not exist, and if the map is read-write,
the entry is created and made read-write.
Else if the entry exists and is read-write, and the map is read-write,
the entry value is changed.
Else if the entry exists and is read-only, or the map is read-only,
a compile error results.
\item If the value of {\tt s} is {\tt NONE}, reading pops a value from the
end of the vector
of {\tt m} and returns the value popped (as in `{\tt v = m[]}'),
or just returns {\tt NONE} if the vector is empty,
and writing pushes the value written to the end of the vector of {\tt m}
(as in `{\tt m[] = v}').
\item Otherwise if {\tt s} is neither a non-rational integer or a string,
a compile-error results.
\end{enumerate}
\end{indpar}

{\tt constant function const r = std} \ttkey{copy} {\tt ( const m )} \\
{\tt constant function const r = std} \ttkey{copy top} {\tt ( const m )} %
\label{MAP-COPY}
\begin{indpar}
Returns a new map whose contents is a copy of the contents of
map {\tt m}.  The new map is read-only if and only if {\tt m} is,
and the labels in the new map are read-only if and only if the
corresponding labels in {\tt m} are.

If any vector or dictionary element values are maps, they are
copied recursively by {\tt copy}, but not by
{\tt copy top}, which only copies the element values of {\tt m}
and does not copy recursively.

Changing the values of elements of the new map will \underline{not} change
the contents of {\tt m}.  For {\tt copy} modifying the element values
that are maps will not change {\tt m}, but for {\tt copy top},
modifying these element values will change the elements of {\tt m}.

\end{indpar}

{\tt constant function const r = std} \ttkey{duplicate} {\tt ( const m )} \\
{\tt constant function const r = std} \ttkey{duplicate top} {\tt ( const m )}
\begin{indpar}
Ditto, but if any read-only map is to be copied, the pointer
to the map is copied and no new map is made.
\end{indpar}

{\tt constant function const r = std} \ttkey{slice}
    {\tt ( const m, const i, const n )}
\begin{indpar}
{\tt i} and {\tt n} must be non-rational integers.

If {\tt i < 0} then {\tt i} is replaced by {\tt \# m + i} before the
following is done.

Then if {\tt n > 0}, returns a new map consisting of just a vector of the
elements {\tt m[i]}, {\tt m[i+1]}, \ldots, {\tt m[i+n-1]}.  
If any of these elements do not exist, they are omitted (e.g.,
if {\tt i >= \# m} or {\tt i + n <= 0} the empty map is returned).

If {\tt n == 0 } the empty map is returned.

If {\tt n < 0} the elements returned are
{\tt m[i+n]}, {\tt m[i+n+1]}, \ldots, {\tt m[i-1]}.

\end{indpar}

{\tt constant function const r = std} \ttkey{splice}
    {\tt ( const m, const i, const n, const v )}
\begin{indpar}
{\tt i} and {\tt n} must be non-rational integers.

If {\tt i < 0} then {\tt i} is replaced by {\tt \# m + i} before the
following is done.

Then if {\tt n > 0},
edits {\tt m} by replacing the vector element sequence
{\tt m[i]}, {\tt m[i+1]}, \ldots, {\tt m[i+n-1]} by the
vector elements of {\tt v}.  Dictionary elements of {\tt v} are ignored;
dictionary elements of {\tt m} are unchanged.

If {\tt n == 0}
the elements of {\tt v} are pushed into {\tt m}
just after {\tt m[i]}.

If {\tt n < 0} the elements replaced are 
{\tt m[i+n]}, {\tt m[i+n+1]}, \ldots, {\tt m[i-1]}.

The elements being replaced need not (all) exist.  {\tt m} is thought
of as an infinite sequence of existing and non-existing elements indexed
by integers, including negative integers.  The members of
{\tt m} to be removed are made non-existant,
then the elements of {\tt v} are pushed
into the sequence, and then non-existant elements are deleted.

So if {\tt i >= \# m} and {\tt n >= 0} then the elements of {\tt v}
are appended to {\tt m}, and if {\tt i = -1} and {\tt n <= 0}, the
elements of {\tt v} are prepended to {\tt m}.

The edited map {\tt m} is returned.

\end{indpar}

{\tt constant function const r = std} \ttkey{truncate}
                                      {\tt ( const m, const i )}
\begin{indpar}
An optimized version of {\tt splice} that removes the elements
{\tt m[i]}, {\tt m[i+1]}, \ldots, from the end of the vector of {\tt v}.
The edited map {\tt m} is returned.  It is not an error if no elements
are removed.

If {\tt i} < 0 it is replaced by {\tt \# m + i}.  If {\tt \# m + i < 0},
all elements of the vector are removed.
\end{indpar}

{\tt constant function const r = std} \ttkey{push} {\tt ( const m, const v )}
\begin{indpar}
Appends {\tt v} to the vector of {\tt m} and returns {\tt m}.
\end{indpar}

{\tt constant function const r = std} \ttkey{push}
    {\tt ( const m, const v, const i )}
\begin{indpar}
Executes {\tt push(m,v)} {\tt i} times.  {\tt i} must be a
non-rational, non-negative integer.
\end{indpar}

{\tt constant function const r = std} \ttkey{append}
    {\tt ( const m1, const m2 )}
\begin{indpar}
Appends the vector elements of the map {\tt m2} to the vector of {\tt m1}
and returns {\tt m1}.
\end{indpar}

{\tt constant function const r = std} \ttkey{pop} {\tt ( const m )}
\begin{indpar}
Deletes the last vector element of {\tt m} and returns it.
Returns {\tt NONE} if {\tt m} is empty.
\end{indpar}

{\tt constant function const r = std} \ttkey{pop} {\tt ( const m, const i )}
\begin{indpar}
Deletes the last {\tt i} vector elements of {\tt m} and returns a map
containing them in the same order.
If there are fewer than {\tt i} vector elements
in {\tt m}, the returned vector will have only {\tt \# m} elements.
{\tt i} must be a non-rational, non-negative integer.
\end{indpar}

\subsection{Type, Field, Subfield, and Pointer Type Maps}
\label{TYPE-FIELD-SUBFIELD-MAPS}

Types, fields, subfields, and pointer types are described
at compile-time by {\tt const} map values which
user code can access.
These are read-write as a whole, but some of their
labels are protected.  The following sections describe protected labels
provided by the compiler.  Unless otherwise specified,
these have values that do not change during compilation.

Compiled code may add its own labels to these maps.
To prevent conflict, the labels provided by the compiler
begin with `{\tt .}', so
that to use them to access a map dictionary entry
you must use double dots: `{\tt ..}'.
E.g., {\tt int..size}.

In the following a \key{name string} is a string
consisting of a sequence of one or more {\em words}
and {\em natural-numbers}, separated
by single spaces, and beginning with a {\em word}.
{\em Natural-numbers} are represented
by strings of 1 to 9 decimal digits with no high-order
zeros (zero is represented by `{\tt 0}').
Name strings are used to represent type, field, and subfield
names.

{\em Module abbreviations} in a name string are
replaced by \key{compiler module abbreviations}
which are words of the form {\tt M\$$n$}, where
$n$ is a natural number.  {\tt M\$0} is always
the abbreviation for the {\tt std} module.
These compiler module abbreviations are specific to the
entire compilation and are not dependent on which
module or body a definition appears in.

{\tt com module dictionary}
\begin{indpar}
A dictionary mapping compiler module abbreviation numbers
to strings that are {\em mod\-ule-names}.  Specifically:
{\tt com module dictionary[$n$] == "$N$"}
means {\tt M\$$n$ \rm{maps to} $N$}.
For example,
\\[0.5ex]
\hspace*{1.5in}{\tt com module dictionary[0] == "standard"}

\end{indpar}

\subsubsection{Type Maps}
\label{TYPE-MAPS}

At compile-time a {\em type-name} can be used as a {\tt const} type
{\em variable-name} that names a read-only variable with a map value
called a \key{type map}.

The compiler defined attributes of a type map are:

{\tt \ttkey{.type} => "type"}

\ttkey{.name}
\begin{indpar}
The name of the type as a name string.
\end{indpar}

\ttkey{.size} \\
\ttkey{.alignment}
\begin{indpar}
The {\tt .size} is the number of bits taken by a value of the given type at
run-time.
The {\tt .alignment} is the alignment in bits
of an aligned value of the given type at
run-time.
\\ E.g., {\tt int64..size == 64, int64..alignment == 64}.

These may increase during compilation of type expansions, and will be
{\tt UNDEF} for {\tt *DEFERRED*} types not yet defined by the
compilation.
\end{indpar}

\ttkey{.expandable} \\
\ttkey{.external}
\begin{indpar}
The {\tt .expandable} attribute is {\tt TRUE} if the
current list of type subdeclarations ends with
{\tt ***} \underline{or} {\tt *EXTERNAL*},
and {\tt FALSE} otherwise.
The {\tt .external} attribute is {\tt TRUE} if the current
list of type subdeclarations ends with
{\tt *EXTERNAL*}, and {\tt FALSE} otherwise.

These may change during compilation of type expansions, and are
{\tt UNDEF} for {\tt *DEFER\-RED*} types not yet defined by the
compilation.
\end{indpar}

\ttkey{.fields}
\begin{indpar}
A map listing field maps\pagnote{FIELD-MAPS} for the fields of the type.
The dictionary entries list named fields by name.
The vector entries list unnamed fields
(which have subfields).

Fields may be added during compilation of type expansions.
Will be empty if a type has no fields, or if the type is
currently {\tt *DEFERRED*} and not yet defined by the
compilation.
\end{indpar}

\ttkey{.min} \\
\ttkey{.max}
\begin{indpar}
The minimum and maximum values of a number type $N$.  Not defined for
non-number types.  These are {\tt const} values which must be
converted to the run-time type $N$ before being used
(e.g., by the expression `$N$($N$..max)').  These values are exact;
for some $N$, these values can be {\em number-constants}, but
for others they must be {\em rational-constants}
(e.g., {\tt uns64..max} is {\tt X\#"7FFFFFFFFFFFFFFF"}).
\end{indpar}

\ttkey{.indefinite}
\begin{indpar}
The value of the indefinite integer for a \underline{signed} integer type $I$.
Not defined for non-integer and unsigned integer types.

The \key{indefinite integer}\label{INDEFINITE-INTEGER} is returned by
some operations, e.g. {\tt round},
when they return a correct integer value.%
\footnote{See documentation of the intel IA-64 FIST instruction.}

The value is typically $-2^{S-1}$ where $S$ is the size of $I$ in bits.

This is a {\tt const} value which must be
converted to the run-time type $I$ before being used
(e.g., by the expression `$I$($I$..indefinite)').  This value is exact;
for some $I$, the values can be a {\em number-constant}, but
for others it must be a {\em rational-constant}
(e.g., {\tt int64..indefinite} is {\tt -B\#"1e63"}).
\end{indpar}

Example:
\begin{indpar}\begin{verbatim}
int64 = { .type => "type",
          .name => "int",
          .size => 64,
          .alignment => 64,
          .expandable => FALSE,
          .external => FALSE,
          .fields => {},
          .min => -X#"8000000000000000",
          .max => X#"7FFFFFFFFFFFFFFF",
          .indefinite => -X#"8000000000000000" }
\end{verbatim}\end{indpar}

\subsubsection{Field Maps}
\label{FIELD-MAPS}

Each field of a type has a {\tt const} map value called
a \key{field map} which is in the {\tt .fields} dictionary of
a type map.  The compiler defined attributes of a field map are:

{\tt \ttkey{.type} => "field"}

\ttkey{.name}
\begin{indpar}
The name of the field ({\em target-label} or {\em pointer-label})
as a name string.  May be {\tt NONE} for a field with subfields.
\end{indpar}

\ttkey{.parent}
\begin{indpar}
Type map of the type of containing this field.
\end{indpar}

\ttkey{.offset}
\begin{indpar}
Offset in bits of the field within a value of its parent type.
\end{indpar}

\ttkey{.pointer-type}
\begin{indpar}
Pointer type map for the pointer type of the field,
or {\tt NONE}.
\end{indpar}

\ttkey{.pointer-qualifiers}
\begin{indpar}
List of strings, each a {\em word} naming a qualifier
of the field pointer type, or {\tt NONE} if there is no
pointer type.  May be empty list.
\end{indpar}

\ttkey{.field type}
\begin{indpar}
Type map for the type of the field if the {\tt .pointer-type}
is {\tt NONE}, or the {\tt .pointer-type} target if the
{\tt .pointer-type} is not {\tt NONE}, or {\tt NONE}
for a {\tt *LABEL*}.
\end{indpar}

\ttkey{.qualifiers}
\begin{indpar}
List of strings, each a {\em word} naming a qualifier
of the field.  May be empty list.
If {\tt .pointer-type} is \underline{not} {\tt NONE},
these qualifiers apply to the pointer value of the field
and not to its target.
\end{indpar}

\ttkey{.dimensions}
\begin{indpar}
List of strictly positive integers, the dimensions of the field, or {\tt NONE}
if no dimensions.
\end{indpar}

\ttkey{.subfields}
\begin{indpar}
Dictionary of subfield maps for the subfields of the type.  The labels
of the dictionary entries are the names of the subfields.
Empty if there are no subfields.
\end{indpar}

Example:
\begin{indpar}\begin{verbatim}
type my type:
    int32 X[4,3]
    av *READ-WRITE* flt @Y

// The value of the global const variable `my type' is:
{ .type => "type",
  .name => "my type",
  .size => 128,
  .alignment => 64,
  .expandable => FALSE,
  .external => FALSE,
  .fields => {
      { .type => "field",
        .name => "X",
        .parent => my type, // Note absence of quotes
        .offset => 0,
        .pointer-type => NONE,
        .pointer-qualifiers => {},
        .field type => int32, // Note absence of quotes
        .qualifiers => {},
        .dimensions => {4, 3},
        .subfields => {}
      },
      { .type => "field",
        .name => "@Y",
        .parent => my type,  // Note absence of quotes
        .offset => 384,      // 12 * 32
        .pointer-type => av, // Note absence of quotes
        .pointer-qualifiers => {},
        .field type => flt, // Note absence of quotes
        .qualifiers => { "*READ-WRITE*" },
        .dimensions => {},
        .subfields => {}
      }
  }
}

\end{verbatim}\end{indpar}

\subsubsection{Subfield Maps}
\label{SUBFIELD-MAPS}

Each subfield of a field has a {\tt const} map value called
a \key{subfield map} which is in the {\tt .subfields} dictionary of
a field map.  The compiler defined attributes of a subfield map are:

{\tt \ttkey{.type} => "subfield"}

\ttkey{.name}
\begin{indpar}
The name of the subfield ({\em target-label})
as a name string.
\end{indpar}

\ttkey{.parent}
\begin{indpar}
Field map of the field of containing this subfield.
\end{indpar}

\ttkey{.bits}
\begin{indpar}
A list of two integers: {\tt \{{\rm \em highbit},{\rm \em lowbit}\}}.
\end{indpar}

\ttkey{.subfield type}
\begin{indpar}
Type map for the type of the subfield.
This is always a {\tt std} number type or {\tt std bool}.
\end{indpar}

\ttkey{.dimensions}
\begin{indpar}
List of strictly positive integers,
the dimensions of the subfield, or {\tt NONE} if no dimensions.
\end{indpar}

\subsubsection{Pointer Type Maps}
\label{POINTER-TYPE-MAPS}

At compile-time a {\em pointer-type-name} can be used as a {\tt const} type
{\em variable-name} that names a read-only variable with a map value
called a \key{pointer type map}.

The compiler defined attributes of a pointer type map are:

{\tt \ttkey{.type} => "pointer type"}

\ttkey{.name}
\begin{indpar}
The name of the pointer type as a name string.
\end{indpar}

\ttkey{.data type}
\begin{indpar}
Type map for the data type of the pointer type.
\end{indpar}

\subsection{Compile Time Compilation Functions}
\label{COMPILE-TIME-COMPILATION-FUNCTIONS}

These functions are principally of use in {\tt macro} or
{\tt inclusion} functions, but can be used in any inline function.

{\tt load reference function const r = com \ttkey{*STATEMENT*} }%
\label{COM-STATEMENT}
\begin{indpar}
This {\em function-variable-name} returns the parsed {\em statement}
containing the {\tt inclusion} function
currently executing at compile-time.
\end{indpar}

{\tt load reference function const r = com \ttkey{*SUBBLOCK*} }%
\label{COM-SUBBLOCK}
\begin{indpar}
This {\em function-variable-name} returns the subblock at the end
of the parsed {\em statement}
containing the {\tt inclusion} function currently executing at compile-time.
This is annotated with {\tt ".initiator" = ":"} and
{\tt ".terminator" = *INDENTED-PARAGRAPH*}.

If instead of ending with a subblock, the statement ends with the
{\tt ":"} operator followed by a {\em restricted-statement} $S$,
this function returns: \\
\hspace*{0.3in}{\tt \{ $S$, ".initiator" = ":",
                        ".terminator" = *INDENTED-PARAGRAPH* \} }

In other words, this function packages $S$ in the form of a 1-{\em statement}
subblock.
\end{indpar}

{\tt load reference function const r = com \ttkey{new variable name} }%
\label{NEW-VARIABLE-NAME}
\begin{indpar}
This function returns a {\em variable-name} of the form {\tt "V\$\ldots"}
that is unique and distinct from any other variable name in the current
compilation.  In particular, the function does not return the same
{\em variable-name} twice.

\end{indpar}

{\tt constant function const r = com \ttkey{name of} ( const variable name )}
\begin{indpar}
Here `{\tt variable name}' is a {\em variable name}
declared in a non-macro {\em prototype-argument-declaration} of a
{\tt macro} or {\tt inclusion} {\em function-declaration} $D$,
and the {\tt name of} function is called by $D$.
The type of the variable
in this {\em proto\-type-argument-declaration} \underline{cannot}
be {\tt const}.

This function returns a {\em variable-name} of the form {\tt V\$\ldots}
created by calling {\tt com new variable name}
that can be used inside run-time code produced by the inline or inclusion
function to reference the value of the actual argument associated with
the {\em prototype-argument-declaration} of the `{\tt variable name}'.
More explicitly,
if the {\em prototype-argument-declara\-tion} has the form `$TTT$ $V$'
where $TTT$ consists of runtime types and qualifiers and $V$ is a
{\em variable-name}, and if \\
\hspace*{1in}{\tt $W$ = name of ( "$V$" )}, \\
is executed in the inline function,
and if {\tt "V\$\ldots"} is returned as the value of $W$,
then code of the form: \\
\hspace*{1in}{\tt $TTT$ V\$\ldots = {\em actual-argument}} \\
is executed at runtime just before the {\em statement} containing
the executing inline function.
\end{indpar}

For example:
\begin{indpar}[1em]\begin{verbatim}
function macro r = inc ( macro v, int w ):
    const W = name of ( "w" )
    return { v, "+=", { W } }
ap *READ-WRITE* int @x:
    x = 5
inc ( x, 10 ) // Same as:
              //     int V$1 = 10
              //     {{"x"}, "+=", {V$1}}.
    // Now x == 15.
\end{verbatim}\end{indpar}

\subsection{Compile Time Exception and Trace Support}
\label{COMPILE-TIME-EXCEPTION-AND-TRACE-SUPPORT}

An L-Language \key{ID} is a {\tt const} integer storable
at run time in an {\tt uns} variable that identifies something.
{\em Throw-exception-statements} may have \skey{exception ID}s
and {\em trace-statements} may have \skey{trace ID}s.

The {\tt std} module defines the following {\tt const} maps and functions:

{\tt const std \ttkey{exception ID map} = \{ "NONE" \} } \\
{\tt const std \ttkey{trace ID map} = \{ \}}

{\tt constant function const r = std \ttkey{new exception ID} ( const name ) }%
\label{NEW-EXCEPTION-ID}
\begin{indpar}
A call to this function pushes {\tt name} to the end of
{\tt std exception ID map} and returns the new length of the map minus 1.
\end{indpar}

{\tt constant function const r = std \ttkey{new trace ID} ( const name ) }%
\label{NEW-TRACE-ID}
\begin{indpar}
A call to this function pushes {\tt name} to the end of
{\tt std trace ID map} and returns the new length of the map minus 1.

There must be no more than 64 trace IDs.

\end{indpar}


\subsection{Compile Time Machine Parameters}

{\tt const com \ttkey{atomc types} = \{ "int", "uns", \ldots{} \}}%
\label{ATOMIC-TYPES}
\begin{indpar}
These are the types for which atomic operations\pagnote{ATOMIC-OPERATIONS}
are defined.
\end{indpar}

{\tt const com \ttkey{hardware overflow} =
    \ldots{}} ~~~~~[{\tt TRUE} or {\tt FALSE}]%
\label{HARDWARE-OVERFLOW}
\begin{indpar}
{\tt TRUE} iff hardware computes the overflow {\tt bool} for integer
addition and subtraction.\pagnote{ADD-SUB-OVERFLOW}
{\tt FALSE} if this is computed when needed by software
(much more slowly).
\end{indpar}

\section{Builtin Run-Time Functions and Constants}

Run-time functions execute at run-time, and but may have
parts that execute at compile-time, and may even return
{\tt const} results.

The L-Language built-in run-time functions are very basic
and provide only functionality that cannot be efficiently
provided by library functions.

\subsection{Builtin Run-Time Constants}
\label{BUILTIN-RUN-TIME-CONSTANTS}

\begin{indpar} \tt
bool std \ttkey{true} = 1 \\
bool std \ttkey{false} = 0
\end{indpar}


\subsection{Builtin Implicit Conversions}
\label{BUILTIN-IMPLICIT-CONVERSIONS}

See \itemref{TYPE-CONVERSIONS} for non-builtin conversions.


\subsubsection{Numeric Implicit Conversions}
\label{NUMERIC-IMPLICIT-CONVERSIONS}

Any value of number or {\tt bool} type {\tt N1}
can be implicitly converted to a value
of number type {\tt N2} if every value of type {\tt N1} can be
precisely represented by a value of type {\tt N2}, or if {\tt N1} is
an integer type and {\tt N2}
is a floating point type.

Note that a larger floating point type
\underline{cannot} be implicitly converted to a smaller floating point type,
as such would create a cyclic loop in the
implicit conversion graph\pagnote{IMPLICIT-CONVERSION-GRAPH}.
Also note that implicit conversions are the shortest path in this
graph, e.g., the exact path {\tt int32} $\rightarrow$ {\tt flt64}
will be used and the inexact path
{\tt int32} $\rightarrow$ {\tt flt32} $\rightarrow$ {\tt flt64} will not be.

More specifically,
the implicit conversions are defined by:
\begin{indpar} \tt
function N2 r = std \ttkey{*IMPLICIT* *CONVERSION*} ( N1 v )
\end{indpar}
in the following cases:
\begin{center}
\begin{tabular}{l|c|c|c|}
\multicolumn{1}{c}{}	& \multicolumn{3}{c}{\tt N1} \\
\tt N2  & \tt flt64 & \tt flt32 & \tt flt16
\\\hline
\tt flt64 & no & yes & yes \\
\tt flt32 & no & no & yes \\
\tt flt16 & no & no & no
\\\hline
\tt int\ldots{} & no & no & no \\
\tt uns\ldots{} & no & no & no
\\\hline
\end{tabular}
\\[2ex]
\begin{tabular}{l|c|c|c|c|}
\multicolumn{1}{c}{}	& \multicolumn{4}{c}{\tt N1} \\
\tt N2  & \tt int64 & \tt int32 & \tt int16 & int8
\\\hline
\tt flt64 & yes & yes & yes & yes \\
\tt flt32 & yes & yes & yes & yes \\
\tt flt16 & yes & yes & yes & yes
\\\hline
\tt int64 & no & yes & yes & yes \\
\tt int32 & no & no & yes & yes \\
\tt int16 & no & no & no & yes \\
\tt int8 & no & no & no & no
\\\hline
\tt uns\ldots{} & no & no & no & no
\\\hline
\end{tabular}
\\[2ex]
\begin{tabular}{l|c|c|c|c|c|}
\multicolumn{1}{c}{}	& \multicolumn{5}{c}{\tt N1} \\
\tt N2  & \tt uns64 & \tt uns32 & \tt uns16 & uns8 & bool
\\\hline
\tt flt64 & yes & yes & yes & yes & yes \\
\tt flt32 & yes & yes & yes & yes & yes \\
\tt flt16 & yes & yes & yes & yes & yes
\\\hline
\tt int64 & no & yes & yes & yes & yes \\
\tt int32 & no & no & yes & yes & yes \\
\tt int16 & no & no & no & yes & yes \\
\tt int8 & no & no & no & no & yes
\\\hline
\tt uns64 & no & yes & yes & yes & yes \\
\tt uns32 & no & no & yes & yes & yes \\
\tt uns16 & no & no & no & yes & yes \\
\tt uns8 & no & no & no & no & yes
\\\hline
\end{tabular}
\end{center}

\subsubsection{Pointer Implicit Conversions}
\label{POINTER-IMPLICIT-CONVERSIONS}

An aligned pointer may be implicitly converted to a direct pointer:

\begin{indpar}
{\tt function dp Q\$ T\$ @r =
    std \ttkey{*IMPLICIT* *CONVERSION} ( ap Q\$ T\$ @p )}
\begin{indpar}
The base address of {\tt @p} is added to the offset of {\tt @p} to
produce the value of {\tt @r}.
\end{indpar}
\end{indpar}

\subsubsection{Qualifier Implicit Conversions}
\label{QUALIFIER-IMPLICIT-CONVERSIONS}

Implicit conversions of qualifiers may occur whenever a pointer
value is copied, unlike other implicit conversions.
The following are qualifier conversions:
\begin{indpar}
\begin{enumerate}
\item {\tt co} may be replaced by {\tt ro}
\item {\tt *READ-WRITE*} may be replaced by {\tt ro}
\item {\tt *READ-WRITE*} may be replaced by {\tt *WRITE-ONLY*}
\item Lifetime qualifiers can be converted when pointers are read or
stored: see (L3), (L6), (L12), (L14), (L15) of \itemref{LIFETIMES}.

\end{enumerate}
\end{indpar}

\subsection{Builtin Explicit Conversions}
\label{BUILTIN-EXPLICIT-CONVERSIONS}

See \itemref{TYPE-CONVERSIONS} for non-builtin conversions.

\subsubsection{Numeric Explicit Conversions}

{\tt function F r = std F (N v)}
\begin{indpar}
Where {\tt F} is any builtin floating point type
and {\tt N} is any builtin number or {\tt bool} type.

Converts {\tt v} to the type {\tt F}.  The result may be
{\tt +Inf} or {\tt -Inf}, or precision may be lost.
\end{indpar}

{\tt function I r = std \ttkey{floor} (F v1, F v2 ?=~1.0 )} \\
{\tt function I r = std \ttkey{ceiling} (F v1, F v2 ?=~1.0 )} \\
{\tt function I r = std \ttkey{truncate} (F v1, F v2 ?=~1.0 )} \\
{\tt function I r = std \ttkey{round} (F v1, F v2 ?=~1.0 )}
\begin{indpar}
Where {\tt I} is any builtin \underline{signed} integer type
and {\tt F} is one of {\tt flt}, {\tt flt64}, or {\tt flt32}.

These divide {\tt v1} by {\tt v2} and return {\tt r} as the
result rounded to an integer.
Here {\tt floor} rounds toward negative infinity, {\tt ceiling}
rounds towards positive infinity, {\tt truncate} rounds toward
zero, and {\tt round} rounds to the nearest integer, or to the
even integer if there are two nearest integers.

The floating point flags set are those set by division (see below), plus the
inexact flag may be set if the division quotient is not a integer, plus
the invalid flag is set if the result is outside the range storable in
{\tt I}.  In the last case, and the result is
an indefinite integer.\pagnote{INDEFINITE-INTEGER}
\end{indpar}

{\tt function I1 r = std \ttkey{*UNCHECKED*} ( I2 v )}
\begin{indpar}
Where {\tt I1} and {\tt I2} are any builtin integer types
such that at least one of the following is true:
\begin{enumerate}
\item {\tt I1} is shorter than {\tt I2}
\item {\tt I1} and {\tt I2} are of equal length and one
is {\tt int\ldots} while the other is {\tt uns\ldots}
\item {\tt I2} is {\tt int\ldots} while {\tt I1} is {\tt uns\ldots}.
\end{enumerate}

These in effect convert {\tt v} to a bit-string of unbounded length (e.g., by
two's complement sign extension) and
then truncate it to the length of {\tt I1}.
\end{indpar}

{\tt function N r, std FP flags f = std \ttkey{D\#} ( ap ro C s )} \\
{\tt function N r, std FP flags f = std \ttkey{B\#} ( ap ro C s )} \\
{\tt function N r, std FP flags f = std \ttkey{X\#} ( ap ro C s )}
\label{RUN-TIME-STRING-TO-NUMBER-CONVERSIONS}
\begin{indpar}
Where {\tt N} is any number type
and {\tt C} is {\tt uns8}, {\tt uns16}, or {\tt uns32} (for UTF8, UTF16,
or UTF32 strings).

These convert the string {\tt s} to the number {\tt r}, where the
string is formatted as in Section \itemref{RATIONAL-CONSTANTS}.

Error flags are set in {\tt f} (see \pagref{FP-FLAGS}).
If there are no errors, no flags are set.
If {\tt s} does not have the proper format,
or its value is negative and {\tt N} is an unsigned integer,
the {\tt Invalid} flag is set, {\tt NaN} is returned for floating point types,
and the indefinite integer\pagnote{INDEFINITE-INTEGER}
is returned for integer types.
If the value is to large to store, the
{\tt Overflow} flag is set,
{\tt $\pm$Inf} is returned for floating point types,
and the most positive or negative storable value is returned
for integer types.  If the value must be rounded when it is stored,
the {\tt Inexact} flag is set.
\end{indpar}

\subsubsection{Pointer Explicit Conversions}

{\tt function ap Q\$ T\$ @r = std \ttkey{*UNCHECKED*} ( dp Q\$ T\$ @p )}
\begin{indpar}
The base pointer of {\tt r} is set to point at a location that is
always {\tt 0} and the offset of {\tt r} is set to point to the
address stored as the value of {\tt p}.
\end{indpar}

{\tt function av Q\$ T\$ r = std \ttkey{*UNCHECKED*} \\
\hspace*{0.2in}( ap Q\$ T\$ p, int offset, int lower, int upper )}
\begin{indpar}
The base pointer of {\tt @r} is set to the base pointer of {\tt @p},
the offset of {\tt @r} is set to the sum of the offset of {\tt @p}
and the {\tt offset} argument, and the bounds of {\tt @r} are set from
the {\tt lower} and {\tt upper} arguments.
\end{indpar}

\subsection{Builtin Floating Point Operations}
\label{BUILTIN-FLOATING-POINT-OPERATIONS}

A floating point {\tt NaN}
is a quiet NaN with zero significand bits, except for the
highest order bit which is one (to indicate that the NaN is quiet).

{\tt function F r = std \ttkey{"+"} ( F v1 )} \\
{\tt function F r = std \ttkey{"-"} ( F v1 )} \\
{\tt function F r = std (F v1) \ttkey{"+"} ( F v2 )} \\
{\tt function F r = std (F v1) \ttkey{"-"} ( F v2 )} \\
{\tt function F r = std (F v1) \ttkey{"*"} ( F v2 )} \\
{\tt function F r = std (F v1) \ttkey{"/"} ( F v2 )}
\begin{indpar}
Where {\tt F} is one of {\tt flt}, {\tt flt64}, or {\tt flt32}.
\\[1ex]
Standard arithmetic operators on numbers {\tt v1} and {\tt v2},
done using IEEE floating point arithmetic.

Floating point operations may set the following floating point flags:
\begin{itemlist}
\item[Invalid]  Set in the following cases.  Returns {\tt NaN}.
\\[1ex]
\hspace*{0.5in}\begin{tabular}{l@{\hspace*{1in}}l}
	     \tt +Inf + -Inf & \tt -Inf + +Inf \\
	     \tt +Inf - +Inf & \tt -Inf - -Inf \\
	     \tt +Inf * 0 & \tt 0 * +Inf \\
	     \tt -Inf * 0 & \tt 0 * -Inf \\
	     \tt +Inf / +Inf & \tt +Inf / -Inf \\
	     \tt -Inf / +Inf & \tt -Inf / -Inf \\
	     \tt +0 / +0 & \tt +0 / -0 \\
	     \tt -0 / +0 & \tt -0 / -0 \\
	     \end{tabular}
\item[Divide by Zero]  Set when a non-zero value is divided by a zero value.
Returns {\tt +Inf} or {\tt -Inf} with sign determined by the signs
of the zero and non-zero values in the usual way.
\item[Overflow]  Set when the computed value is a number outside the range that
can be stored because its absolute value is too large.
Returns {\tt +Inf} or {\tt -Inf}.
\item[Underflow] Set when the computed value is a number outside the range that
can be stored because its absolute value is too small.
Returns {\tt +0} or {\tt -0}.
\item[Inexact] Set when the computed value cannot be precisely stored but
is inside the range of absolute values that can be stored.  Returns
the nearest value that can be stored, with ties
going to the value whose least significant bit is zero.
\end{itemlist}
\end{indpar}

{\tt function F r = std \ttkey{floor} (F v1, F v2 ?=~1.0 )} \\
{\tt function F r = std \ttkey{ceiling} (F v1, F v2 ?=~1.0 )} \\
{\tt function F r = std \ttkey{truncate} (F v1, F v2 ?=~1.0 )} \\
{\tt function F r = std \ttkey{round} (F v1, F v2 ?=~1.0 )}
\begin{indpar}
Where {\tt F} is one of {\tt flt}, {\tt flt64}, or {\tt flt32}.

These divide {\tt v1} by {\tt v2} and return {\tt r} as the
result rounded to an integer.
Here {\tt floor} rounds toward negative infinity, {\tt ceiling}
rounds towards positive infinity, {\tt truncate} rounds toward
zero, and {\tt round} rounds to the nearest integer, or to the
even integer if there are two nearest integers.

The floating point flags set are those set by division (see above), plus the
inexact flag may be set if the division quotient is not a integer.
If the division quotient is an infinity or {\tt NaN},
{\tt r} is set to this quotient.
\end{indpar}

{\tt function bool r = std (F v1) \ttkey{"=="} ( F v2 )} \\
{\tt function bool r = std (F v1) \ttkey{"!="} ( F v2 )} \\
{\tt function bool r = std (F v1) \ttkey{"<"} ( F v2 )} \\
{\tt function bool r = std (F v1) \ttkey{"<="} ( F v2 )} \\
{\tt function bool r = std (F v1) \ttkey{">"} ( F v2 )} \\
{\tt function bool r = std (F v1) \ttkey{">="} ( F v2 )}
\begin{indpar}
Where {\tt F} is one of {\tt flt}, {\tt flt64}, or {\tt flt32}.

Standard comparison operators on floating point numbers {\tt v1} and {\tt v2}.
Infinities are treated as actual numbers with absolute value
larger than any real number: e.g., if {\tt x} is not a {\tt NaN},
`{\tt x <= +Inf}' is always
true and `{\tt x == +Inf}' is true iff {\tt x} is {\tt +Inf}.
If an argument is a {\tt NaN}, the result is undefined and an invalid
flag is set.
\end{indpar}

{\tt function bool r = std} \ttkey{is nan} {\tt ( F v1 )} \\
{\tt function bool r = std} \ttkey{is infinity} {\tt ( F v1 )} \\
{\tt function bool r = std} \ttkey{is finite} {\tt ( F v1 )}
\begin{indpar}
Where {\tt F} is one of {\tt flt}, {\tt flt64}, {\tt flt32}, or {\tt flt16}.
\begin{itemlist}
\item[\tt is nan]
Returns {\tt true} if {\tt v1} is \underline{any} NaN number
(not just the quiet {\tt NaN} with zero significand bits except for
the highest order one),
and {\tt false} otherwise.
\item[\tt is infinity]
Returns {\tt true} if {\tt v1} is {\tt +Inf} or {\tt -Inf}, and {\tt false}
otherwise.
\item[\tt is finite]
Returns {\tt true} if {\tt is nan} and {\tt is infinity}
both return {\tt false}, and returns {\tt false} otherwise.
\end{itemlist}
\end{indpar}

{\tt
type~std~\ttkey{FP flags}:\label{FP-FLAGS} \\
\begin{tabular}[t]{@{~~~~~}l}
\tt uns flags \\
\tt [\ldots] bool invalid (operand for a given operation) \\
\tt [\ldots] bool divide by zero \\
\tt [\ldots] bool overflow \\
\tt [\ldots] bool underflow \\
\tt [\ldots] bool inexact \\
\end{tabular} \\
}
{\tt load reference function std FP flags r = std} \ttkey{FP flags register} \\
{\tt store reference function std}
    \ttkey{FP flags register} {\tt = std FP flags v}
\begin{indpar}
The hardware floating point flags can be read into a datum of type
{\tt FP flags} and an {\tt FP flags} datum can be written
to the hardware floating point flags by using the {\tt FP flags register}
reference functions.  The exact bits in the data that contain the flags
are implementation dependent, and are here represented by `{\tt \ldots{}}'.
\end{indpar}

If a memory space has more than one process (a.k.a., thread - i.e., local
stack\pagnote{LOCAL-STACK}), each process has its own
{\tt std FP flags register}.

\subsection{Builtin Integer Operations}
\label{BUILTIN-INTEGER-OPERATIONS}


{\tt function I r, bool cout, bool ovfl =
	std \ttkey{"+"} ( I v1, bool cin = 0 )} \\
{\tt function I r, bool cout, bool ovfl =
	std \ttkey{"-"} ( I v1, bool cin = 1 )} \\
{\tt function I r, bool cout, bool ovfl =
    std (I v1) \ttkey{"+"} ( I v2, bool cin = 0 )} \\
{\tt function I r, bool cout, bool ovfl =
    std (I v1) \ttkey{"-"} ( I v2, bool cin = 1 )}
\begin{indpar}
Where {\tt I} is one of:
	\begin{tabular}[t]{l}
	\tt int  int128 int64  int32  int16  int8 \\
	\tt uns  int128 uns64  uns32  uns16  uns8 \\
	\end{tabular}
\\[1ex]
Standard arithmetic operators on {\tt v1} and {\tt v2}
treated as binary unsigned integers.  When values are
interpreted as two's complement signed integers, these
operations also give valid results.

{\tt cin} is added to the result; {\tt cout} is the carry from
the result.  Operands are made negative by bitwise complementing
them and adding 1 by setting {\tt cin = 1}.

{\tt ovfl} is set to {\tt 1} if and only if the operation overflows
when values are interpreted as signed two's complement integers.
If S0, S1, and Sr are the signs of {\tt v1}, {\tt v2}, and {\tt r},
for two operand "+" this would equal {\tt S0 $=$ S1 $\neq$ Sr}.
{\tt ovfl} is computed by some hardware, but is expensive to
compute if not supported by hardware.\label{ADD-SUB-OVERFLOW}  See
{\tt com hardware overflow}.\pagnote{HARDWARE-OVERFLOW}

\end{indpar}

{\tt function I r = std (I v1) \ttkey{"*"} ( I v2 )} \\
{\tt function U r, U cout =
    std (U v1) \ttkey{"*"} ( U v2, U cin1 = 0, U cin2 = 0 )}
\begin{indpar}
Where {\tt I} is one of:
	\begin{tabular}[t]{l}
	\tt int  int128 int64  int32  int16 \\
	\end{tabular}
\\[1ex]
and {\tt U} is one of:
	\begin{tabular}[t]{l}
	\tt uns  uns64  uns32 \\
	\end{tabular}
\\[1ex]
The version without carries is the standard arithmetic multiply
which truncates results that are outside the range of {\tt I}.

The version with carries is integer multiply of N-bit unsigned
integers to produce a 2N-bit product to which \underline{both}
{\tt cin1} and {\tt cin2} are
added.  Of the result {\tt r} is the low order N bits
and {\tt cout} is the high order N bits.

\end{indpar}

{\tt function I r = std (I v1) \ttkey{"/"} ( I v2 )} \\
{\tt function U r, U cout = std (U v1, U cin = 0) \ttkey{"/"} ( U v2 )}
\begin{indpar}
Where {\tt I} is one of:
	\begin{tabular}[t]{l}
	\tt int  int128 int64  int32  int16 \\
	\end{tabular}
\\[1ex]
and {\tt U} is one of:
	\begin{tabular}[t]{l}
	\tt uns  uns64  uns32 \\
	\end{tabular}
\\[1ex]
The version without carries is the standard arithmetic divide.
An exception trap occurs if {\tt v2 $=$ 0}.

The version with carries is integer divide of a 2N-bit unsigned
dividend made by concatenating {\tt cin} (high order) and
{\tt v1} (low order) by an N-bit unsigned divisor {\tt v2}.  The result
is an N-bit quotient {\tt r} and an N-bit remainder {\tt cout}.
An exception trap occurs if {\tt v2 $\leq$ cin} (this includes
that case where {\tt v2 $=$ 0}).

\end{indpar}

{\tt function I r = std        \ttkey{"\textasciitilde"} ( I v1 )} \\
{\tt function I r = std (I v1) \ttkey{"\&"} ( I v2 )} \\
{\tt function I r = std (I v1) \ttkey{"|"} ( I v2 )} \\
{\tt function I r = std (I v1) \ttkey{"\textasciicircum"} ( I v2 )}
\begin{indpar}
Where {\tt I} is one of:
	\begin{tabular}[t]{l}
	\tt int  int128 int64  int32  int16 int8 \\
	\tt uns  uns128 uns64  uns32  uns16 uns8 bool \\
	\end{tabular}
\\[1ex]
Standard bitwise operators, complement ({\tt \textasciitilde}),
and ({\tt \&}), or ({\tt |}), and exclusive or ({\tt \textasciicircum}),
on integers {\tt v1} and {\tt v2}
that are treated as two's complement if signed.
\end{indpar}

{\tt function I r = std (I v1) \ttkey{"<{}<"} ( int v2 )} \\
{\tt function I r = std (I v1) \ttkey{">{}>"} ( int v2 )}
\begin{indpar}
Where {\tt I} is one of:
	\begin{tabular}[t]{l}
	\tt int  int128 int64  int32  int16 int8 \\
	\tt uns  uns128 uns64  uns32  uns16 uns8 \\
	\end{tabular}
\\[1ex]
Standard bitwise shifts of integer {\tt v1} by the amount {\tt v2}.
If signed, {\tt v1} is treated as two's complement.
The amount of shift, {\tt v2}, must be in the range
[0,{\tt I..size}); values out of range produce undefined results.
Bits shifted out at the left or
right side are discarded.
\end{indpar}

{\tt function bool r = std (I v1) \ttkey{"=="} ( I v2 )} \\
{\tt function bool r = std (I v1) \ttkey{"!="} ( I v2 )} \\
{\tt function bool r = std (I v1) \ttkey{"<"} ( I v2 )} \\
{\tt function bool r = std (I v1) \ttkey{"<="} ( I v2 )} \\
{\tt function bool r = std (I v1) \ttkey{">"} ( I v2 )} \\
{\tt function bool r = std (I v1) \ttkey{">="} ( I v2 )}
\begin{indpar}
Where {\tt I} is one of:
	\begin{tabular}[t]{l}
	\tt int  int128 int64  int32  int16 int8 \\
	\tt uns  uns128 uns64  uns32  uns16 uns8 bool \\
	\end{tabular}
\\[1ex]
Standard comparison operators on integers {\tt v1} and {\tt v2}.
\end{indpar}

\subsection{Builtin Pointer Operations}
\label{BUILTIN-POINTER-OPERATIONS}

{\tt function ap Q\$1  T\$1 r = \\
\hspace*{1in}std ( uns length, uns alignment ) null}%
\label{NULL} \\
{\tt function av Q\$1  T\$1 r = \\
\hspace*{1in}std ( uns length, uns alignment ) null [ uns count ]}
\begin{indpar}
These functions allocate a value of type {\tt T\$1}
(or {\tt count} values of type {\tt T\$1}) to null
memory (memory in inaccessible virtual pages that memory fault if
accessed)
and return a pointer to the value(s).
\\[1ex]
These functions can only be called by an
{\tt allocation-call}\pagnote{ALLOCATION-CALL}.
See \pagref{ALLOCATION-CALLS}.
\end{indpar}

{\tt function ap QU\$1  T\$1 r = \\
\hspace*{1in}std ( uns length, uns alignment ) local}%
\label{LOCAL} \\
{\tt function av QU\$1  T\$1 r = \\
\hspace*{1in}std ( uns length, uns alignment ) local [ uns count ]}
\begin{indpar}
These functions allocate a value of type {\tt T\$1}
(or {\tt count} values of type {\tt T\$1}) to local
memory (the current out-of-line function execution's frame in the local stack:
see \pagref{OUT-OF-LINE-LOCALS})
and return a pointer to the value(s).
\\[1ex]
These functions can only be called by an
{\tt allocation-call}\pagnote{ALLOCATION-CALL}.
See \pagref{ALLOCATION-CALLS}.
\end{indpar}

{\tt function ap QU\$1 *GLOBAL* T\$1 r = \\
\hspace*{1in}std ( uns length, uns alignment ) global}%
\label{GLOBAL} \\
{\tt function av QU\$1 *GLOBAL* T\$1 r = \\
\hspace*{1in}std ( uns length, uns alignment ) global [ uns count ]}
\begin{indpar}
These functions allocate a value of type {\tt T\$1}
(or {\tt count} values of type {\tt T\$1}) to global
memory (the global stack: see \pagref{GLOBAL-MEMORY})
and return a pointer to the value(s).
\\[1ex]
These functions can only be called by an
{\tt allocation-call}\pagnote{ALLOCATION-CALL}.
See \pagref{ALLOCATION-CALLS}.
\end{indpar}

\subsection{Builtin Exception and Trace Support Operations}
\label{BUILTIN-EXCEPTION-AND-TRACE-SUPPORT-OPERATIONS}

The following functions can be used in an {\em exception-subblock}
to determine which variables of its containing
{\em block-assignment-statement} or {\em loop-assignment-statement}
have been set.

{\tt function bool r = std is set ( N value )} \\
{\tt function bool r = std is set ( P\$1 Q\$1 T\$1 pointer )}%
\label{IS-SET}
\begin{indpar}
where {\tt N} is any number type.
\\[1ex]
Returns {\tt true} if the {\tt value} is not zero or the {\tt pointer}
is not {\tt null}, and {\tt false} otherwise. 
These functions should only be used inside
{\em exception-subblocks}\pagnote{EXCEPTION-SUBBLOCK}.
\end{indpar}

Information about the last exception is recorded in the following:

{\tt
type~std~\ttkey{exception data}: \\
\begin{tabular}[t]{@{~~~~~}l}
\tt uns~ID~~~~~~~~~~// exception ID from throw statement \\
\tt dp~uns8~@pc~~~~~// program counter of throw statement\\
\end{tabular} \\
}
{\tt load reference function std exception data r = std}
    \ttkey{current exception data} \\
{\tt store reference function std} \ttkey{current exception data}
    {\tt = std exception data v}
\begin{indpar}
The current exception data contain the exception ID and program counter
of the last exception.  These are set by
a {\em throw-statement}\pagnote{THROW-STATEMENT} that
gives an exception ID.   A {\em throw-statement} without an exception ID
coes not change the current exception data.
\end{indpar}

If a memory space has more than one process (a.k.a., thread - i.e., local
stack\pagnote{LOCAL-STACK}), each process has its own
{\tt std current exception data}.

A program fault executes the equivalent of a {\em throw-statement}
with one of the following exception IDs:

{\tt std divide exception = std new exception ID ( "DIVIDE" )} \\
\hspace*{1in}{\tt // Integer divide by zero.} \\
{\tt std inaccessible exception = std new exception ID ( "INACCESSIBLE" )} \\
\hspace*{1in}{\tt // Read or write of inaccessible memory location.}  \\
{\tt std write exception = std new exception ID ( "WRITE" )} \\
\hspace*{1in}{\tt // Write of accessible but write-protected
                  memory location.}

See Compile Time Exception and Trace Support
\itemref{COMPILE-TIME-EXCEPTION-AND-TRACE-SUPPORT}
for the {\tt std new exception ID} function.

A mask determining which {\em trace-statements} are active
is recorded in the following:

{\tt load reference function uns64 r = std} \ttkey{current trace mask}%
\label{CURRENT-TRACE-MASK} \\
{\tt store reference function std} \ttkey{current trace mask} {\tt = uns64 v}
\begin{indpar}
Read and write the current trace mask.
A {\em trace-statement}\pagnote{TRACE-STATEMENT} with trace ID X
will be executed if the current trace mask has bit {\tt 1 <{}< X}
on, and will be a no-operation otherwise.
\end{indpar}

If a memory space has more than one process (a.k.a., thread - i.e., local
stack\pagnote{LOCAL-STACK}), each process has its own
{\tt std current trace mask}.

The following is an example trace mask:
\begin{indpar}\begin{verbatim}
uns64 trace file errors = 1 << std new trace ID ( "FILE ERRORS" )
    // Note: 1 << X is an exact integer in the IEEE floating point
    //       format used for const numbers even when X is
    //       a large integer.
\end{verbatim}\end{indpar}

See Compile Time Exception and Trace Support
\itemref{COMPILE-TIME-EXCEPTION-AND-TRACE-SUPPORT}
for the {\tt std new trace ID} function.


\section{Atomic Operations}
\label{ATOMIC-OPERATIONS}

\key{Atomic operations} read and write memory locations
that are shared between multiple CPUs or processes
using the same RAM memory.

When a process executes a program, the process may move
memory reads and writes around so they are no longer
done when they would be done were the program
statements executed in strict sequential order.  The
execution does this if the effect of the program is not
changed, under the assumption that the program is the
only user of the RAM memory.  But if there are multiple CPUs,
or a multi-tasking system asynchronously switching one CPU
between processes, this assumption is not correct.

There is also the possibility that if a memory location is
being read by CPU 1 and at the same time written by CPU 2,
what CPU 1 reads will consist partly of the location value
before CPU 2's write and partly of the location value after
CPU 2's write.

An operation is \key{atomic} if:
\begin{indpar}
\begin{enumerate}
\item
All read and or write operations and all atomic operations
for the current process that would be
before (or after) this atomic operation in strict sequential program execution
are before (or after) this atomic operation
in actual optimized program execution.
\item
This atomic operation cannot be interrupted by a read or write executed by a
different CPU or process of part of the memory being read or written
by this atomic operation.
\end{enumerate}
\end{indpar}

Atomic operations can only be performed on locations of \key{atomic type}.
Atomic types are listed in the {\tt com atomic types}\pagnote{ATOMIC-TYPES}
compile-time variable.
The word-length integer types, {\tt int} and {\tt uns}, are
always atomic types.

{\tt function A r = std atomic read ( ap QR\$1 A p )}
\begin{indpar}
For {\tt A} an atomic type,
read and return the location pointed at by {\tt p}.  In addition:
\begin{enumerate}
\item
All read or atomic operations for the current process that would be
before (or after) this operation in strict sequential program execution
are before (or after) this operation in actual optimized program execution.
\item
The read cannot be interrupted by a write executed by a different CPU
or process of part of the memory being read.
\end{enumerate}
\end{indpar}

{\tt function std atomic write ( ap QW\$1 A p, A v )}
\begin{indpar}
For {\tt A} an atomic type,
write the value {\tt v} to the location pointed at by {\tt p}.
In addition:
\begin{enumerate}
\item
All write or atomic operations for the current process that would be
before (or after) this operation in strict sequential program execution
are before (or after) this operation in actual optimized program execution.
\item
The write cannot be interrupted by a read executed by a different CPU
or process of part of the memory being read.
\end{enumerate}
\end{indpar}

{\tt function std bool r =
	atomic compare and set ( ap QRW\$1 A p, A vr, A vw )}
\begin{indpar}
For {\tt A} an atomic type,
read the location pointed at by {\tt p} and compare it to {\tt vr}.
If equal, write {\tt vw} to the location, and return {\tt true}.
If not equal, just return {\tt false}.
In addition:
\begin{enumerate}
\item
All read and write and atomic operations for the current process that would be
before (or after) this operation in strict sequential program execution
are before (or after) this operation in actual optimized program execution.
\item
The operation cannot be interrupted by a read or write
executed by a different CPU or process of any of the memory this operation
reads or writes.
\end{enumerate}
\end{indpar}

Example 1:
\begin{indpar}
A device has registers in global memory which are shared between the
device and a process.  The registers are either owned by the process
and the device is inactive, or the registers are owned by the device
which is executing an operation.  There is a register with a GO bit
which is turned on by the process to activate the device, and another
register with a READY bit which is set by the device when its current
operation is done.

The GO bit is set by an atomic write, which guarentees that all writes
to registers in the code before the GO bit is set are actually done
before the GO bit is set.

The READY bit is read by an atomic read, which guarentees that all reads
from registers in the code after the READY bit has been read as being on 
are actually done after the READY bit has been read as being on.
\end{indpar}

Example 2:
\begin{indpar}
A device has registers as in Example 1.  The device also has a large
memory accessed via two registers: A and D.  A holds the address of
a location in device memory, and D holds the contents of that location:
reading D reads the location contents, and writing D writes the location
contents.

Register A is set by an atomic write and then register D
is read by an atomic read.  Because atomic operations execute in the
same order as they appear in the code, the read will be done after the
write.
\end{indpar}

Example 3:
\begin{indpar}
A data structure which is shared among processes perhaps executing
on different CPUs is guarded by a lock consisting of two integer
memory locations: B (before) and A (after).  When the structure is
not being written, B == A.  A writer first increments B, then
updates the structure, and then increments A.

To get a write lock, the writer reads A atomically and then does
a compare and set on B that checks that B == A and if so writes
B+1 to B and acquires the lock.

To read, the reader reads A atomically and saves the value V,
then reads data from the structure, then reads B atomically and
checks that the value read equals V.  If the check passes, the data
is uncorrupted by writing that is simultaneous with the reading.
If the check fails, the data may be corrupted.  The reader must be
sure corrupted data does not destroy the integrity of the reader's execution,
but can read B atomically and check the value against V
at any time to see if the data read so far is uncorrupted.
\end{indpar}

	

\end{document}
