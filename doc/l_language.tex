% Layered Languages Low Level Language (L-Language)
%
% File:         l_language.tex
% Author:       Bob Walton (walton@acm.org)
% Date:		See \date below.
  
\documentclass[12pt]{article}

\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{makeidx}
\usepackage{upquote}
     % (import to local directory for CentOS 8)
     % Available on CentOS 8.

\makeindex

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\setlength{\textheight}{8.5in}
\raggedbottom

\setlength{\unitlength}{1in}

% The following attempt to eliminate headers at the bottom of a page.
\widowpenalty=300
\clubpenalty=300
\setlength{\parskip}{3ex plus 2ex minus 2ex}

\pagestyle{headings}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subsubsubsection}[1]{\paragraph[#1]{#1.}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph[#1]{#1.}}

% Begin \tableofcontents surgery.

\newcount\AtCatcode
\AtCatcode=\catcode`@
\catcode `@=11	% @ is now a letter

\renewcommand{\contentsname}{}
\renewcommand\l@section{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\l@table{\@dottedtocline{1}{0.1em}{1.4em}}
\renewcommand\tableofcontents{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{0.8in}%
	      \setlength{\rightmargin}{0.8in}}%
    \item\@starttoc{toc}%
    \end{list}}
\renewcommand\listoftables{%
    \begin{list}{}%
	     {\setlength{\itemsep}{0in}%
	      \setlength{\topsep}{0in}%
	      \setlength{\parsep}{1ex}%
	      \setlength{\labelwidth}{0in}%
	      \setlength{\baselineskip}{1.5ex}%
	      \setlength{\leftmargin}{1.0in}%
	      \setlength{\rightmargin}{1.0in}%
	      }%
    \item\@starttoc{lot}%
    \end{list}}

\catcode `@=\AtCatcode	% @ is now restored

% End \tableofcontents surgery.

\newcommand{\TILDE}{\textasciitilde}

\newcommand{\CN}[2]%	Change Notice.
    {\hspace*{0in}\marginpar{\sloppy \raggedright \it \footnotesize
     $^{\mbox{#1}}$#2}}
    % Change notice.

\newcommand{\TT}[1]{{\tt \bfseries #1}}
\newcommand{\TTALL}{\tt \bfseries}

\newcommand{\STAR}{{\Large $^\star$}}
\newcommand{\PLUS}[1][]{{$^{+#1}$}}
\newcommand{\QMARK}{{$^{\,\mbox{\footnotesize ?}}$}}
\newcommand{\OPEN}{{$\{$}}
\newcommand{\CLOSE}{{$\}$}}

\newcommand{\ABV}{-{}-{}->}
\newcommand{\MA}{{\em ma}\QMARK}
\newcommand{\TS}{\hspace*{0in}\tt}

\newcommand{\key}[1]{{\rm \bfseries #1}}
\newcommand{\ttkey}[1]{{\tt \bfseries #1}}
\newcommand{\emkey}[1]{{\em \bfseries #1}}
\newcommand{\skey}[2]{{\rm \bfseries #1#2}}
\newcommand{\tttkey}[1]{{\tt \bfseries <#1>}}
\newcommand{\ttakey}[1]{{\tt \bfseries *#1*}}
\newcommand{\ttdkey}[1]{{\tt \bfseries .#1}}

\newcommand{\itemref}[1]{\ref{#1}$\,^{p\pageref{#1}}$}
\newcommand{\pagref}[1]{p\pageref{#1}}
\newcommand{\pagnote}[1]{$\,^{p\pageref{#1}}$}
\newcommand{\stack}[1]{\begin{tabular}[t]{@{}l@{}}#1\end{tabular}}

\newcommand{\EOL}{\penalty \exhyphenpenalty}

\newlength{\figurewidth}
\setlength{\figurewidth}{\textwidth}
\addtolength{\figurewidth}{-0.40in}

\newsavebox{\figurebox}

\newenvironment{boxedfigure}[1][!btp]%
	{\begin{figure*}[#1]
	 \begin{lrbox}{\figurebox}
	 \begin{minipage}{\figurewidth}

	 \vspace*{1ex}}%
	{
	 \vspace*{1ex}

	 \end{minipage}
	 \end{lrbox}

	 \centering
	 \fbox{\hspace*{0.1in}\usebox{\figurebox}\hspace*{0.1in}}
	 \end{figure*}}

\newenvironment{indpar}[1][0.3in]%
	{\begin{list}{}%
		     {\setlength{\itemsep}{0in}%
		      \setlength{\topsep}{0in}%
		      \setlength{\parsep}{1ex}%
		      \setlength{\labelwidth}{#1}%
		      \setlength{\leftmargin}{#1}%
		      \addtolength{\leftmargin}{\labelsep}}%
	 \item}%
	{\end{list}}

\newenvironment{itemlist}[1][1.2in]%
	{\begin{list}{}{\setlength{\labelwidth}{#1}%
		        \setlength{\leftmargin}{\labelwidth}%
		        \addtolength{\leftmargin}{+0.2in}%
		        \renewcommand{\makelabel}[1]{##1\hfill}}}%
	{\end{list}}

\begin{document}
        
\begin{center}
\Large \bf
Low Level Layered Language\\[0.5ex]
\huge \bf
L-LANGUAGE
\end{center}
\begin{center}
\large \bf
(Draft 1a)
\\[0.5ex]
Robert L. Walton\\
January 12, 2022

\bigskip
 
Table of Contents
\end{center}

\bigskip

\tableofcontents 

\newpage

\section{Introduction}

This document describes \key{L-Language}, the Layered Language
System Low Level Language.

The L-Language is a system programming language built on the
following two main ideas:

\begin{indpar}

\key{Type Checking Segregation Hypothesis}~~~~ A strongly typed-checked
general-purpose computer-efficient language is impossible.
What is possible is
to segregate non-type-checkable code into small inline
library functions and into macro functions,
with code that uses these functions being
strongly type-checked.

\key{Fully Capable Macro Sublanguage Hypothesis}~~~~ It is better for
a programming language to have a builtin macro language that
is a general purpose interpreted language than it is for the
programming language to build into itself
many more limited and specialized type declaration and
flow control features.

\end{indpar}

\section{Overview}

A typical L-Language statement is:
\begin{indpar}\begin{verbatim}
int X = Y - C#"0"
\end{verbatim}\end{indpar}
This allocates a new variable {\tt X} of type {\tt int}
and sets its value to the value of the
variable {\tt Y} minus the constant {\tt C\#"0"} (which is
the character code of the character {\tt 0}).
The `variable' {\tt X} is readable, but after it is
initialized it is not writable.

The following is another example:
\begin{indpar}\begin{verbatim}
av *READ-WRITE* uns8 @bp =@ local[81]
av uns8 @cp = "Hello!"
int i = 0
while ( i < @cp.upper ):
    bp[i] = cp[i]
    next i = i + 1
bp[cp.upper] = 0
\end{verbatim}\end{indpar}

Here `{\tt local[81]}' creates an aligned vector of
81 {\tt uns8} (8-bit unsigned) numbers in the current function
frame and returns an aligned vector pointer, or {\tt av}, to
the vector, marking the vector elements as {\tt *READ-WRITE*}.
{\tt "Hello!"} is a constant vector of {\tt uns8} numbers
and is similar except that it marks the vector elements
{\tt co}, for `constant', which is the implied default qualifier
for {\tt @cp}, and therefore
is not explicitly given.
Vector pointers can be used with indices
to reference elements of their vectors, and have {\tt upper} and
{\tt lower} bounds on these indices.  Here the {\tt lower} bounds
are their defaults, which are {\tt 0}.

Here {\tt @bp} is a variable whose name begins with `{\tt @}' and
whose value is therefore a pointer.  Such a variable has an associated
indirect variable {\tt bp} whose name is missing the initial `{\tt @}'.
The expression {\tt @bp[i]} designates a pointer to the {\tt i}+1'st
element of the vector pointed at by {\tt @bp}, but the expression
{\tt bp[i]} designates the value of the element.  Similarly for
{\tt @cp[i]} and {\tt cp[i]}.\footnote{`{\tt @}' is analogous to
C++ `{\tt \&}' used in a variable declaration, but here `{\tt @}'
can be used with different types of pointers, can be used
without restrictions for structure members, and can be used
with mutable pointers.}

The qualifier {\tt *READ-WRITE*} says that a value can be written,
the default qualifier {\tt co}, or `constant',
says a value will \underline{never} be written no matter what,
the qualifier {\tt ro}, or read-only, says that
the value cannot be written using the variable name given, but might be
written by some other piece of code that accesses the value under another
name, and the qualifier {\tt *VOLATILE*} says a value may be
written by some device other than the processor, or by some process
independent of the current process, at any time.
A {\tt *VOLATILE*} value must also be either {\tt *READ-WRITE*}
or {\tt ro}, with {\tt ro} being the default.

Variables in function frames and module memory
have names, like {\tt X}, {\tt Y}, and {\tt Z}, and values
that are constants.
These values most frequently
have a size equal to the natural
word size of the computer (typically 32 or 64 bits), or
several times that size: {\tt intd} is a two word (double) integer
and {\tt intq} is a four word (quad) integer.
Although the value of a variable is constant, the value may point
at a memory location that is read-write.

An aligned vector pointer {\tt av} is a
quad integer ({\tt intq}) containing:
\begin{itemize}
\item A `base pointer' {\tt int} holding the byte address
of an {\tt int} in memory
that contains the `base (byte) address' of the vector.
Note that the {\tt av} value does \underline{not} contain
the base address, but contains instead this pointer to where
the base address is stored in memory.  This scheme allows
the base address to be change without changing the {\tt av} value.
\item An `offset' {\tt int} that is added to the base address
to form the byte address of the vector element
that has index {\tt 0} in the vector (this element does not
exist if {\tt 0} is not an allowed index).
\item A `lower bound' {\tt int} which is the minimum allowed
value of the index {\tt int}.
\item An `upper bound' {\tt int} which is the maximum allowed
value of the index {\tt int} plus 1.
\end{itemize}

There are other types of pointer.  An {\tt fv}, or `field vector',
is like an {\tt av} aligned
vector except that the offset {\tt int} has a bit address in its
high order part and a field size in bits in its low order part.
The {\tt ap} and {\tt fp} types are
similar but do not have the bounds and cannot be indexed.  Lastly
there is the direct pointer, {\tt dp}, that is just a single {\tt int}
containing a byte address; this is most useful for calling
C language functions.
New pointer types may be defined by the user.

If the value of a variable {\tt @V} is a pointer and the name of
the variable begins with an `{\tt @}', the variable's name with the
initial `{\tt @}' removed, in this case {\tt V}, is called the
indirect variable associated to {\tt @V}
and names the value pointed at by {\tt @V}.
For example:

\begin{indpar}\begin{verbatim}
int X = 5
ap *READ-WRITE* int @Y =@ local
Y = X + 2                // Now Y == 7
Y = Y - 4                // Now Y == 3
X = X + 1                // Illegal!  X is co
ap ro int Z = @Y         // Copies pointer value of Y
                         // Conversion from *READ-WRITE*
                         // to ro is legal.  As Z does not
                         // begin with @, there is no
                         // corresponding indirect variable.
\end{verbatim}\end{indpar}

Here `{\tt =@ local}' allocates an {\tt int} to the current
function frame, zeros it, and returns an `{\tt ap *READ-WRITE* int}'
pointer to its location.

Instead of making a variable point at a {\tt *READ-WRITE*} location you
can update the constant variable using the {\tt next} construct:
\begin{indpar}\begin{verbatim}
int X = 5
int Y = X + 2           // Now Y == 7; Y is co
next Y = Y - 4          // Now Y == 3; Y is co
Y = Y + 1               // Illegal!  Y is co
\end{verbatim}\end{indpar}
Here `{\tt next Y}' is a new variable, distinct from {\tt Y},
but with the same type, pointer type, qualifiers, and name `{\tt Y}',
which hides the previous variable of the same name.
The advantage of doing this is that it makes compilation more
efficient by keeping variables constant (i.e., {\tt co}), and
it improves debuggability by retaining the different values of
the variable for inspection by a debugger.

Loops use the `{\tt next \ldots}' construct.  For example:
\begin{indpar}\begin{verbatim}
// Compute sum of 4, 5, and 6.
//
int sum = 0
int i = 4
next sum, next i = while i <= 6:
    next sum = sum + i
    next i = i + 1
\end{verbatim}\end{indpar}
which is semantically equal to:
\begin{indpar}\begin{verbatim}
int sum = 0
int i = 4
next sum, next i:
    next sum = sum + i
    next i = i + 1
next sum, next i:
    next sum = sum + i
    next i = i + 1
next sum, next i:
    next sum = sum + i
    next i = i + 1
\end{verbatim}\end{indpar}
The `{\tt next sum}' and `{\tt next i}' before the `{\tt :}',
which are the output variables for the block of code containing
the two `{\tt +}' statements,
can also be implied as they appear as output variables
of the `{\tt +}' statements, so the above loop can be written as:
\begin{indpar}\begin{verbatim}
int sum = 0
int i = 4
while i <= 6:
    next sum = sum + i
    next i = i + 1
\end{verbatim}\end{indpar}

L-Language has a full set of number types:
{\tt int8}, {\tt uns8},
{\tt int16}, {\tt uns16}, {\tt flt16}, \ldots,
{\tt int128}, {\tt uns128}, {\tt flt128}; for signed integer,
unsigned integer, and floating point respectively.
The types {\tt int}, {\tt uns}, {\tt flt} are just these
types for the target machine word size.
The types {\tt intd}, {\tt intq}, {\tt unsd}, {\tt unsq} are just integer
types for twice (double) or four times (quad) the target machine word size.
The {\tt bool} type is a single bit interpreted as {\tt true} if
1 and {\tt false} if 0: it is in essence a 1-bit unsigned integer.

User defined types have values that
consist of a sequence of bytes containing fields.
Fields in turn can contain subfields.
An example is:

\begin{indpar}\begin{verbatim}
type my type:
             uns32                    // Container for:
    [24-31]  uns8 op code             //   Operation
    [31]     bool has constant        //   Format indicator
    [0-23]   int constant             //   Constant
    [16-23]  uns8 src1                //   Source Register
    [8-15]   uns8 src2                //   Source Register
    [0-7]    uns8 des                 //   Destination Register

. . . . . . . . . . . .

my type X:
    X.op code = 5       // This is an initialization block
    X.src1 = 2          // for X in which X is write-only.
    X.src2 = 3
    X.des = 3
uns op = X.op code      // Now op == 5
int d = X.des           // Now d == 3
ap *READ-WRITE* my type @Y =@ local
Y.op code = 129
fp *READ-WRITE* int @C = @Y.constant
ap *READ-WRITE* uns8 @OP = @Y.op code
next op = OP            // Now op == 129
bool B = Y.has constant // Now B == 1
C = -1234               // Now Y.constant = -1234
\end{verbatim}\end{indpar}

In this example there is one field in a {\tt my type} value,
an unlabeled {\tt uns32} integer.
Inside this unlabeled field there are 6 subfields, the first of which is
an {\tt uns8} integer occupying the highest order 8
bits of the unlabeled field, bits 24-31,
where bits are numbered 0, 1, 2, \ldots{} from
low to high order.  The second subfield is a 1-bit {\tt bool}
value that occupies the high order bit, bit 31, of the unlabeled field.
Note that subfields can overlap.

Defined type values are aligned on byte boundaries when
they are stored in memory.  Therefore the `{\tt op code}' subfield
is on a byte boundary, and
the location of {\tt OP} is an {\tt ap} aligned pointer.  Although
the {\tt constant} subfield is on a byte boundary, it is
shorter than an {\tt int}, and therefore the
location of {\tt C} must be an {\tt fp} field pointer.
If `{\tt op code}' where in bits 23-30 instead of 24-31, it would
not be on a byte boundary and the location of {\tt OP} would
also have to be an {\tt fp} field pointer.

Note that `{\tt Y.op code}' is a {\tt *READ-WRITE*}
{\tt uns8} while `{\tt @Y.op code}' is a {\tt co} pointer to
a {\tt *READ-WRITE*} {\tt uns8}.

Note that names in L-Language can have multiple lexemes, as in
the type name `{\tt my type}', the subfield name `{\tt op code}',
and what L-Language calls the
associated member name `{\tt .op code}' which can be used to access
the field.

Another example is:

\begin{indpar}\begin{verbatim}
type my type:
    pack
    uns8    kind             // Object Kind
    [7] bool animal          // True if Animal
    [6] bool vegetable       // True if Vegetable
    flt64   weight           // Object Weight
    align   8
    *LABEL*   extension
    **

type my type:
    *ORIGIN*  extension
    flt64   height           // Object Height
    flt64   width            // Object Width
    **

type my type:
    *ORIGIN*  extension
    flt64   volume           // Object Volume

type your type:
    include my type   // Copy sub-declarations of my type
    dp uns8 name      // Direct pointer to name
                      // character string

. . . . . . . . . . . .

my type X:
    X.kind = BOX
    X.weight = 55
    X.height = 1023
    X.width = 572

your type Y:
    Y.kind = BEER
    Y.weight = 0.45
    Y.volume = 48
    Y.name = "John Doe's Lager"
\end{verbatim}\end{indpar}

Here the definitions of {\tt my type} and {\tt your type} are in
statements called {\em type-declarations}.  Each of these
{\em type-declarations} contains a sequence of sub-declarations, e.g.,
for {\tt my type} the first two sub-declarations are
`{\tt pack}' and `{\tt uns8 kind}'.  There is a current
offset in bytes that starts at {\tt 0} and is updated by each sub-declaration.
A sub-declaration such as `{\tt uns8 kind}' allocates a field
(i.e., {\tt kind})
at the current offset and adds the size of the field to the
current offset.

In the example the fields are {\tt kind}, {\tt weight}, {\tt height}, etc.
Fields can be packed or aligned; aligned is the default.  An aligned number has an offset
that is a multiple of the length of the number.
Here fields are initially packed
so that since {\tt kind} has offset 0 bytes and size 1 byte,
{\tt weight} has offset 1 byte.  Subfields {\tt animal}
and {\tt vegetable} are 1-bit values inside {\tt kind}.

The {\tt align 8} sub-declaration moves the current offset
forward to a 8-byte boundary and causes fields beyond it
to be aligned and not packed.  A number is aligned if
its offset is a multiple of its length.  Alignments must be powers of two.
A defined type has an
alignment equal to the least common multiple (in this case just the
largest) of the
alignments of its aligned fields.

A {\tt *LABEL*} is like a zero length field that has no value and
is used to associate an origin-label with the current offset.
Here {\tt extension} has the offset value of 16 bytes.
The {\tt *ORIGIN*} sub-declaration resets the current offset to the offset
of a given origin-label.

The `{\tt **}' sub-declaration at the end of a
{\em type-declaration} defining a user defined type indicates
that the definition may be continued by a later {\em type-declaration},
as is done for {\tt my\_type} above.
The sub-declarations of the later {\em type-declaration} are
simply appended to those of previous {\em type-declarations}.

The {\tt include} sub-declaration copies all the sub-declarations
from another user defined type.
If the user defined type is
defined by multiple {\em type-declarations}, only sub-declarations
from the {\em type-declarations} in the current scope (see \itemref{SCOPE})
are copied.

Defined types can be extended
(as per the example), and fields can overlay each other.
A defined type value has a size in bytes just large enough to
accommodate all its fields.  If a defined type has multiple
{\em type-declarations}, this size may not be known until load time.

Values of {\tt const} type are compile-time values, and are
not available at run-time.  Number constants consisting of
digits and optional signs, decimal points, and exponents,
are converted to IEEE 64-bit floating point values, as are
special lexemes such as {\tt inf}, {\tt +inf}, {\tt -inf}, and
{\tt nan}.  Other number constants represent
rationals with unbounded integral numerators
and denominators; for example,
{\tt D\#"1/3"} represents the precise rational one-third.
Number constants
can be converted to run-time numbers during compilation.
However it is an compile error
if the result will not fit into the runtime number.
This happens, for example, if either {\tt 1.1} or {\tt 1e20}
is converted to an {\tt int32}.

Quoted strings denote string {\tt const} values that can be
converted during compilation to run-time vectors
with {\tt co} unsigned integer elements that encode the
string in UTF-8, UTF-16, or UTF-32.

Lastly there are map {\tt const} values that can hold lists
and dictionaries.  Map values can be mutable at compile-time,
but cannot be converted to run-time values.

Expressions, statements, and functions that use only {\tt const} values
execute at compile-time and can be used to compute compile-time
{\tt const} values including maps that represent code.

By default, functions in L-Language are inline.  For example,

\begin{indpar}\begin{verbatim}
function int r = max ( int x, int y ):
    if x < y:
        r = y
    else:
        r = x

int x = ...
int y = ...
int z = max ( x, y )
\end{verbatim}\end{indpar}

In general, L-Language does \underline{not} support implicit
conversions.  An exception is: any number or rational constant may be
converted implicitly to any run-time number type as long as
the number constant value can be stored exactly in a variable
of the run-time type.  Builtin operators, such as `{\tt +}',
have the same type of their operands as they have for their
result.\footnote{In these matters L-Language follows Ada.}

For example, given the definition of {\tt max} above:

\begin{indpar}\begin{verbatim}
float w = ...
int x = ...
int y = ...
int z = ...
int r1 = 5 + max ( x, y )          // OK
int r2 = max ( x, max ( y, z ) )   // OK
int r3 = max ( y, w )              // Illegal
int r4 = max ( x, 123 )            // OK
int r5 = max ( x, 123.4 )          // Illegal
const c1 = 100
const c2 = 1000
int r6 = max ( x, c1 + c2 )        // OK
flt64 r7 = 1.1                     // OK
flt32 r8 = 1.1                     // Illegal
    // 1.1 is stored in the compiler as a flt64 and
    // cannot be converted to flt32 without losing
    // precision.
flt32 r8 = 1.125                   // OK
    // 1.125 is stored precisely as a flt64, because
    // it is 9/8 and 8 is a power of 2.
\end{verbatim}\end{indpar}

Explicit conversion functions are provided whose function names
are the same as the type name of their result, as long as
all argument values can be converted result values that reasonably
represent the true argument values.
Examples:

\begin{indpar}\begin{verbatim}
int64 x = ...
flt64 y = ...
int32 z = ...
int64 r1 = int64(z)                // OK
int32 r2 = int32(x)                // Illegal
int64 r3 = int64(y)                // Illegal
flt64 r4 = flt64(x)                // OK; precision may be lost
flt32 r5 = flt32(y)                // OK; precision may be lost;
                                   //     some values may be
                                   //     converted to infinities
\end{verbatim}\end{indpar}

There are functions such as `{\tt round}' that will input a floating
point value and output an integer, though they produce undefined
values and error flags when the floating point number is too large.

It is possible to define compile-time functions:

\begin{indpar}\begin{verbatim}
function const r = max ( const x, const y ):
    if x < y: r = y
    else:     r = x

const x = 2e5
const y = 3e6
const z = 9e4
const w = max ( x, max( y, z ) )  // Legal!
\end{verbatim}\end{indpar}

Such functions are not available at run-time, and
are not really inline, as there is no
distinction between inline and out-of-line for compile-time functions.

Inline function definitions may make use of type wildcards.
A name that is a single word beginning with {\tt T\$}
is a type wildcard that denotes
an arbitrary type.  Thus the example:

\begin{indpar}\begin{verbatim}
function T$r r = max ( T$r x, T$r y ):
    if x < y: r = y
    else:     r = x

const x = 2e5
int y = 27e4
int z = max ( x, y )      // T$r is int, x converts to int.
const w = 34e4
const v = max ( x, w )    // T$r is const, all values are const.
\end{verbatim}\end{indpar}

A wildcard type of a result variable gets its value from the
type of the result variable in a function call.  The exception
is {\tt const}, which can be a wildcard type in a function
definition if and only if all type wildcards in the function definition
are assigned the value {\tt const} and doing so makes
all types in the function definition be {\tt const}
(except for types that are not used as types, but are used as
{\tt const} values, as in `{\tt int..size}').

Pointer types can be wildcards which must have names that are
single words beginning with {\tt P\$}.  A list of qualifiers
can also be a wild card named by a single word beginning with
{\tt Q\$}.  An example is:

\begin{indpar}\begin{verbatim}
function uns r = strlen ( P$s Q$s uns8 s ):
    dp ro uns8 sdp = s
    r = call "strlen" ( sdp )
\end{verbatim}\end{indpar}

which converts the pointer of type {\tt P\$s} to a pointer of
type {\tt dp} (direct pointer) and calls the `foreign' C programming
language subroutine {\tt strlen} with the direct pointer.
For some pointer types (e.g., field pointer types),
the pointer conversion may be illegal.

L-Language does not necessarily make any use of registers, other
than as temporaries during the execution of a single statement,
and a pair of registers that hold the current function
execution frame address and current module data address.
However, registers can be used to cache data that exists in
RAM memory, or that should exist in RAM memory but does not
due to optimization.  We call such registers
\skey{software cach}{es}.

Software caches of a RAM memory location are flushed when an out-of-line
function is called if the location does not have the {\tt co} qualifier.
Attaching the {\tt *VOLATILE*} qualifier to a location
flushes software caches of the location between statements.

A pointer type
has two places where a qualifier may appear, as in

\begin{indpar}\begin{verbatim}
type my control block:
    co ap *VOLATILE* uns32 @cr
    ....
\end{verbatim}\end{indpar}
in which {\tt @cr} is a constant pointing at a volatile
{\tt uns32} location {\tt cr}.

Pointer types cannot be cascaded, but there is a work-around
using defined types:
\begin{indpar}\begin{verbatim}
ap av flt64 p = .....         // Illegal!

struct my pointer
    av flt64 p

. . . . . . . . . .

ap my pointer @q = ...        // OK
flt64 v = q.p[0]              // OK
\end{verbatim}\end{indpar}

Any inline function can create new code that is inserted
after the statement containing a call to the function.
The code is expressed as a {\tt const} map value in
the format output by the code parser.  As a simple
example, if the inline function contains:
\begin{indpar}\begin{verbatim}
const T = my number
const V = my variable
include (T, V):
    T V = x + y
    T z = max ( V, 1000 )
\end{verbatim}\end{indpar}
then a statement calling the inline function will be
followed by the code:
\begin{indpar}\begin{verbatim}
my number my variable = x + y
my number z = max ( my variable, 1000 )
\end{verbatim}\end{indpar}
which the parser renders as the {\tt const} map value:
\begin{indpar}\begin{verbatim}
{ { { "my", "number", "my", "variable" }, "=",
    { { "x" }, "+", { "y" } } },
  { { "my", "number", "z" }, "=",
    { "max", { { "my", "variable" }, { "1000" },
               .initiator => "(",
               .separator => ",",
               .terminator =? ")" } } } }
\end{verbatim}\end{indpar}

Code to be inserted can also be computed directly as a {\tt const} map
value without using `{\tt include}' statements.




\section{Syntax}

In this section we describe the syntax of L-Language programs
and briefly indicate the associated semantics, which is
described in detail in later sections.

\subsection{Lexemes}
\label{LEXEMES}

A L-Language source file is a sequence of bytes that is a UTF-8 encoding
of a sequence of UNICODE characters.  This is scanned into a sequence
of \skey{lexeme}s.

Unless otherwise specified, the term `\key{character}' in this
document means a 32-bit UNICODE character.

Lexemes are defined in terms of
the following character classes:

\begin{indpar}
\emkey{horizontal-space-character}
    \begin{tabular}[t]{rl}
    :::= & characters in UNICODE category \TT{Zs} \\
         & (includes {\em ASCII-single-space}) \\
    $|$  & {\em horizontal-tab-character}
    \end{tabular}
\\
\emkey{vertical-space-character}
    \begin{tabular}[t]{rl}
    :::= & {\em line-feed} $|$ {\em carriage-return} \\
    $|$ & {\em form-feed} $|$ {\em vertical-tab}
    \end{tabular}
\\
\emkey{space-character} :::= {\em horizontal-space-character}
                        $|$ {\em vertical-space-character}
\\[1ex]
\emkey{graphic-character} :::= characters in UNICODE categories
                              \TT{L}, \TT{M}, \TT{N}, \TT{P}, and \TT{S}
\\
\emkey{control-character} :::=
	characters in UNICODE categories \TT{C} and \TT{Z}
\\[1ex]
\emkey{isolated-separating-character} :::= \\
\hspace*{0.5in}
    \begin{tabular}[t]{l}
    characters in UNICODE categories \TT{Ps}, \TT{Pi}, \TT{Pe},
    and \TT{Pf}; \\
    includes \TT{\{ ( [ << >> ] ) \}}
    \end{tabular}
\\
\emkey{separating-character} :::= \TT{|} $|$ {\em isolated-separating-character}
\\[1ex]
\emkey{leading-separator-character} :::=
	\TT{`} $|$ \TT{\textexclamdown} $|$ \TT{\textquestiondown}
\\
\emkey{trailing-separator-character} :::=
	\TT{'} $|$ \TT{!} $|$ \TT{?} $|$ \TT{.} $|$ \TT{:}
	       $|$ \TT{,} $|$ \TT{;}
\\[1ex]
\emkey{quoting-character} :::= \TT{"}
\\[1ex]
\emkey{letter} :::=
    characters in UNICODE category \TT{L}
\\
\emkey{ASCII-digit} :::= \TT{0} $|$ \TT{1} $|$ \TT{2} $|$ \TT{3} $|$ \TT{4}
                     $|$ \TT{5} $|$ \TT{6} $|$ \TT{7} $|$ \TT{8} $|$ \TT{9}
\\
\emkey{digit} :::=
    characters in UNICODE category \TT{Nd}
    (includes {\em ASCII-digits})
\\
\emkey{lexical-item-character} :::=
	\begin{tabular}[t]{l}
        {\em graphic-character} other than \\
	{\em separating-character} or \TT{"}
	\end{tabular}
\end{indpar}

Comments may be placed at the ends of lines:
\begin{indpar}
\emkey{comment}\label{COMMENT} :::=
    \TT{//} {\em comment-character}\,$^\star$
\\[1ex]
\emkey{comment-character} :::= {\em graphic-character}
                          $|$ {\em horizontal-space-character}
\end{indpar}

Lexemes may be separated by {\em white-space}, which
is a sequence of {\em space-characters},
but, with some exceptions mentioned just below, is not itself a lexeme:
\begin{indpar}
\emkey{white-space} :::= {\em space-character}\PLUS{}
\\[0.3ex]
\emkey{horizontal-space} :::= {\em horizontal-space-character}\PLUS{}
\\[0.3ex]
\emkey{vertical-space} :::= {\em vertical-space-character}\PLUS{}
\end{indpar}

The following is a special virtual lexeme:
\begin{indpar}
\emkey{indent}\label{INDENT} ::=
        virtual lexeme inserted just before the first
	{\em graphic-character} on a line
\end{indpar}

\key{Indent lexemes} have no characters, but
do have an \key{indent}, which is the indent of
the graphic character after the indent lexeme.
The \key{indent} of a character is the number
of columns that precede the character in the character's physical line.
{\em Control-characters} other than {\em horizontal-space-characters}
take zero columns, as do characters of classes \TT{Mn} (combining-marks)
and \TT{Me} (ending marks).  All other characters take one column,
except for tabs, that are set every 8 columns.
Indent lexemes are used to form logical lines and blocks
(\itemref{LOGICAL-LINES-BLOCKS-AND-STATEMENTS}).

One kind of {\em vertical-space} is given special distinction:
\begin{indpar}
\emkey{line-break}\label{LINE-BREAK} ::=
	\begin{tabular}[t]{l}
        {\em vertical-space} containing exactly one {\em line-feed}
	\end{tabular}
\end{indpar}

This is the {\em line-break} lexeme.

Non-{\em indent}, non-{\em line-break} {\em white-space}, such as occurs
in the middle of text or code outside comments, is discarded and not treated
as a lexeme.  Such {\em white-space} may be used to separate lexemes.

{\em Horizontal-\EOL space-\EOL characters}\label{ILLEGAL-CHARACTERS}
other than single
space are illegal inside {\em quoted-string} lexemes (defined below).
{\em Vertical-space} that has \underline{no} {\em line-feeds} is
illegal (see below).
{\em Control-characters} not in {\em white-space} are illegal.
Characters that have no UNICODE category are {\em unrecognized-characters}
and are illegal:
\begin{indpar}
\emkey{misplaced-horizontal-space-character} :::= \\
\hspace*{0.5in}
    {\em horizontal-space-character}, other than ASCII-single-space
\\[0.3ex]
\emkey{misplaced-vertical-space-character} :::= \\
\hspace*{0.5in}{\em vertical-space-character} other than {\em line-feed}
\\[0.3ex]
\emkey{illegal-control-character} :::= \\
\hspace*{0.5in}
    \begin{tabular}[t]{l}
    {\em control-character},
    but \underline{not} a {\em horizontal-space-character} or \\
    {\em vertical-space-character}
    \end{tabular}
\\[0.3ex]
\emkey{unrecognized-character} :::= \\
\hspace*{0.5in}
    \begin{tabular}[t]{l}
    character with no UNICODE category or \\
    with a category other than
    \TT{L}, \TT{M}, \TT{N}, \TT{P}, \TT{S}, \TT{C}, or \TT{Z}
    \end{tabular}
\end{indpar}

Sequences of these characters generate warning messages,
but are otherwise like {\em horizontal-space}:
\begin{indpar}
\emkey{misplaced-horizontal} :::=
    {\em misplaced-horizontal-space-character}\PLUS{}
\\[0.3ex]
\emkey{misplaced-vertical} :::=
    {\em misplaced-vertical-space-character}\PLUS{}
\\[0.3ex]
\emkey{illegal-control} :::= {\em illegal-control-character}\PLUS{}
\\[0.3ex]
\emkey{unrecognized} :::= {\em unrecognized-character}\PLUS{}
\end{indpar}

{\em Misplaced-horizontal} only exists inside a {\em quoted-string},
but the other three sequences can appear anywhere.  When they occur,
these sequences generate warning messages, but otherwise they behave
like {\em horizontal-space}.  Specifically, outside {\em quoted-strings}
and {\em comments} these sequences can be used to separate other lexemes,
just as {\em horizontal-space} can be used,
whereas inside {\em quoted-strings} and
{\em comments} these sequences do nothing aside from generating
warning messages.

\begin{boxedfigure}[!p]

\emkey{lexeme}
        \begin{tabular}[t]{rl}
	::= & {\em numeric-word} $|$ {\em word} $|$
	      {\em natural} $|$ {\em number} $|$ {\em numeric} \\
	$|$ & {\em mark} $|$ {\em separator} $|$ {\em quoted-string} \\
	$|$ & {\em indent} $|${\em line-break} $|$
	      {\em comment} $|$ {\em end-of-file}
	\end{tabular}
\label{LEXEME}
\\[1ex]
\emkey{strict-separator} :::= {\em isolated-separating-character} $|$
                              \TT{|}\PLUS{}
\\[0.5ex]
\emkey{leading-separator} :::=
	\TT{`}\PLUS{} $|$ 
	\TT{\textexclamdown}\PLUS{} $|$ \TT{\textquestiondown}\PLUS{}
\\[0.5ex]
\emkey{trailing-separator} :::= \TT{'}\PLUS{} $|$
				   \TT{!}\PLUS{} $|$
				   \TT{?}\PLUS{} $|$
				   \TT{.}\PLUS{} $|$
				   \TT{:}\PLUS{} $|$
				   \TT{;} $|$
				   \TT{,}
\\[0.5ex]
\emkey{separator}
    ::= {\em strict-separator} 
    $|$ {\em leading-separator}
    $|$ {\em trailing-separator}
\\[1ex]
\emkey{quoted-string}\label{QUOTED-STRING} :::=
    \TT{"} {\em character-representative}\,\STAR{} \TT{"}
\\[0.3ex]
\emkey{character-representative}\label{CHARACTER-REPRESENTATIVE}
	\begin{tabular}[t]{@{}rl@{}}
	::= & {\em graphic-character} other than \TT{"} \\
	$|$ & {\em ASCII-single-space-character} \\
	$|$ & {\em special-character-representative} \\
	\end{tabular}
\\[0.3ex]
\emkey{special-character-representative} :::=
    \TT{<} \{ {\em upper-case-letter} $|$ {\em digit} \}\PLUS{} \TT{>}
\\[1ex]
\emkey{lexical-item} :::= {\em lexical-item-character}\PLUS{}
                       not beginning with \TT{//}
\\[0.5ex]
\emkey{lexical-item} :::= {\em leading-separator}\STAR{}
			  {\em middle-lexeme}\QMARK{}
                          {\em trailing-separator}\STAR{}
\\[0.5ex]
\emkey{middle-lexeme} :::= 
	{\em lexical-item}
	\begin{tabular}[t]{@{}l@{}}
	not beginning with a {\em leading-separator-character} \\
	or ending with a {\em trailing-separator-character} \\
	\end{tabular}
\\[0.5ex]
\emkey{numeric-word} :::= {\em sign}\QMARK{} \ttkey{nan}
                      $|$ {\em sign}\QMARK{} \ttkey{inf}
		      ~~~~~
		      [where {\em letters} are \underline{case insensitive}]
\\[0.5ex]
\emkey{word} :::= {\em middle-lexeme}
                  \begin{tabular}[t]{@{}l@{}}
		  that contains a {\em letter} before any {\em digit} \\
		  and is not a {\em numeric-word}
		  \end{tabular}
\\[0.5ex]
\emkey{natural}\label{NATURAL}
	\begin{tabular}[t]{@{}rl@{}}
	:::= & {\em decimal-digit}\PLUS{} not beginning with \TT{0} $|$
	       \TT{0} \\
	\multicolumn{2}{l}{[but lexical type may be changed;
	                    see \pagref{LEXEME-TYPE-CONVERSION}]} \\
	\end{tabular}
\\[0.5ex]
\emkey{number}\label{NUMBER}
	\begin{tabular}[t]{@{}rl@{}}
	:::= & {\em sign}\QMARK{} {\em integer-part}
	                          {\em exponent-part}\QMARK{}
	     [that is not a {\em natural}] \\
	 $|$ & {\em sign}\QMARK{} {\em integer-part}\QMARK{}
	                          {\em fraction-part}
				  {\em exponent-part}\QMARK{} \\
	\multicolumn{2}{l}{[but lexical type may be changed;
	                    see \pagref{LEXEME-TYPE-CONVERSION}]} \\
	\end{tabular}
\\[0.5ex]
\emkey{numeric} :::= {\em middle-lexeme}
                  \begin{tabular}[t]{@{}l@{}}
		  that contains a {\em digit} before any {\em letter} \\
		  and is not a {\em natural} or {\em number}
		  \end{tabular}
\\[0.5ex]
\emkey{integer-part} :::= {\em decimal-digit}\PLUS{}
\\[0.5ex]
\emkey{fraction-part} :::= \TT{.} {\em decimal-digit}\PLUS{}
\\[0.5ex]
\emkey{exponent-part} :::= {\em exponent-indicator} {\em sign}\QMARK{}
                           {\em decimal-digit}\PLUS{}
\\[0.5ex]
\begin{tabular}[t]{@{}l@{\hspace{1in}}l@{}}
\emkey{sign} :::= \TT{+} $|$ \TT{-}
&
\emkey{exponent-indicator} :::= \TT{e} $|$ \TT{E}
\end{tabular}
\\[0.5ex]
\emkey{mark}\label{MARK} :::= {\em middle-lexeme} not containing a
                              {\em letter} or a {\em digit}
\\[0.5ex]
\begin{tabular}[t]{@{}l@{\hspace{1in}}l@{}}
{\em indent} ::= see \pagref{INDENT}
&
{\em line-break} ::= see \pagref{LINE-BREAK}
\\[0.5ex]
{\em comment} ::= see \pagref{COMMENT}
&
{\em end-of-file} ::= see \pagref{END-OF-FILE}
\end{tabular}


\caption{L Language Program Lexemes}
\label{L-LANGUAGE-PROGRAM-LEXEMES}
\end{boxedfigure}


The lexemes in a L-Language program are specified in
Figure~\itemref{L-LANGUAGE-PROGRAM-LEXEMES}.  This specification assumes there
are no illegal characters in the input; see text
above to account for such characters.

The symbol `\ttkey{:::=}' is used in syntax equations
that define lexemes or parts of lexemes whose syntactic elements are
character sequences that must \underline{not} be separated by {\em white-space}.
The symbol `\ttkey{::=}'
is used in syntax equations that define sequences of lexemes that may
and sometimes must be separated by {\em white-space}.

There is a special \emkey{end-of-file}\label{END-OF-FILE}
lexeme that occurs only at the end of a file.

Files are scanned into sequences of lexemes which are then divided
into logical lines as per \itemref{LOGICAL-LINES-BLOCKS-AND-STATEMENTS}.
After each logical line is formed,
{\em indent}, {\em comment},
{\em line-break}, and {\em end-of-file} lexemes are deleted
from the logical line.

A \emkey{special-character-representative} can consist of
a UNICODE character name surrounded by angle brackets.  Examples are
\TT{<NUL>}, \TT{<LF>}, \TT{<SP>}, \TT{<NBSP>}.  There are three other cases:
\tttkey{Q} represents the doublequote \TT{"}, \tttkey{NL} (new line)
represents a line feed (same as \TT{<LF>}), and \tttkey{UUC} represents
the `\key{unknown UNICODE character}' which in turn is used to represent
illegal UTF-8 character encodings.

A {\em special-character-representative} can also consist of
a hexadecimal UNICODE character code, which must begin with a digit.
Thus \TT{<0FF>} represents \TT{\"y} whereas \TT{<FF>} represents
a form feed.

\key{Quoted string lexemes}
\label{QUOTED-STRING-CONCATENATION}
separated by the `\TT{\#}' mark
are glued together if they are in the
same logical line.  Thus
\begin{indpar}\begin{verbatim}
"This is a longer sentence" #
    " than we would like."
"And this is a second sentence."
\end{verbatim}\end{indpar}
is equivalent to
\begin{indpar}\begin{verbatim}
"This is a longer sentence than we would like."
"And this is a second sentence."
\end{verbatim}\end{indpar}
This is useful for
breaking long quoted string lexemes across line continuations.
But there is an important case where there is not an exact equivalence
between the glued and unglued versions.  \TT{"<" \# "LF" \# ">"} is
\underline{not} equivalent to \TT{"<LF>"}.  The former is a 4-character
quoted string, the characters being \TT{<}, \TT{L}, \TT{F},
and \TT{>}.  The latter is a 1-character quoted string, the character
being a line feed.

The definition of a \key{middle-lexeme} is unusual: it is what is left over
after removing {\em leading-separators} and {\em trailing-separators}
from a {\em lexical-item}.  The lexical scan first scans a
{\em lexical-item}, and then removes
{\em leading-separators} and {\em trailing-separators} from it.
Also {\em trailing-separators} are removed
from the end of a {\em lexical-item} by a right-to-left scan, and not
the usual left-to-right scan which is used for everything else.
Thus the {\em lexical-item}
`\TT{\textquestiondown 4,987?,{},::}' yields the
{\em leading-separator} `\TT{\textquestiondown}',
the {\em middle-lexeme} `\TT{4,987}',
and the four {\em trailing-separators} `\TT{?}',
`\TT{,}' `\TT{,}' and `\TT{::}'.

{\em Words}, {\em numerics}, and {\em marks}
in the same logical line are glued together if the first
ends with `\TT{\#}' and the second begins with `\TT{\#}'.
Thus
\begin{indpar}\begin{verbatim}
This is a continued-#
    #middle# #-lexeme.
\end{verbatim}\end{indpar}
is equivalent to
\begin{indpar}\begin{verbatim}
This is a continued-middle-lexeme.
\end{verbatim}\end{indpar}
For compatibility, two consecutive `\TT{\#}' marks may be used
to glue together two quoted strings, as in
\begin{indpar}\begin{verbatim}
"This is a continued-"#
    #"quoted"# #"-string".
\end{verbatim}\end{indpar}
which is equivalent to
\begin{indpar}\begin{verbatim}
"This is a continued-quoted-string".
\end{verbatim}\end{indpar}


A {\em numeric-word}, {\em natural}, or {\em number} lexeme
is a C/C++ constant, and 
conversely a C/C++ constant representing decimal number
and not ending in a {\em decimal-point} or representing an
IEEE floating point special value (e.g., {\tt NaN} or {\tt Inf})
is a {\em numeric-word}, {\em natural}, or {\em number} lexeme.
All these lexemes are given an IEEE double precision number value
after the manner of C/C++, and then their lexical type is changed
as follows:
\begin{itemize}\label{LEXEME-TYPE-CONVERSION}
\item If the value is \underline{not} a finite number, the
new type is {\em numeric-word}.  For example, this applies to {\tt 1e500}
which converts to the same value as {\tt +inf}.
\item If the value is an integer in the range $[0,10^{15})$ the new
type is {\em natural}.
For example, this applies to {\tt 1e3}
which converts to the same value as {\tt 1000}.
\item Otherwise the new type is {\em number}.
For example, this applies to {\tt 10000000000}
which converts to the same value as {\tt 1e10}.
\end{itemize}

In contrast, a {\em numeric} represents a character string and in this
is like a {\em word}.

\subsection{Logical Lines, Blocks, and Statements}
\label{LOGICAL-LINES-BLOCKS-AND-STATEMENTS}

Each non-blank physical line begins with an {\em indent} lexeme
that is followed by a
lexeme that is not an {\em indent}, {\em line-break}, or
{\em end-of-file}.

Lexemes are organized into \skey{logical line}s.  A logical line
begins immediately after an {\em indent} lexeme, and the
\key{indent} of the logical line is the
indent of this {\em indent} lexeme (i.e., the indent of the
first graphic character of the logical line).

A logical line ends with the next {\em indent} lexeme whose indent
is not greater than the indent of the logical line, or with an
{\em end-of-file}.  Thus physical
lines with indent greater than that of the current logical line
are \skey{continuation line}s for that logical line.

A code file is a sequence of `\key{top level}' logical lines that
are required to have indent \TT{0}.

A logical line may end with a \key{block} that is itself a sequence of
logical lines that have indents greater than the indent of the
logical line containing the block.
The block is introduced by a `\TT{:}' at the end
of a physical line, provided the `\TT{:}' is not inside brackets
or quotes
(e.g., not inside \TT{(~)} or \TT{`~'}).
If the first {\em indent} lexeme after the
`\TT{:}' has an indent that is \underline{not} greater than the indent
of the logical line containing the `\TT{:}', the block is empty.
Otherwise the indent of this {\em indent} lexeme becomes the
\key{indent} of the block and the indent of all the
logical lines in the block.  The first logical line of the block
starts immediately after this {\em indent} lexeme.
The block ends just before the first
logical line with lesser indent than the block indent, or the end of file.
More specifically, the last logical line of the block ends with an
{\em indent} whose indent is less than the block indent, or with an
{\em end-of-file}.

Examples are:
\begin{indpar}\begin{verbatim}
this is a top level logical line ending with a block:
    this is the first line of the block
    this is the
         second line of the block
    this is the third line of the block:
        this is the first line of a subblock
        this is the second line
                of the subblock:
            this is the only line of a sub-subblock
        this is the third line of the subblock
    this is the fourth line
            of the block:
        this is the only line of the second subblock
    this is the fifth line of the block
         and it ends with an empty subblock:
this is the second top level
     logical line
\end{verbatim}\end{indpar}

A warning message is output if two indents that are being compared
differ by more than \TT{0} and
less than \TT{2} columns, in order to better detect
indentation mistakes.

{\em Line-break} lexemes are effectively ignored.  A sequence
of {\em line-break} lexemes is followed by an {\em indent}
or {\em end-of-file} which is not ignored.
Blank physical lines are represented by sequences of
more than one {\em line-break} lexeme, and are effectively
ignored.

A logical line that contains {\em comments}, but no
lexemes other than {\em comments}, {\em line-breaks}, {\em indents}
and a possible {\em end-of-file}, is
a `\key{comment line}'.

It is an error to begin non-comment logical lines with
a {\em comment}.
{\em Comments} can be used freely in the middle of or at the
end of any logical line, or at the beginning of a comment line.

It is an error for the first logical line of a file
to have an indent that is greater than \TT{0}, the top level
indent.

It is an error for a block to be in the middle of a logical
line.  This means that the first {\em indent} following the
block must have an indent no greater than that of the logical
line containing the block.

Examples are:
\begin{indpar}\begin{verbatim}
// this is a logical line that is a single comment

// this is a logical line that has two
    // comments

this is a logical line // with a comment
     // and another comment
     with three comments // and a last comment

this is a logical line ending with a block:
     First line of the block
     Second line of the block
// Comment that ends block
// Comment that is in error because
    it begins a logical line that this continues

this is a logical line with a block:
     First line of the block
     Second line of the block
  but the block is in error because it is before
  this continuation of the logical line that contains
  the block

this is a logical line ending with a block:
        First line of the block
        Second line of the block
  // comments that end the block, but are in error,
  // because they continue the logical line
  // containing the block
\end{verbatim}\end{indpar}

After a logical line
has been formed, any {\em indent},
{\em comment}, {\em line-break}, and {\em end-of-file}
lexemes in the logical line
are removed from the logical line.  If the result is
empty, e.g., the logical line is a comment line, it is discarded.
Otherwise the
modified logical line becomes a L-Language `\emkey{statement}'.

Therefore a file is a sequence of top-level statements.

Since a logical line can end with a block that itself consists
of a sequence of logical lines, a statement can end with
a block that itself consists of a sequence of statements.

\newpage

\subsection{Expressions}

Expressions are built from operators, such as \TT{+} and \TT{*},
and primaries, such as variable names and function calls.

Operators are characterized by fixity, precedence, and format.
The L-Language operators are listed in
Figures~\itemref{L-LANGUAGE-LINE-OPERATORS}
and~\itemref{L-LANGUAGE-NON-LINE-OPERATORS}.


Given this, expressions have the following syntax,
where an {\em P-expression}
is an expression all of whose operators that are outside brackets
have precedence equal to or greater than P:

\begin{indpar}\begin{minipage}{6in}
\emkey{expression}\label{EXPRESSION} ::= {\em L-expression}
\\[0.5ex]
\emkey{P-expression}
    \begin{tabular}[t]{@{}rl}
    ::= & \{ {\em (P+1)-expression} $|$ {\em P-operator)} \}\PLUS{} \\
        & where no two {\em (P+1)-expressions} may be adjacent \\ 
        & and the {\em P-operators} must obey the fixity rules below \\
    \end{tabular}
\\[0.5ex]
\emkey{P-operator} ::= operator of precedence P
\\[0.5ex]
\emkey{(H+2)-expression} ::= {\em primary}
\\[0.5ex]
\emkey{primary} ::= {\em primary-element}\PLUS{} ~~~~~ [see \pagref{PRIMARIES}]
\\[0.5ex]
\emkey{primary-element} ::= {\em non-operator-lexeme} $|$
                            {\em bracketted-subexpression}
\\[2.0ex]
\hspace*{3em}\begin{tabular}{l}
where P is any precedence in the range [L,H+1]
\end{tabular}
\end{minipage}\end{indpar}


Generally
a {\em P-expression} consists of a sequence of {\em (P+1)-expressions}
separated by operators of precedence $P$.

The operators can have any combination of the following \key{base fixities}:

\begin{center}
\begin{tabular}{lp{5.0in}}
\ttkey{initial}	& {\em P-operator} must be the first thing
                  in its {\em P-expression}. \\
\ttkey{final}	& {\em P-operator} must be the last thing
                  in its {\em P-expression}. \\
\ttkey{left}	& {\em P-operator} must be immediately
                  preceded by a {\em (P+1)-expression}
                  in its {\em P-expression}. \\
\ttkey{right}	& {\em P-operator} must be immediately
                  followed by a {\em (P+1)-expression}
                  in its {\em P-expression}. \\
\ttkey{afix}	& {\em P-operator} must be after a (not necessarily
                  immediately) preceding {\em P-operator}
                  in its {\em P-expression}. \\
\end{tabular}
\end{center}

The following \key{combination fixities} are defined:

\begin{center}
\begin{tabular}{ll}
\ttkey{prefix}	& {\tt initial} + {\tt right} \\
\ttkey{infix}	& {\tt left} + {\tt right} \\
\ttkey{postfix}	& {\tt left} + {\tt final} \\
\ttkey{nofix}	& none of {\tt initial}, {\tt final}, {\tt left},
                  or {\tt right} \\
\end{tabular}
\end{center}

All of these but {\tt initial} and {\tt prefix} can be combined with {\tt afix}.

\newpage

\begin{boxedfigure}[!t]
\begin{center}
Line Level Operators \\
Must Occur Outside Parentheses and Brackets
\\[1ex]
\begin{tabular}{|l|l|l|l|r|}
\hline
Operator & Meaning & Fixity & Format & Precedence \\
\hline
\ttkey{if} & conditional & prefix & conditional & 0000
\\\cline{1-1}
\ttkey{else if} & & & &
\\\cline{1-2}
\ttkey{while} & loop & & &
\\\cline{1-1}
\ttkey{until} & & & &
\\\cline{1-4}
\ttkey{else} & terminating & initial & terminating & \\
             & conditional & & conditional &
\\\cline{1-4}
\ttkey{:} operator & conditional & afix & (none) & \\
                   & completion & right & &
\\\cline{1-1}\cline{3-3}
\ttkey{:} indentation & & afix & & \\
~~mark                & & postfix & &
\\\hline
\ttkey{=} & assignment & infix & binary & 1000
\\\cline{1-2}
\ttkey{+=} & increment & & &
\\\cline{1-2}
\ttkey{-=} & decrement & & &
\\\cline{1-2}
\ttkey{*=} & multiply by & & &
\\\cline{1-2}
\ttkey{/=} & divide by & & &
\\\cline{1-2}
\ttkey{|=} & include & & &
\\\cline{1-2}
\ttkey{\&=} & mask & & &
\\\cline{1-2}
\ttkey{\textasciicircum=} & flip & & &
\\\cline{1-2}
\ttkey{<{}<=} & shift left & & &
\\\cline{1-2}
\ttkey{>{}>=} & shift right & & &
\\\hline
\end{tabular}
\end{center}

\caption{L-Language Line Operators}
\label{L-LANGUAGE-LINE-OPERATORS}
\end{boxedfigure}

\begin{boxedfigure}[!t]
\begin{center}
Non-Line Level Operators \\
May Occur Inside or Outside Parentheses and Brackets
\\[1ex]
\begin{tabular}{|l|l|l|l|r|}
\hline
Operator & Meaning & Fixity & Format & Precedence \\
\hline
\ttkey{,} & separator & nofix & separator & 2000
\\\hline
\ttkey{if} & selector & infix & selector & 3000
\\\cline{1-1}\cline{3-4}
\ttkey{else} & & infix & (none) & \\
             & & afix & &
\\\hline
\ttkey{BUT NOT} & logical and not & infix & binary & 4000
\\\hline
\ttkey{AND} & logical and & infix & n-ary & 4100
\\\cline{1-2}
\ttkey{OR}  & logical or  & & &
\\\hline
\ttkey{NOT}  & logical not & prefix & unary & 4200
\\\hline
\ttkey{==}  & equal & infix & (none) & 5000
\\\cline{1-2}
\ttkey{!=}  & not equal & & &
\\\cline{1-2}
\ttkey{<}  & less than & & &
\\\cline{1-2}
\ttkey{<=}  & less than or equal & & &
\\\cline{1-2}
\ttkey{>}  & greater than & & &
\\\cline{1-2}
\ttkey{>=}  & greater than or equal & & &
\\\hline
\ttkey{+}  & addition & infix & sum & 6000
\\\cline{1-2}
\ttkey{-}  & subtraction & & &
\\\cline{1-2}\cline{4-4}
\ttkey{|}  & bitwise or & & n-ary &
\\\cline{1-2}
\ttkey{\&}  & bitwise and & & &
\\\cline{1-2}
\ttkey{\textasciicircum}  & bitwise xor & & &
\\\hline
\ttkey{/}  & division & infix & binary & 6100
\\\cline{1-2}\cline{4-5}
\ttkey{*}  & multiplication & & n-ary & 6200
\\\cline{1-2}\cline{4-5}
\ttkey{**}  & exponentiation & & binary & 6300
\\\hline
\ttkey{<{}<}  & left shift & infix & binary & 6400
\\\cline{1-2}
\ttkey{>{}>}  & right shift & & &
\\\hline
\ttkey{+}  & no-op & prefix & unary & H
\\\cline{1-2}
\ttkey{-}  & negation & & & 
\\\cline{1-2}
\ttkey{\textasciitilde}  & bitwise complement & & & 
\\\hline

\end{tabular}
\end{center}

\caption{L-Language Non-Line Operators}
\label{L-LANGUAGE-NON-LINE-OPERATORS}
\end{boxedfigure}

\clearpage

The operators in
Figures~\itemref{L-LANGUAGE-LINE-OPERATORS}
and~\itemref{L-LANGUAGE-NON-LINE-OPERATORS}
have precedences in
the range {\em [L,H]}.
Precedence {\em (H+1)} is reserved for the `error operator' which is a
nofix operator inserted by the parser to `fix up' parsing errors
so parsing can continue.

The first {\em P-operator} in a {\em P-expression} determines
the {\em P-expression}'s \key{format}, which is one of the following,
where in describing expressions we use:
\begin{center}
`expression' to mean {\em P-expression}, \\
`operator' to mean {\em P-operator}, \\
and `operand' to mean {\em (P+1)-expression}:
\end{center}
\begin{center}
\begin{tabular}{p{1in}p{5.0in}}
\ttkey{conditional}
    & The expression must consist of the operator followed by an
      operand followed by either a \TT{:} operator and an
      operand or by just a \TT{:} indented paragraph.
\\[1ex]
\ttkey{\begin{tabular}[t]{@{}l@{}}terminating\\conditional\end{tabular}}
    & The expression must consist of the operator followed by
      either a \TT{:} operator and an
      operand or by just a \TT{:} indented paragraph.
\end{tabular}
\\[0.5ex]
\begin{tabular}{p{1in}p{5.0in}}
\ttkey{selector}
    & The expression operators must all be either \TT{if} or \TT{else}.
      The expression must consist of alternating operands
      and operators and begin and end with an operand.
      The two possible operators alternate, with \TT{if} first.
\end{tabular}
\\[0.5ex]
\begin{tabular}{p{1in}p{5.0in}}
\ttkey{binary}
    & The expression must consist of an operand followed by
      the operator followed by an operand.  There must be only one
      operator in the expression.
\end{tabular}
\\[0.5ex]
\begin{tabular}{p{1in}p{5.0in}}
\ttkey{separator}
    & All operators in the expression must be identical.
      There are no other constraints on the expression.  An implied empty
      operand is inserted between two consecutive operators,
      at the beginning if the expression begins with an operator,
      and at the end if the expression ends with an operator.
      Then the operators are deleted from the expression and
      the expression operator is attached
      to the expression as its \TT{.separator} attribute.
\end{tabular}
\\[0.5ex]
\begin{tabular}{p{1in}p{5.0in}}
\ttkey{n-ary}
    & All operators in the expression must be identical.
      The expression must consist of alternating operands
      and operators and begin and end with an operand.
\\[1ex]
\ttkey{unary}
    & The expression must consist of
      the operator followed by an operand.
\end{tabular}
\\[0.5ex]
\begin{tabular}{p{1in}p{5.0in}}
\ttkey{sum}
    & The expression operators must all be either \TT{+} or \TT{-}.
      The expression must consist of alternating operands
      and operators and end with an operand (it may begin with
      an operator).
      Each subsequence of the form `\TT{-} operand' is
      replaced by `\TT{+} \TT{\{|} \TT{-} operand \TT{|\}}', and then
      any \TT{+} at the beginning of the expression is deleted.
\end{tabular}
\end{center}

There are a few additional special syntactic rules:
\begin{enumerate}
\item Non-line bitwise operators (\TT{|}, \TT{\&}, \TT{\textasciicircum},
\TT{<{}<}, \TT{>{}>}, and \TT{\textasciitilde}) cannot be mixed
with non-line arithmetic operators
(\TT{+}, \TT{-}, \TT{/}, \TT{*}, and \TT{**})
outside parentheses in a subexpression.
E.g., `{\tt x + (y * \textasciitilde z)}'
is illegal but `{\tt x + (y * (\textasciitilde z))}' is legal.
\end{enumerate}


Full semantics of operators and expressions is described later,
but the following examples give an idea of some of this semantics:

\begin{indpar}
\hspace*{-0.2in}{\tt T v \TT{=} x + y * z} \\
       Here {\tt T} is the \key{result type} of the expression
       `{\tt x + y * z}'.  Because it is the result type of {\tt +} and
       arithmetic operators (with a few exceptions)
       have operands that are of the same
       type as their result, {\tt T} is also result type of {\tt *}, and
       since L-Language does not have implicit conversion (except for
       constant numbers), {\tt T} must be
       the type of {\tt x}, {\tt y}, and {\tt z}.

\hspace*{-0.2in}{\tt T v \TT{=} x \TT{if} y \TT{else} z} \\
      Evaluates {\tt y} with result type {\tt bool}.  If that value
      is {\tt true}, evaluates and returns the value of {\tt x}; otherwise
      evaluates and returns the value of {\tt z}.  Both {\tt x} and {\tt z},
      if evaluated, must have type {\tt T}.

      However if {\tt y} is a {\tt const} value, {\tt x} or {\tt y}, whichever
      is not evaluated, is also not compiled, and if it would be in error
      were it compiled, the error is not detected (unless it is a parsing
      error).

\hspace*{-0.2in}{\tt x \TT{AND} y} \\
      If {\tt x} is \underline{not} of type {\tt const},
      the result type is {\tt bool} and the types of {\tt x} and {\tt y}
      must be {\tt bool}.  {\tt x} is evaluated first, and if false,
      {\tt y} is not evaluated.

      If {\tt x} is a true {\tt const} value, {\tt y} is evaluated
      with result type {\tt bool} or {\tt const}.

      If {\tt x} is a false {\tt const} value, {\tt y} is not compiled
      or evaluated and the result is a false {\tt const} value.
      If {\tt y} would be in error were it compiled,
      the error is not detected (unless it is a parsing error).

\hspace*{-0.2in}{\tt x \TT{<} y \TT{<} z} \\
      This is equivalent to `{\tt x < y} AND {\tt y < z}', except that
      {\tt y} is only evaluated once.

      If {\tt x} or {\tt y} is \underline{not} of type {\tt const},
      `{\tt x < y}' has result type {\tt bool}
      and is only defined if {\tt x} and {\tt y} have the
      same type, {\tt T}, in which case {\tt z} must also have type  {\tt T}.

\hspace*{-0.2in}{\tt v[x+5] = y} \\
      The result type of subscript expressions such as `{\tt x + 5}'
      must be {\tt int}.

\hspace*{-0.2in}{\tt \TT{\textasciitilde} x} \\
       The `{\tt \textasciitilde}' operator
       evaluates on signed integers as if they were represented
       in two's complement by binary values of unbounded size,
       and similarly for other bitwise operators.

\hspace*{-0.2in}{\tt x \TT{**} y} \\
       Requires that {\tt y} be a {\tt const} non-negative integer;
       {\tt x ** 0 == 1} and {\tt x ** 1 == x} for all {\tt x}.

\hspace*{-0.2in}{\tt x \TT{+=} y} \\
	Means `{\tt next x = x + y}' if {\tt x} is {\tt co},
	and `{\tt x = x + y}' if {\tt x} is {\tt *READ-WRITE*}.
\end{indpar}

\subsection{Primaries}
\label{PRIMARIES}

A \key{primary} is an {\em expression} that has no operators:
\begin{indpar}
\emkey{primary}
    \begin{tabular}[t]{@{}rll}
    ::= & {\em constant}		& [\pagref{CONSTANTS}] \\
    $|$ & {\em reference-expression}    & [\pagref{REFERENCE-EXPRESSIONS}] \\
    $|$ & {\em function-call}		& [\pagref{FUNCTION-CALLS}] \\
    $|$ & {\em bracketted-expression}	& [\pagref{BRACKETTED-EXPRESSIONS}] \\
    \end{tabular}
\end{indpar}

\subsubsection{Names}
\label{NAMES}

A \key{name} is a sequence of lexemes used to name things like
variables and functions.  Names are building blocks of primaries.

\begin{indpar}
\emkey{name}\label{NAME} ::=
    {\em initial-name-item} {\em continuing-name-item}\STAR{} \\
\emkey{initial-name-item} ::= {\em name-item} other than {\em natural-number} \\
\emkey{continuing-name-item} ::= {\em name-item} not containing `\TT{.}' \\
\emkey{name-item}\label{NAME-ITEM}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em word} containing no `\TT{.}' that follows a character
                     that is not a `\TT{.}' \\
        & [i.e., `\TT{.}'s can only be at the \underline{beginning}
	   of the {\em word}] \\
        & [see text about splitting words with embedded `\TT{.}'s] \\
    $|$ & {\em natural-number} less than $10^9$ \\
    $|$ & {\em quoted-mark} not containing `\TT{.}'s \\
    $|$ & {\em quoted-separator} not containing `\TT{.}'s \\
    \end{tabular} \\
\emkey{quoted-mark} :::= \TT{"} {\em mark} \TT{"} \\
\emkey{quoted-separator} :::= \TT{"} {\em separator} \TT{"}
\end{indpar}

{\em Words} containing embedded `\TT{.}'s are split into
{\em name-items} which contain `\TT{.}'s only at their beginning.
Thus
\begin{center}
\TT{bills.wife.1.weight..size}
\end{center}
is split into
\begin{center}
\TT{bills~~~.wife~~~.1~~~.weight~~~~..size}
\end{center}
However, `\TT{.1}' is not a legal {\em name-item} and so cannot
be part of a legal {\em name}.

Name items beginning with more than one `\TT{.}' are reserved
for use by systems and compilers (e.g., \TT{..size} in the example).
Name items that are words containing `\TT{\$}' or that both
begin and end with `\TT{*}' are
similarly reserved.  For example, words of the form `\TT{T\$}\ldots'
are reserved for use as type wildcards.

A name can abbreviate another name, using the statement:
\begin{indpar}
\emkey{abbreviation-statement} ::=
    {\em abbreviated-name}~ \ABV{}~ {\em abbreviation-name}
\end{indpar}
For example:
\begin{center}
\tt bool \ABV{} std bool
\end{center}

Note that it is whole names that are abbreviated, and not parts of
names.

A name may begin with a {\em word} that is a {\em module-abbreviation}
that designates a code module: see~\itemref{MODULE-AND-BODY-DECLARATIONS}.
For example {\tt std} abbreviates the builtin standard module.

L-Language uses several kinds of names:

\begin{indpar}
\emkey{simple-name} ::= \TT{word} not containing any `\TT{.}'s or `\TT{@}'s \\
\emkey{module-abbreviation}\label{MODULE-ABBREVIATION} ::= {\em simple-name} \\
\emkey{ma} ::= {\em module-abbreviation} \\
\emkey{pointer-type-name}\label{POINTER-TYPE-NAME} ::=
    \MA{} {\em simple-name}
\\[1ex]
\emkey{basic-name}\label{BASIC-NAME} ::=
	    {\em name} not containing a `\TT{.}', {\em quoted-mark}, or
	    {\em quoted-separator} \\
\emkey{type-name}\label{TYPE-NAME} ::=
    \MA{} {\em basic-name} \\
\emkey{variable-name}\label{VARIABLE-NAME} ::=
    \MA{} {\em basic-name} \\
\emkey{pointer-variable}\label{POINTER-VARIABLE} ::=
    {\em variable-name} whose {\em basic-name} begins with an \TT{@} \\
\emkey{target-variable}\label{TARGET-VARIABLE} ::=
    {\em variable-name} whose {\em basic-name} does \underline{not}
    begin with an \TT{@} \\
\emkey{statement-label} ::= {\em basic-name}
    \label{STATEMENT-LABEL}
\\[1ex]
\emkey{member-name}\label{MEMBER-NAME}
	::= \begin{tabular}[t]{@{}l@{}}
                        {\em name} beginning with a `\TT{.}', \\
			but not containing a {\em quoted-mark} or
			    {\em quoted-separator} \\
			(note: all `\TT{.}'s in a {\em name} must be at
			 the beginning of the {\em name})
			\end{tabular} \\
\emkey{pointer-member-name}\label{POINTER-MEMBER-NAME} ::= \\
\hspace*{2em}
    {\em member-name} beginning with one or more `\TT{.}'s followed by
    an `\TT{@}' \\
\emkey{target-member-name}\label{TARGET-MEMBER-NAME} ::=
    {\em member-name} that is \underline{not} a {\em pointer-member-name}
\\[1ex]
\emkey{data-label}\label{DATA-LABEL} ::=
    {\em basic-name} $|$ {\em member-name}
\\[1ex]
\emkey{function-term-name} ::= {\em name}
    \label{FUNCTION-TERM-NAME}
\\[1ex]
\emkey{qualifier-name}\label{QUALIFIER-NAME} ::=
    \ttkey{co} $|$ \ttkey{ro} $|$ \ttakey{READ-WRITE} $|$
    \ttakey{WRITE-ONLY} $|$ \ttakey{VOLATILE} $|$ \ttakey{ATOMIC}
\begin{indpar}
{\tt co} abbreviates `constant' meaning `never changes' \\
{\tt ro} abbreviates `read-only' meaning `other code may change'
\end{indpar}
\emkey{operator-name}
    \begin{tabular}[t]{rl}
    ::= & \TT{if} $|$ \TT{else}
                  $|$ \TT{AND} $|$ \TT{OR}
		  $|$ \TT{NOT} $|$ \TT{BUT}
    \end{tabular}

\emkey{function-keyword}
    \begin{tabular}[t]{rl}
    ::= & \TT{no} $|$ \TT{not} $|$ \TT{function} \\
    $|$ & \TT{"="} $|$ \TT{","} $|$ \TT{"("} $|$ \TT{")"} $|$
          \TT{"["} $|$ \TT{"]"}
    \end{tabular}

\emkey{wild-card}\label{WILD-CARD}
    ::= {\em simple-name} beginning with \TT{T\$}, \TT{P\$}, or \TT{Q\$}
\begin{indpar}
Each {\tt T\$} name is assigned a {\em type-name} \\
Each {\tt P\$} name is assigned a {\em pointer-type-name} \\
Each {\tt Q\$} name is assigned a sequence of zero or more
               {\em qualifier-names}
\end{indpar}

where the following rules should be followed, least there be
various confusing syntax or semantic errors:
\begin{enumerate}
\item
A {\em type-name} should not begin with a {\em pointer-type-name}.
\item
A {\em pointer-type-name} should not begin with a {\em type-name}.
\item
A {\em function-term-name} should not begin with a {\em module-abbreviation}
or contain {\em function-keywords}.
\item
{\em Names} not used as operators should not contain {\em operator-names}.
\item
{\em Names} that are not {\em qualifier-names}
should not contain {\em qualifier-names}.
\end{enumerate}
\end{indpar}

For example,
the name resolver treats a sequence of
names in certain contexts as having the form:
\begin{center}
\{\MA {\em pointer-type-name}\}\QMARK{}~
{\em qualifier-name}\STAR{}~
\MA {\em type-name}~
\MA {\em variable-name}
\end{center}
where \MA denotes an optional {\em module-abbreviation},
and while scanning this sequence from left to right,
the name resolver does \underline{not} back up after identifying
one of the components of the sequence.

{\em Variable-names}, {\em type-names}, and {\em pointer-type-names}
that begin with a {\em module-abbreviation} are called
\key{external}\label{EXTERNAL-NAME}.
Other names are called \key{internal}\label{INTERNAL-NAME}.


\subsubsection{Constants}
\label{CONSTANTS}

A \key{constant} is a value of type \ttkey{const} computed at
compile-time.  There are four kinds of constants:

\begin{indpar}
\emkey{constant}\label{CONSTANT}
    \begin{tabular}[t]{rl}
    ::= & {\em special-constant} \\
    $|$ & {\em string-constant} \\
    $|$ & {\em number-constant} \\
    $|$ & {\em map-constant} \\
    \end{tabular} \\
\emkey{special-constant} ::= \ttkey{TRUE} $|$ \ttkey{FALSE}
                         $|$ \ttkey{UNDEF} $|$ \ttkey{NONE} \\
\emkey{string-constant} ::= {\em quoted-string}
\end{indpar}

The meanings of the {\em special-constants} are:
\begin{indpar}[1in]
\begin{itemize}
\item[\TT{TRUE}] The boolean value true.
\item[\TT{FALSE}] The boolean value false.
\item[\TT{UNDEF}] The value exists but is undefined (unknown).
\item[\TT{NONE}] The value does not exist.
\end{itemize}
\end{indpar}
A special constant is not equal to any other constant.

A \emkey{string-constant} is just a {\em quoted-string} lexeme
that denotes a character string: see
\pagref{QUOTED-STRING} and \pagref{QUOTED-STRING-CONCATENATION}.

String constants can be used to load run-time vectors
with {\tt uns8}, {\tt uns16}, or {\tt uns32} type elements.
UTf-8, UTF-16, or UTF-32 encodings are used according to element
size.

{\em Number-constants} and {\em map-constants} are described in the
following sections.


\subsubsubsection{Number Constants}
\label{NUMBER-CONSTANTS}

A \emkey{number-constant} is a {\em number} lexeme or sequence of
lexemes with specific syntax
that is used to denote a number.  Numbers are stored either
as unbounded integers, or as rational numbers whose numerator
and denominator are unbounded integers that have no common divisor
with the denominator being equal to or greater than 2.  In addition,
plus and minus infinity and a special `Not-a-Number' (NaN) value
are number values.
The syntax is:

\begin{indpar}
\emkey{number-constant}\label{NUMBER-CONSTANT}
    \begin{tabular}[t]{@{}cl}
    ::= & {\em decimal-constant} \\
    $|$ & {\em binary-constant} \\
    $|$ & {\em hexadecimal-constant} \\
    $|$ & {\em character-constant} \\
    $|$ & \TT{+Inf}
          ~$|$~ \TT{-Inf}
          ~$|$~ \ttkey{NaN} \\
    $|$ & \TT{Inf} ~~~~~ [equals {\tt +Inf}]
    \end{tabular}
\\[0.5ex]
\emkey{sign} :::= \TT{+} $|$ \TT{-} \\
\emkey{exponent} :::=
	\{ \TT{e} $|$ \TT{E} \} {\em sign}\QMARK{} {\em dit}\PLUS{}
\\[0.5ex]
\emkey{decimal-constant} \begin{tabular}[t]{@{}rl@{}}
                         ::= & {\em decimal-lexeme} \\
			 $|$ & {\em decimal-constant-prefix}~
			       {\em decimal-quoted-body}~
			       {\em exponent}\QMARK{}
			 \end{tabular}
\\[0.5ex]
\emkey{decimal-lexeme} :::= {\em sign}\QMARK{}~ {\em decimal-integer}~
			    {\em decimal-fraction}\QMARK{}~
                            {\em exponent}\QMARK{}
\\[0.5ex]
\emkey{decimal-constant-prefix} :::= {\em sign}\QMARK{}~ \TT{D\#}
\\[0.5ex]
\emkey{decimal-quoted-body} :::= \TT{"}~ {\em decimal-integer}~
				 {\em decimal-fraction}\QMARK{}~ \TT{"}
\\[0.5ex]
\emkey{decimal-integer}
    :::= {\em dit}\PLUS{} 
         \{ \TT{,} {\em dit} {\em dit} {\em dit} \}\STAR{} \\
\emkey{decimal-fraction} :::=
    \TT{.} \{ {\em dit} {\em dit} {\em dit} \TT{,} \}\STAR{}
           {\em dit}\PLUS{} \\
\emkey{dit}\label{DIT}
	:::= \TT{0} $|$ \TT{1} $|$ \TT{2} $|$ \TT{3} $|$ \TT{4}
                    $|$ \TT{5} $|$ \TT{6} $|$ \TT{7} $|$ \TT{8} $|$ \TT{9}
 \\[0.5ex]
\emkey{binary-constant} ::= {\em binary-constant-prefix}~
                              {\em binary-quoted-body}~
			      {\em exponent}\QMARK{}
\\[0.5ex]
\emkey{binary-constant-prefix} :::= {\em sign}\QMARK{}~ \TT{B\#}
\\[0.5ex]
\emkey{binary-quoted-body} :::= \TT{"}~ {\em binary-integer}~
				{\em binary-fraction}\QMARK{}~ \TT{"}
\\[0.5ex]
\emkey{binary-integer}
    :::= {\em bit}\PLUS{}
           \{ \TT{,} {\em bit} {\em bit} {\em bit} {\em bit} \}\STAR{} \\
\emkey{binary-fraction} :::=
    \TT{.} \{ {\em bit} {\em bit} {\em bit} {\em bit} \TT{,} \}\STAR{}
    {\em bit}\PLUS{} \\
\emkey{bit} :::= \TT{0} $|$ \TT{1}
 \\[0.5ex]
\emkey{hexadecimal-constant} ::= \\
\hspace*{0.5in}{\em hexadecimal-constant-prefix}~
               {\em hexadecimal-quoted-body}~
	       {\em exponent}\QMARK{}
\\[0.5ex]
\emkey{hexadecimal-constant-prefix} :::= {\em sign}\QMARK{}~ \TT{X\#}
\\[0.5ex]
\emkey{hexadecimal-quoted-body} :::= \TT{"}~ {\em hexadecimal-integer}~
				     {\em hexadecimal-fraction}\QMARK{}~ \TT{"}
\\[0.5ex]
\emkey{hexadecimal-integer}
    :::= {\em hit}\PLUS{}
           \{ \TT{,} {\em hit} {\em hit} \}\STAR{} \\
\emkey{hexadecimal-fraction} :::=
    \TT{.} \{ {\em hit} {\em hit} \TT{,} \}\STAR{}
    {\em hit}\PLUS{} \\
\emkey{hit} :::= \TT{0} $|$ \TT{1} $|$ \TT{2} $|$ \TT{3} $|$ \TT{4}
	     $|$ \TT{5} $|$ \TT{6} $|$ \TT{7} $|$ \TT{8} $|$ \TT{9}
	     $|$ \TT{a} $|$ \TT{b} $|$ \TT{c} $|$ \TT{d} $|$ \TT{e} $|$ \TT{f}
	     $|$ \TT{A} $|$ \TT{B} $|$ \TT{C} $|$ \TT{D} $|$ \TT{E} $|$ \TT{F}
 \\[0.5ex]
\emkey{character-constant} ::=
	{\em character-constant-prefix}~ {\em character-quoted-body}
\\[0.5ex]
\emkey{character-constant-prefix} :::= {\em sign}\QMARK{}~ \TT{C\#}
\\[0.5ex]
\emkey{character-quoted-body} :::=
	\TT{"}~ {\em character-representative}~ \TT{"}
\\[0.5ex]
\emkey{character-representative} :::= see \pagref{CHARACTER-REPRESENTATIVE}
\end{indpar}

The integer part of decimal constants may have commas
every 3 digits from the end and the fractional part may have
commas every 3 digits from the decimal point.
Similarly for binary integers and fractions with commas every 4 binary
digits,
and with hexa-decimal integers and fractions with commas every 2
hexa-decimal digits.
If there is a decimal point, there \underline{must}
be at least one integer digit and
one fraction digit.

A {\em character-constant} denotes plus or minus
the UNICODE code point of the {\em character-representative}.

\TT{NaN} denotes a canonical non-signaling NaN such
as that produced by hardware on the target machine.
\TT{+Inf} denotes positive infinity; \TT{-Inf} denotes negative infinity.

A number constant may be converted to a run-time type such as {\tt int32}.
It is a compile error to convert to an integer type that cannot
hold the exact value of the number constant.
Conversion of a number constant
to a run-time floating type, such as {\tt flt64}, is however
never a compile error.  If necessary the converted value is
{\tt +Inf} or {\tt -Inf}.

\subsubsubsection{Map Constants}
\label{MAP-CONSTANTS}

A {\em map-constant} has two parts, a list (a.k.a, a vector) and a dictionary.
Either or both can be empty.  The syntax of a {\em map-constant} is:

\begin{indpar}
\emkey{map-constant}\label{MAP-CONSTANT}
    \begin{tabular}[t]{rl}
    ::= & \TT{\{} \TT{\}} \\
    $|$ & \TT{\{} {\em map-list} \TT{\}} \\
    $|$ & \TT{\{} {\em map-dictionary} \TT{\}} \\
    $|$ & \TT{\{} {\em map-list}\TT{,} {\em map-dictionary} \TT{\}} \\
    $|$ & {\em phrase-constant} \\
    $|$ & {\em expression-constant} \\
    \end{tabular}
\\[0.5ex]
\emkey{map-list} ::= {\em list-element} \{ \TT{,} {\em list-element} \}\STAR{}
\\[0.5ex]
\emkey{map-dictionary} ::= {\em dictionary-entry}
                              \{ \TT{,} {\em dictionary-entry} \}\STAR{}
\\[0.5ex]
\emkey{dictionary-entry} ::=
    {\em dictionary-label} \TT{=>} {\em dictionary-value}
\\[0.5ex]
\emkey{list-element}\label{LIST-ELEMENT} ::= {\em constant}
\\[0.5ex]
\emkey{dictionary-label}\label{DICTIONARY-LABEL} ::= {\em data-label}
    ~~~~~ [see \pagref{DATA-LABEL}]
\\[0.5ex]
\emkey{dictionary-value}\label{DICTIONARY-VALUE}
    ::= {\em constant}
\\[0.5ex]
\emkey{constant}
    ::= see \pagref{CONSTANT}
\\[0.5ex]
\emkey{phrase-constant} ::= \TT{\{|} {\em expression} \TT{|\}}
\\[0.5ex]
\emkey{expression-constant} ::= \TT{\{*} {\em expression} \TT{*\}}
\\[0.5ex]
\emkey{expression} ::= see \pagref{EXPRESSION}
\end{indpar}

Maps \underline{cannot} be represented at run-time.

By abuse of language, \key{list} is used to refer to a map whose
dominant mode of access is to go through the map list elements
sequentially.  Similarly \key{vector} is used to refer to a map whose
dominant mode of access is to access the map elements randomly
using subscripts.  And \key{dictionary} is used to refer to a map
whose dominant mode of usage is to access the map's dictionary elements.

Dictionary entries are also called \skey{attribute}s.  For lists and
vectors, they are also called \skey{annotation}s.

Each {\em map-constant}
creates a distinct map: no two such maps are \TT{==}.  A map created
by a {\em map-constant} is initially set so that it and all its dictionary
entries are read-only.  This can be changed: see \pagref{READ-ONLY-MAP}.

If some {\em list-elements} or {\em dictionary-values} are
{\em expressions} that is not {\em constants} but which evaluate
to {\em constants}, then the {\em map-constant} expression is
a legal {\em expression} and computes a map.

An {\em expression-constant} is shorthand for the {\em map-constant}
produced when the {\em expression} is parsed: see \pagref{PARSER-OUTPUT}.
Generally, parsing an expression groups expression elements into
sublists and moves bracket and separator punctuation to dictionary entries.
Some examples are:
\begin{center} \tt
\begin{tabular}{l@{~~~}l}
\rm The expression:	& \rm Is equivalent to:
\\\hline
\{* X = ( Y + 1 ) *\}	& \{ "X", "=", \\
			&  ~~~~~~~\{ "Y", "+", 1, .initiator =>"(", \\
			& ~~~~~~~~~~~~~~~~~~~~~~.terminator =>")" \} \}
\\[0.5ex]
\{* X, Y = Y, X *\}	& \{ \{ "X", "Y", .separator => "," \}, \\
			&  ~ "=", \\
			&  ~ \{ "Y", "X", .separator => "," \} \}
\\[0.5ex]
\{* X + Y * Z *\}	& \{ "X", "+", \{ "Y", "*", "Z" \} \}
\\[0.5ex]
\{* X 3 = Y Z + 1 *\}	& \{ \{ "X", 3 \} "=", \{ \{ "Y", "Z" \} "+", 1 \} \}
\end{tabular}
\end{center}
In an \TT{\{*} {\em expression} \TT{*\}} constant,
line level operators are recognized if and only if
they are outside parentheses in the {\em expression}.

{\em Phrase-constants} are like {\em expression-constants} except that
operators (including separators, e.g. `{\tt ,}') are not recognized.
Brackets are recognized and create sublists.  Some examples contrasting
with {\em expression-constants} are:
\begin{center} \tt
\begin{tabular}{l@{~~~}l}
\rm The expression:	& \rm Is equivalent to:
\\\hline
\{| X = 1 |\}		& \{ "X", "=", 1 \}
\\[0.5ex]
\{* X = 1 *\}		& \{ "X", "=", 1 \}
\\[0.5ex]
\{| X = Y + 1 |\}	& \{ "X", "=", "Y", "+", 1 \}
\\[0.5ex]
\{* X = Y + 1 *\}	& \{ "X", "=", \{ "Y", "+", 1 \} \}
\\[0.5ex]
\{| X 3 = Y Z + 1 |\}	& \{ "X", 3, "=", "Y", "Z", "+", 1 \}
\\[0.5ex]
\{* X 3 = Y Z + 1 *\}	& \{ \{ "X", 3 \} "=", \{ \{ "Y", "Z" \} "+", 1 \} \}
\end{tabular}
\end{center}

{\em Type-names} and {\em pointer-type-names} can be used at
compile-time as if they were variables of type {\tt const}
with map values.  These map values are partly read-only,
with the read-only part including elements with labels like
{\tt size} for the size in bits of run-time values of the type.
Users can add their own elements if these do not conflict
with the names of the read-only elements.  See \pagref{TYPE-MAPS}.

\subsubsection{Reference Expressions}
\label{REFERENCE-EXPRESSIONS}

A \emkey{reference-expression} names either a pointer to a location in memory
or names the value of such a location.

The most basic {\em reference-expression} is the name of a variable
in the current function frame or current module memory.  Other
reference expressions are made by appending vector indices or structure
member names to more basic {\em reference-expressions}.  The syntax
is:

\begin{indpar}
\emkey{reference-expression}
    \begin{tabular}[t]{rl}
    ::= & {\em variable-name} \\
    $|$ & \TT{next}~ {\em variable-name} \\
    $|$ & {\em reference-expression} \TT{[} {\em index-list} \TT{]} \\
    $|$ & {\em reference-expression} {\em member-name} \\
    \end{tabular}
\\[0.5ex]
\emkey{index-list} ::= {\em index} \{ \TT{,} {\em index} \}\STAR{}
\\[0.5ex]
\emkey{index}\label{REFERENCE-INDEX}
    ::= {\em sign}\QMARK{} {\em index-term}
        \{ {\em sign} {\em index-term} \}\STAR{}
\\[0.5ex]
\emkey{sign} ::= \TT{+} $|$ \TT{-}
\\[0.5ex]
\emkey{index-term}
    \begin{tabular}[t]{rl}
    ::= & {\em constant-expression} \\
    $|$ & {\em variable-name} \\
    $|$ & {\em constant-expression} \TT{*} {\em variable-name} \\
    \end{tabular}
\\[0.5ex]
\emkey{constant-expression}\label{CONSTANT-EXPRESSION}
    ::= {\em expression} that evaluates at compile-time to a constant
\\[0.5ex]
\emkey{variable-name} ::= see \pagref{VARIABLE-NAME}
\\[0.5ex]
\emkey{member-name} ::= see \pagref{MEMBER-NAME}
\end{indpar}

A {\em member-name} of the form `\TT{.}{\em data-label}\,'
may be used to select a field or subfield\label{FIELD-SELECTION}
of a user defined type\pagnote{TYPE-DECLARATIONS} value or
a dictionary entry of a {\em map-dictionary}.

An {\em index} may be used to select an element of a vector
or array in a
user defined type value, or the
element of a vector pointed at by a pointer, or an element
of a {\em map}.  An {\em index} can be a {\em const}
string.  For a run-time {\em reference-expression} a string
{\em index} is a {\em data-label}: `{\tt ["M"]}' is equivalent
to `{\tt .M}'.  For a compile-time {\em reference-expression}
the string is used to select a map {\em dictionary-entry}.
Otherwise the
index must be a positive or negative integer.  Bounds imposed
by user defined types or stored in a pointer are used to
check that the index is within range.


Within an {\em index-list} the comma (\TT{,}) is treated
as equivalent to \TT{][}, so, for example, {\tt [x,y]}
is equivalent to {\tt [x][y]}.

If the {\em variable-name} at the beginning of a {\em reference-expression}
is a {\em pointer-variable}, the reference expression computes a pointer.
E.g., `{\tt @V[5]}' computes a pointer to the 5+1'st element of the
vector pointed at by {\tt @V}.

If the {\em variable-name} at the beginning of a {\em reference-expression}
is a {\em target-variable} with an associated {\em pointer-variable},
the reference expression refers to the value pointed by the pointer
that would be computed if the {\em target-variable} was replaced by
its associated {\em pointer-variable}.

If the {\em variable-name} at the beginning of a {\em reference-expression}
is a {\em target-variable} (i.e., does not begin with `\TT{@}')
\underline{without}
an associated {\em pointer-variable},
the reference expression refers to the variable itself,
to a field or dictionary entry of the variable's value,
or to a vector or list element of the variable's value.

Compile-time maps are represented internally by pointers to where
the map is stored, so that if {\tt X} is a variable equal to,
i.e., pointing at, a map, then {\tt Y = X} copies the pointer
to the map to the variable {\tt Y}.  By default compile-time
maps can be changed, but it is possible to mark dictionary members
of a map
as unchangeable constants.  The following example illustrates
computation with compile-time maps:
\begin{indpar}\begin{verbatim}
const X = {"A", "B"}
X[0] = "C"               // Now X is {"C", "B"}.
const Y = X              // Now X and Y are both {"C", "B"}. 
Y[1] = "D"               // Now X and Y are both {"C", "D"}. 
const Z = { Y, "M" }     // Now Z is {{"C", "D"}, "M"}.
Z[0].W = "N"             // Now Z is {{"C", "D", "W" => "N"}, "M"},
                         // X and Y are both {"C", "D", "W" => "N"}.
\end{verbatim}\end{indpar}


Inline functions may be defined that syntactically and semantically mimic
{\em reference-\EOL expres\-sions}, and calls to such functions
can be used as {\em reference-expressions} (this is an exception
to the rule that a run-time statement can contain at most one function
call).  If the inline function returns a value, a call to the function
can only be used to read a value from an apparent
location.  However if the inline function returns a pointer at a target
with writable qualifiers, a call to the function can be used
to write that target.  An example of the latter is:
\label{REFERENCE-EXPRESSION-FUNCTION-EXAMPLE}

\begin{indpar}\begin{verbatim}
// In my vector X, a writable vector with flt64 elements is
// located at X.offset from the address of X and allows index
// range from 0 through X.length-1.
//
type my vector:
    uns offset;
    uns length;
    . . . .
function ap *READ_WRITE* flt64 @x = ( ap my vector @v ) [ uns index ]:
    av *READ-WRITE* flt64 @p = *UNCHECKED*
            ( @v, v.offset, 0, v.length )
        // The *UNCHECKED* function is a builtin function
        // that performs a variety of conversions which
        // violate type checking.  Here it takes @v, adds
        // v.offset to its offset, and returns this ap as an
        // av with bounds 0 and v.length.
    @x = @p[index]
\end{verbatim}\end{indpar}

\subsubsection{Function Calls}
\label{FUNCTION-CALLS}

The syntax of function calls is:

\begin{indpar}
\emkey{function-call}\label{FUNCTION-CALL}
    \begin{tabular}[t]{rl}
    ::= & {\em module-abbreviation}\QMARK{}
          {\em call-argument-list}\STAR{}
          {\em call-term} {\em call-term}\STAR{} \\
    $|$ & {\em call-argument-list}
          {\em call-argument-list}\PLUS{} \\
    \end{tabular}
\\[0.5ex]
\emkey{call-term}
    \begin{tabular}[t]{rl}
    ::= & {\em call-term-name} {\em call-argument-list}\STAR{} \\
    $|$ & \ttkey{no} {\em call-term-name} \\
    $|$ & \ttkey{not} {\em call-term-name} \\
    \end{tabular}
\\[0.5ex]
\emkey{call-argument-list}\label{CALL-ARGUMENT-LIST}
    \begin{tabular}[t]{rl}
    ::= & \TT{(} {\em actual-argument}
          \{ \TT{,} {\em actual-argument} \}\STAR{} \TT{)} \\
    $|$ & \TT{[} {\em actual-argument}
          \{ \TT{,} {\em actual-argument} \}\STAR{} \TT{]} \\
    $|$ & \TT{()} $|$ \TT{[]} \\
    $|$ & {\em unparenthesized-actual-argument} \\
    \end{tabular}
\\[0.5ex]
\emkey{actual-argument} ::= {\em expression}
\\[0.5ex]
\emkey{unparenthesized-actual-argument} ::=
    {\em constant} $|$ {\em variable-name}
\\[0.5ex]
\emkey{call-term-name}\label{CALL-TERM-NAME} ::=
    \begin{tabular}[t]{@{}l}
    {\em function-term-name} with quotes \underline{optionally} removed from \\
    {\em quoted-marks} and {\em quoted-separators}
    \end{tabular}
\\[0.5ex]
\emkey{function-term-name} ::= see \pagref{FUNCTION-TERM-NAME}
\\[0.5ex]
\emkey{constant} ::= see \pagref{CONSTANTS}
\\[0.5ex]
\emkey{variable-name} ::= see \pagref{VARIABLE-NAME}
\\[0.5ex]
\emkey{expression} ::= see \pagref{EXPRESSION}
\\[2.0ex]
NOTE: Two {\em unparenthesized-actual-arguments} cannot be consecutive.
\end{indpar}

Thus a {\em function-call} is a sequence of {\em function-term-names}
and {\em call-argument-lists}.

An {\em unparenthesized-actual-argument}\label{UNPARENTHESIZED-ACTUAL-ARGUMENT}
is an {\em actual-argument}
{\tt X} that would normally be in parentheses as {\tt (X)} but the
parentheses have been omitted.  Thus given the example function definition
on page \pageref{REFERENCE-EXPRESSION-FUNCTION-EXAMPLE},
{\tt (v)[i]} may be written as {\tt v[i]}.  Only {\tt (~)}'s may be
omitted, and then only if they surround exactly one {\em actual-argument}
that is a {\em constant} or {\em variable-name}.

{\em Call-terms} of the form `{\tt no x}' and `{\tt not x}' are
equivalent to `{\tt x(false)}'.

{\em Function-calls} are matched to function prototypes.  The
{\em call-term-names} in a match are identical to the
{\em function-term-names} taken from the prototype being matched, except
that quotes (\TT{"}) in a prototype {\em quoted-mark} or
{\em quoted-separator} may (or may not) be omitted in the
{\em function-call}.  The first
step in matching is to scan the {\em function-call} to identify the
{\em call-term-names}.  There is no parser backing up after this is
done: if the results of this initial scan do not lead to a satisfying
match, the entire call-prototype match fails.  Therefore caution
is necessary in omitting parentheses around
{\em unparenthesized-actual-arguments} when these share lexemes with
{\em function-term-names} in function prototypes that might be
matched to the {\em function-call}.

\subsubsection{Bracketted Expressions}
\label{BRACKETTED-EXPRESSIONS}

The syntax of a {\em bracketted-expression} is:

\begin{indpar}
\emkey{bracketted-expression}\label{BRACKETTED-EXPRESSION}
    \begin{tabular}[t]{@{}rl}
    ::= & {\em ma}\QMARK{} \TT{(} {\em expression} \TT{)} \\
    $|$ & \TT{[} {\em expression} \TT{]} \\
    $|$ & \TT{\{} {\em expression} \TT{\}} \\
    \end{tabular}
\\[0.5ex]
{\em ma} ::= {\em module-abbreviation} ~~~ [see \pagref{MODULE-ABBREVIATION}]
\end{indpar}

Arithmetic subexpressions and function argument lists are bracketted
with \TT{()} brackets.  Reference expression index lists and function
argument lists are bracketed with \TT{[]} brackets.
Expressions that compute map constants
are bracketed with \TT{\{\}} brackets.

An expression of the form `{\em ma} \TT{(} {\em expression} \TT{)}' is
just syntactic sugar for `\TT{(} {\em ma} {\em expression} \TT{)}', except
that the {\em expression} is parsed before the {\em ma} is moved inside the
\TT{()}'s.  Thus if {\tt mom} is a {\em module-abbreviation},
`{\tt mom ( x + y * z )}' is syntactic sugar for \\
\centerline{\tt ( mom x "+" ( y "*" z ) )}
in which the parenthesis pair surrounding `{\tt y "*" z}' is implied.
This allows the {\em module-abbre\-via\-tion} to be applied to the outermost
operator in the {\em expression}.

\subsection{Compile-Time}
\label{COMPILE-TIME}

Variables and values that exist during compilation are called
\key{compile-time}, while variables and values that exist during
program execution are called {\em run-time}.

Syntactically \key{compile-time} is defined as follows:

\begin{itemize}
\item A variable (i.e., {\em variable-name})
is compile-time if and only if it is of type {\tt const}.
(Compile-time variables do \underline{not} exist at run-time.)
\item A {\em constant} is compile-time.
\item A {\em type-name} and a {\em pointer-type-name} are compile-time
and denote maps describing the type or pointer type.
(At run-time a type {\tt T} is declared by the
equivalent of {\tt type @T = \ldots}, where `{\tt type}' is a
defined type that is
used to distinguish types and contain type parameters, and
similarly for pointer types.)
\item An {\em expression} with an operator is
      compile-time if its lowest precedence operator
      and its operands are compile-time.
      All the standard operators are compile-time.
\item A {\em function-call} is compile-time if and only if all its
      arguments are compile-time and the function called is
      compile-time.
\item A user-defined function is compile-time if and only if all its
      result and argument variables are compile-time (i.e., have
      {\tt const} type) and all its
      {\em statements} are compile-time.
\item Builtin functions are compile-time if their arguments and
      results are all of {\tt const} type.
\item A {\em statement} is compile-time if and only if all its
      variables and expressions are compile-time.
\end{itemize}

A \key{run-time} {\em variable}, {\em expression}, or {\em statement}
is a {\em variable}, {\em expression}, or {\em statement} that is
\underline{not} compile-time.

\subsection{Statements}
\label{STATEMENTS}

The following is a complete list of the kinds of statements:
\begin{indpar}
\emkey{statement}\label{STATEMENT}
    \begin{tabular}[t]{@{}rll}
    ::= & {\em assignment-statement}
        & [\pagref{ASSIGNMENT-STATEMENTS}] \\
    $|$ & {\em control-statement}
        & [\pagref{CONTROL-STATEMENT}] \\
    $|$ & {\em condition-statement}
        & [\pagref{CONDITIONAL-STATEMENTS}] \\
    $|$ & {\em declaration-statement}
        & [\pagref{DECLARATION-STATEMENT}] \\
    $|$ & {\em include-statement}
        & [\pagref{INCLUDE-STATEMENTS}] \\
    \end{tabular}
\end{indpar}

\subsubsection{Assignment Statements}
\label{ASSIGNMENT-STATEMENTS}

{\em Assignment-statements} have a list of variables on the
left side which receive values from a list of expressions or
a block of code on the right side.  The left-side variables
may be omitted if the right side produces no values,
or if a left-side variable
has the form of `{\tt next} {\em variable-name}' and is
implied by the right side.

The forms of an {\em assignment-statement} are:
\begin{indpar}
\emkey{assignment-statement}
    \begin{tabular}[t]{@{}rll}
    ::= & {\em expression-assignment-statement} \\
    $|$ & {\em call-assignment-statement} \\
    $|$ & {\em block-assignment-statement} \\
    $|$ & {\em deferred-assignment-statement} \\
    $|$ & {\em loop-assignment-statement} \\
    \end{tabular}
\\[0.5ex]
\emkey{expression-assignment-statement} ::= \\
\hspace*{0.5in} {\em assignment-result}
                \{ \TT{,} {\em assignment-result} \}\QMARK{}
		\TT{=} {\em expression-list}
\\[0.5ex]
\emkey{expression-list} ::= see \pagref{EXPRESSION-LIST}
\\[0.5ex]
\emkey{call-assignment-statement} ::= \\
\hspace*{0.5in}
    \begin{tabular}[t]{@{}rll}
        & {\em assignment-result}
                \{ \TT{,} {\em assignment-result} \}\QMARK{}
		\TT{=} {\em function-call} \\
    $|$ & {\em function-call} \\
    \end{tabular}
\\[0.5ex]
\emkey{function-call} ::= see \pagref{FUNCTION-CALLS}
\\[0.5ex]
\emkey{block-assignment-statement} ::= \\
\hspace*{0.5in}
    \begin{tabular}[t]{@{}rll}
        & {\em block-variable-declaration}
                \{ \TT{,} {\em block-variable-declaration} \}\QMARK{} \\
	& ~~~~~ \{ \TT{=}
		   \ttkey{do} {\em block-label}\QMARK{} \}\QMARK{} \TT{:} \\
        & ~~~~~~~~~~ {\em statement}\STAR{} \\
        & ~~~~~~~~~~ {\em exit-sublock}\STAR{} \\
    $|$ & \ttkey{do} {\em block-label}\QMARK{} \TT{:} \\
        & ~~~~~ {\em statement}\STAR{} \\
        & ~~~~~ {\em exit-sublock}\STAR{} \\
    \end{tabular}
\\[0.5ex]
\emkey{deferred-assignment-statement} ::= \\
\hspace*{0.5in}
        {\em deferred-variable-declaration}
	    \{ \TT{,} {\em deferred-variable-declaration} \}\QMARK{}
	    \TT{=} \ttkey{*DEFERRED*}
\\[0.5ex]
\emkey{loop-assignment-statement} ::= \\
\hspace*{0.5in}
    \begin{tabular}[t]{@{}rll}
        & {\em next-variable-declaration}
                \{ \TT{,} {\em next-variable-declaration} \}\QMARK{}
		\TT{=} \\
	& ~~~~~~~~~~~~~~~ {\em iteration-control} \TT{:} \\
        & ~~~~~ {\em statement}\STAR{} \\
        & ~~~~~ {\em exit-sublock}\STAR{} \\
    $|$ & {\em iteration-control} \TT{:} \\
        & ~~~~~ {\em statement}\STAR{} \\
        & ~~~~~ {\em exit-sublock}\STAR{} \\
    \end{tabular}
\\[0.5ex]
\emkey{exit-subblock} ::=
    \begin{tabular}[t]{l}
    {\em exit-label} \ttkey{exit}\TT{:} \\
    \TT{~~~~}{\em statement}\STAR{} \\
    \end{tabular}
\\[0.5ex]
\emkey{iteration-control} ::= see \pagref{ITERATION-CONTROL}
\\[0.5ex]
\emkey{block-label}\label{BLOCK-LABEL} ::= {\em statement-label}
\\[0.5ex]
\emkey{exit-label} ::= {\em statement-label}
\\[0.5ex]
\emkey{statement-label} ::= see \pagref{STATEMENT-LABEL}
\\[0.5ex]
\emkey{assignment-result}\label{ASSIGNMENT-RESULT}
    \begin{tabular}[t]{@{}rll}
    ::= & {\em result-variable-declaration} \\
    $|$ & {\em next-variable-declaration} \\
    $|$ & {\em reference-expression}
    		& [see \pagref{REFERENCE-EXPRESSIONS}] \\
    \end{tabular}
\\[0.5ex]
\emkey{result-variable-declaration}\label{RESULT-VARIABLE-DECLARATION} ::= \\
\hspace*{0.5in}\begin{tabular}{rl}
	    & {\em type-name} {\em target-variable} \\
	$|$ & {\em pointer-type-name} {\em qualifier-name}\STAR{}
	      {\em type-name} {\em pointer-variable}
	\end{tabular}
\\[0.5ex]
\emkey{next-variable-declaration}\label{NEXT-VARIABLE-DECLARATION}
    ::= \ttkey{next} {\em variable-name}
\\[0.5ex]
\emkey{block-variable-declaration}\label{BLOCK-VARIABLE-DECLARATION} ::= \\
\hspace*{0.5in}\begin{tabular}{rl}
	    & {\em type-name} {\em target-variable} \\
	$|$ & \TT{next} {\em target-variable} \\
	$|$ & {\em pointer-type-name} {\em qualifier-name}\STAR{}
	      {\em type-name} {\em pointer-variable} \\
	    & ~~~~~ \{ \TT{=@} {\em allocation-call} \}\QMARK{} \\
	$|$ & \TT{next} {\em pointer-variable}
	      ~ \{ \TT{=@} {\em allocation-call} \}\QMARK{} \\
	\end{tabular}
\\[0.5ex]
\emkey{deferred-variable-declaration}%
    \label{DEFERRED-VARIABLE-DECLARATION} ::= \\
\hspace*{0.5in}\begin{tabular}{rl}
	    & {\em type-name} {\em target-variable} \\
	$|$ & {\em pointer-type-name} {\em qualifier-name}\STAR{}
	      {\em type-name} {\em pointer-variable} \\
	    & ~~~~~ \{ \TT{=@} {\em allocation-call} \}\QMARK{} \\
	\end{tabular}
\\[0.5ex]
\emkey{qualifier-name} ::= see \pagref{QUALIFIER-NAME}
\\[0.5ex]
\emkey{pointer-type-name} ::= see \pagref{POINTER-TYPE-NAME}
\\[0.5ex]
\emkey{type-name} ::= see \pagref{TYPE-NAME}
\\[0.5ex]
\emkey{variable-name} ::= see \pagref{VARIABLE-NAME}
\\[0.5ex]
\emkey{target-variable} ::= see \pagref{TARGET-VARIABLE}
\\[0.5ex]
\emkey{pointer-variable} ::= see \pagref{POINTER-VARIABLE}
\\[0.5ex]
\emkey{allocation-call} ::= {\em function-call}
\end{indpar}

Associated with {\em block-assignment-statements},
{\em companion-assignment-statements}, and
{\em loop-assignment-statements}
there are {\em con\-trol-statements}
to control the flow of execution within the more complex
{\em assignment-state\-ment}:
\begin{indpar}
\emkey{control-statement}\label{CONTROL-STATEMENT}
    \begin{tabular}[t]{@{}rll}
    ::= & {\em block-control-statement}
        & [\pagref{BLOCK-CONTROL-STATEMENT}] \\
    $|$ & {\em loop-control-statement}
        & [\pagref{LOOP-CONTROL-STATEMENT}] \\
    \end{tabular}
\end{indpar}

A {\em result-variable-declaration} allocates memory for its variable
in the frame of the currently executing function.
{\em Expression-assignment-statements} set the values of these variables
to the values of the {\em expressions} in the {\em expression-list}.
{\em Call-assignment-statements} set the values of these variables
to the values returned by the {\em function-call}.

A {\em block-variable-declaration}
allocates memory for its variable
in the frame of the currently executing function and also initializes
that memory according to the declaration syntax as follows:
\begin{indpar}[0.05in]
{\em result-variable-declaration}\,:~
The memory is zeroed. \\
{\em next-variable-declaration} with no {\em allocation-call}\,:~
Previous value of the named variable. \\
{\em block-variable-declaration} with {\em allocation-call}\,:~
Value returned by the {\em allocation-call}.
\end{indpar}

The variables declared by {\em block-variable-declarations}
\underline{without} {\em allocation-calls}
are {\tt *WRITE-\EOL ONLY*} in {\em statements}
of the {\em assignment-statement} and {\tt co} after the
{\em assignment-statement}.
Zeroed numbers are zero, while zeroed pointers typically
cause segmentation faults when de-referenced.

The {\em pointer-variables} declared by {\em block-variable-declarations}
\underline{with} {\em allocation-calls}
are initialized by the {\em allocation-call}
(see \pagref{ALLOCATION-CALL}) and are thereafter
{\tt co}, but the memory
pointed at is zeroed initially, 
{\tt *WRITE-\EOL ONLY*} in {\em statements}
of the {\em assignment-statement}, and 
subject to the {\em pointer-variable} {\em qualifiers} after
the {\em assignment-statement}.

If a {\em result-variable-declaration} declares a {\em pointer-variable},
an associated {\em target-variable} is implicitly declared at the same time
whose name is the {\em pointer-name} with the initial `{\tt @}' removed.
The {\em target-variable} is not itself allocated to memory,
but instead references the value the {\em pointer-variable}
points at.

Note that a {\em result-variable-declaration} does not allow
qualifiers on anything but the target of a pointer.  The implicit
qualifier of a declared variable is {\tt co} after the
{\em assignment-statements} meaning that
the value of the variable once initially set is never changed.
The qualifiers of a {\em target-variable} associated with a
{\em pointer-variable} are those of the target of
its associated pointer.

A {\em next-variable-declaration} for a {\em variable} {\tt v}
must occur in the scope of either a {\em result-variable-declaration}
for {\tt v} or another {\em next-variable-declaration} for {\tt v}.
Furthermore, {\tt v} cannot be an {\em target-variable} associated
with a {\em pointer-variable}.
The {\em next-variable-declaration} re-declares {\tt v} making a new
variable that hides the previously declared {\tt v}.  The new variable
has the same types and qualifiers as the previous variable named {\tt v}.

A {\em next-variable-declaration} for variable {\tt v} enables
`{\tt next v}' to be used like a {\em variable-name}
in {\em reference-expressions} within the {\em statements}
of the {\em assignment-statement}.  Use of
{\tt v} within these statements outside of `{\tt next v}'
refers to the value of {\tt v} just
before the {\em assignment-statement} was executed.

Under some circumstances `{\tt next v}' will
be implicitly added to an {\em assignment-statement}
{\em block-variable-declaration} list or {\em next-variable-declaration} list
to legalize the
use of `{\tt next v}' as an {\em assignment-result} of a {\em statement}
in the {\em assignment-statement}.
See \pagref{NEXT-PROMOTION}.

\subsubsubsection{Expression Assignment Statements}
\label{EXPRESSION-ASSIGNMENT-STATEMENTS}

The syntax of an {\em expression-assign\-ment-statement} is:
\begin{indpar}
\emkey{expression-assignment-statement} ::= \\
\hspace*{0.5in} {\em assignment-result}
                \{ \TT{,} {\em assignment-result} \}\QMARK{}
		\TT{=} {\em expression-list}
\\[0.5ex]
\emkey{expression-list}\label{EXPRESSION-LIST} ::=
	      {\em expression} \{ \TT{,} {\em expression} \}\STAR{}
\\[0.5ex]
\emkey{assignment-result} ::= see \pagref{ASSIGNMENT-RESULT}
\\[0.5ex]
\emkey{expression} ::= see \pagref{EXPRESSION}
\\[2.0ex]
where
\begin{itemize}

\item The number of {\em expressions} must equal the number
of {\em assignment-results}.

\item The
{\em expressions} \underline{cannot} contain a run-time {\em function-call},
other than a call to a builtin function called by means of an operator.
For example, {\tt x "+" y} is allowed if {\tt x} and {\tt y} are of
builtin numeric type or number constants, but not if either is a
string constant or of a user defined type.

\item For run-time {\em expression-assignment-statements}, if
there is \underline{more than one} {\em expression}, all these
{\em expressions} must be {\em reference-expressions} or
compile-time {\em expressions} (thus run-time computation cannot
be done except for {\em reference-expression} indices).

\item For run-time {\em expression-assignment-statements} with
a \underline{single} {\em expression}, the run-time operators
in the {\em expression} must operate on
the data type specified by the single {\em assignment-result}.
Furthermore the parenthesis depth of the {\em expression}
must not be greater than 4 (i.e., {\tt ((((\ldots))))} is the
maximum depth allowed).

\end{itemize}
\end{indpar}

All {\em reference-expression} indices are evaluated first,
then the {\em expressions} are evaluated,
then the {\em expression} values are stored in the {\em assignment-results}.

Variable names declared by {\em result-variable-declarations} that are
{\em assignment-results} are not visible to the {\em expressions}.
In particular, if `{\tt next V}' is an {\em assignment-result},
the name `{\tt V}' in an {\em expression} will refer to the variable
that exists before the {\em expression-assignment-statement}.

\subsubsubsection{Call Assignment Statements}
\label{CALL-ASSIGNMENT-STATEMENTS}

The syntax of a {\em call-assignment-statement} is:
\begin{indpar}
\emkey{call-assignment-statement} ::= \\
\hspace*{0.5in} {\em assignment-result}
                \{ \TT{,} {\em assignment-result} \}\QMARK{}
		\TT{=} {\em function-call}
\\[0.5ex]
\emkey{assignment-result} ::= see \pagref{ASSIGNMENT-RESULT}
\\[0.5ex]
\emkey{function-call} ::= see \pagref{FUNCTION-CALL}
\\[2.0ex]
where
\begin{itemize}

\item The {\em function-call} must be run-time (else the statement is
an {\em expression-assign\-ment-statement}).

\item The {\em actual-arguments} in the {\em function-call} must be
{\em reference-expressions} or
com\-pile-time {\em expressions}.

\item The {\em function-call} and {\em assignment-results} together
must match a single function prototype as per
\itemref{INLINE-CALL-PROTOTYPE-MATCHING}.
\end{itemize}
\end{indpar}

All {\em reference-expression} indices are evaluated first,
then the {\em function-call} is evaluated.

Variable names declared by {\em variable-declarations} that are
{\em assignment-results} are not visible to the {\em actual-arguments}.
In particular, if `{\tt next V}' is an {\em assignment-result},
the name `{\tt V}' in an {\em actual-argument} will refer to the variable
that exists before the {\em call-assignment-statement}.


\subsubsubsection{Block Assignment Statements}
\label{BLOCK-ASSIGNMENT-STATEMENTS}

The syntax of {\em block-assignment-statements} is:

\begin{indpar}
\emkey{block-assignment-statement} ::= \\
\hspace*{0.5in}
    \begin{tabular}[t]{@{}rll}
        & {\em block-variable-declaration}
                \{ \TT{,} {\em block-variable-declaration} \}\QMARK{} \\
	& ~~~~~ \{ \TT{=}
		   \ttkey{do} {\em block-label}\QMARK{} \}\QMARK{} \TT{:} \\
        & ~~~~~~~~~~ {\em statement}\STAR{} \\
        & ~~~~~~~~~~ {\em exit-sublock}\STAR{} \\
    $|$ & \ttkey{do} {\em block-label}\QMARK{} \TT{:} \\
        & ~~~~~ {\em statement}\STAR{} \\
        & ~~~~~ {\em exit-sublock}\STAR{} \\
    \end{tabular}
\\[0.5ex]
{\em block-variable-declaration} ::=
    see \pagref{BLOCK-VARIABLE-DECLARATION}
\\[0.5ex]
\emkey{exit-subblock}\label{EXIT-SUBBLOCK} ::=
    \begin{tabular}[t]{l}
    {\em exit-label} \ttkey{exit}\TT{:} \\
    \TT{~~~~}{\em statement}\STAR{} \\
    \end{tabular} \\
\emkey{exit-label} ::= {\em statement-label}
\\[0.5ex]
{\em statement-label} ::= see \pagref{STATEMENT-LABEL} \\
{\em statement} ::= see \pagref{STATEMENT} \\
\emkey{block-control-statement}\label{BLOCK-CONTROL-STATEMENT}
	::= {\em goto-exit-statement} \\
{\em go-to-exit-statement} ::= see \pagref{GO-TO-STATEMENT}
\end{indpar}

The {\em block-assignment-statement}
first allocates and initializes memory in the current function frame
for the variables declared by the {\em block-variable-declarations}.

Then any {\em statements} and
{\em exit-subblocks} are executed.  During this execution
block variables \underline{not} set by an {\em allocation-call}
are {\tt *WRITE-\EOL ONLY*}, and after this execution, these variables become
{\tt co}.  During this execution pointer variables set by
an {\em allocation-call} are {\tt co}, but their target type is changed
to {\tt *WRITE-\EOL ONLY*}, and after execution the target type
qualifiers become whatever the pointer variable declarations specify.

When a declaration has an {\em allocation-call}\label{ALLOCATION-CALL},
its variable must have pointer
type, and the {\em allocation-call} is executed to set the pointer
before any {\em statements} in the {\em block-assignment-statement}
are executed.  The {\em allocation-call} is executed
with a pre-pended argument list consisting of two {\tt uns} values
in {\tt ()} parentheses.  The first value is the number of bytes to
be allocated, and the second value is the byte alignment of the
memory to be allocated.
The {\em prototype-pattern}
of the called function's prototype\pagnote{PROTOTYPE-PATTERN}
must begin with `{\tt ( uns length, uns alignment )}', although
the argument names may be different.
The called function must allocate a block of
memory with the required number of bytes and alignment and zero that
block.  The prototype must have
exactly one result variable whose type is convertible to
the data type associated with a pointer type\pagnote{POINTER-ASSOCIATE}.

As a general rule, allocator functions that return a value of
`{\tt data for av}' or `{\tt data for fv}' type
have a {\tt []} argument list
with a single argument giving a vector size {\tt N}.
The allocator allocates not a single block of the given length
and alignment, but instead a vector of {\tt N} such blocks, with zero padding
between the blocks if necessary to obtain proper alignment for each
block.  However,
this is by convention and is not a builtin requirement of the L-Language.
The convention is followed by the builtin allocators (e.g., {\tt local}).

A {\em go-to-exit-statement} within a block may exit the block or
enter an {\em exit-subblock} of the block:
\begin{indpar}
\emkey{go-to-exit-statement}\label{GO-TO-STATEMENT} ::=
    \ttkey{go to} {\em go-to-label} \TT{exit}
\\[0.5ex]
\emkey{go-to-label} ::= {\em block-label} $|$ {\em exit-label}
\end{indpar}

Unless a {\em go-to-exit-statement} is executed,
a block exits after the last {\em statement} in the block,
and an {\em exit-subblock} exits its containing block after the last
{\em statement} in the {\em exit-subblock}.

A {\em go-to-exit-statement} in an {\em exit-subblock} may only enter
a \underline{subsequent} {\em exit-subblock} or exit any of its containing
{\em block-assignment-statements} by using that block's {\em block-label}.

{\em Go-to-exit-statements} define various possible execution
paths through a {\em block-assignment-statement}
(these are paths in an acyclic graph).
It is a compile error if a {\em statement}
within the {\em block-assignment-statement}
uses a declaration and the statement can be reached by a path that
does not contain the declaration.
Note that declarations not in {\em exit-subblocks} have scope
that includes the {\em exit-subblocks}, but declarations
within an {\em exit-subblock} have scope that ends with the end of
the subblock.  A function prototype is `used' if and only if it
matches a {\em function-call}.

If\label{NEXT-PROMOTION} `{\tt next} {\em variable-name}' is used as an
{\em assignment-result} of some {\em statement} within a
{\em block-assignment-statement} that is not within the scope of
a {\em result-variable-declaration} for the {\em variable-name}
that is also within the {\em block-assignment-statement},
then `{\tt next} {\em variable-name}' will be automatically added
to the {\em variable-declarations} of the {\em block-assignment-statement},
if it is not already there.  For example:
\begin{indpar}\begin{verbatim}
int x = 5
do:
    next x = x + 1
\end{verbatim}\end{indpar}
is equivalent to:
\begin{indpar}\begin{verbatim}
int x = 5
next x = do:
    next x = x + 1
\end{verbatim}\end{indpar}

\subsubsubsection{Deferred Assignment Statements}
\label{DEFERRED-ASSIGNMENT-STATEMENTS}

The syntax of {\em defer\-red-assignment-state\-ments} is:

\begin{indpar}
\emkey{deferred-assignment-statement} ::= \\
\hspace*{0.3in}
    \begin{tabular}[t]{@{}l}
        {\em deferred-variable-declaration}
                \{ \TT{,} {\em deferred-variable-declaration} \}\QMARK{}
		     \TT{=} \ttkey{*DEFERRED*} \\
    \end{tabular}
\\[0.5ex]
{\em deferred-variable-declaration} ::=
    see \pagref{DEFERRED-VARIABLE-DECLARATION}
\end{indpar}

Each variable declared by a {\em deferred-variable-declaration}
of a {\em deferred-assignment-statement} must be declared identically,
except for addition or subtraction of an {\em allocation-call},
as a {\em block-variable-declaration} of a {\em block-assignment-statement}
that is within the scope\pagnote{SCOPE} of the
{\em deferred-assignment-statement}.  The {\em block-assignment-statement},
known as the \key{companion} of the {\em deferred-variable-declaration},
computes the value of the
declared variable, except in the case of a pointer variable whose value is
set by an {\em allocation-call} in the {\em deferred-assignment-statement}.
If a {\em deferred-assignment-statement} is in a module
(\itemref{MODULE-AND-BODY-DECLARATIONS}), companions
of its {\em deferred-variable-declarations}
must be in that module or its bodies.

A pointer variable may have an {\em allocation-call} in either its
{\em deferred-assignment-statement} or in its companion, but not
both.

A {\em deferred-assignment-statement} initializes the variables it declares
in the same manner as a {\em block-assignment-statement}.

{\em Deferred-assignment-statement} variable initialization is the
same as {\em block-assignment-state\-ment} variable initialization,
except that after the statement the variables
are made {\em ro} and not {\em co} if they are not set
by an {\em allocation-call} in the {\em deferred-assignment-statement}.
Code that reads such {\tt ro} variables
before companions compute their values will
read zero.  For pointers this will typically reference undefined memory which
will cause a memory fault if accessed.

The variables declared in a {\em deferred-assignment-statement} are treated as
normal {\em block-vari\-able-declaration} variables inside their companions.
In particular the {\tt ro} variables are {\tt *WRITE-\EOL ONLY*}
inside their companions, and the {\tt co} pointer variables set by
an {\em allocation-call} in their {\em deferred-assignment-statement}
have their target type changed to {\tt *WRITE-ONLY*}
inside their companions.

\subsubsubsection{Loop Assignment Statements}
\label{LOOP-ASSIGNMENT-STATEMENTS}

A {\em loop-assignment-statement} has the syntax:

\begin{indpar}
\emkey{loop-assignment-statement} ::= \\
\hspace*{0.5in}
    \begin{tabular}[t]{@{}rll}
        & {\em next-variable-declaration}
                \{ \TT{,} {\em next-variable-declaration} \}\QMARK{}
		\TT{=} \\
	& ~~~~~~~~~~~~~~~ {\em iteration-control} \TT{:} \\
        & ~~~~~ {\em statement}\STAR{} \\
        & ~~~~~ {\em exit-sublock}\STAR{} \\
    $|$ & {\em iteration-control} \TT{:} \\
        & ~~~~~ {\em statement}\STAR{} \\
        & ~~~~~ {\em exit-sublock}\STAR{} \\
    \end{tabular}
\\[0.5ex]
\emkey{iteration-control}\label{ITERATION-CONTROL}
    \begin{tabular}[t]{rl}
     ::= & {\em loop-label}\QMARK{} \ttkey{loop}
	   \{ \{ \ttkey{at most} \}\QMARK{}
	   {\em int-expression} \ttkey{times} \}\QMARK{} \\
     $|$ & \ttkey{while} {\em bool-expression} \\
     $|$ & \ttkey{until} {\em bool-expression} \\
     \end{tabular}
\\[0.5ex]
\emkey{loop-label} ::= {\em statement-label}
\\[0.5ex]
\emkey{statement-label} ::= see \pagref{STATEMENT-LABEL} \\
\\[0.5ex]
\emkey{int-expression} ::= {\em expression} evaluating to an {\tt int}
\\[0.5ex]
\emkey{bool-expression}\label{BOOL-EXPRESSION} ::=
    \begin{tabular}[t]{@{}l}
    {\em expression} evaluating at run-time to a {\tt bool} \\
    or at compile-time to the {\em const} value {\tt "TRUE"} or {\tt "FALSE"}
    \end{tabular}
\\[0.5ex]
\emkey{loop-control-statement}\label{LOOP-CONTROL-STATEMENT} ::=
    {\em break-statement} $|$ {\em continue-statement}
\\[0.5ex]
\emkey{break-statement}\label{BREAK-STATEMENT} ::=
    \ttkey{break} {\em loop-label}\QMARK{}
\\[0.5ex]
\emkey{continue-statement}\label{CONTINUE-STATEMENT} ::=
    \ttkey{continue} {\em loop-label}\QMARK{}
\end{indpar}

A {\em loop-assignment-statement} is the semantic equivalent of
a sequence of zero or more copies of the statement with
its {\em iteration-control} replaced by `{\tt do}', making these copies into
{\em block-assignment-statements}.  Each copy is called an
\key{iteration} of the {\em loop-assignment-statement}.
The number of iterations is
determined at run-time according by the {\em iteration-control}
and {\em loop-control-statements}.

A simple example is:
\begin{indpar}\begin{verbatim}
int sum = 0
int i = 1;
next sum, next i = while sum < 4:
    next sum = sum + i
    next i = i + 1
\end{verbatim}\end{indpar}
which is semantically equivalent to:
\begin{indpar}\begin{verbatim}
int sum = 0
int i = 1;
next sum, next i = do:
    next sum = sum + i
    next i = i + 1
next sum, next i = do:
    next sum = sum + i
    next i = i + 1
next sum, next i = do:
    next sum = sum + i
    next i = i + 1
// Now sum == 6 and i == 4
\end{verbatim}\end{indpar}

However at run-time the variable values of all but the
last 4 iterations of the {\em loop-assignment-statement}
are discarded, which would not be the case if the compiler
actually inserted iterations in the source code. 
This only affects debugging.

The {\em break-statement} exits the current iteration of the
{\em loop-assignment-statement} and prevents further iterations.
A {\em continue-statement} exits the current iteration of the
{\em loop-assignment-statement} but lets the
{\em iteration-control} determine whether there will be any
more iterations.  If there are nested loops, a {\em loop-label}
may be used with these statements to designate which nested iteration
is being exited.

As in {\em block-assignment-statements}, if `{\tt next V}' occurs
as an {\em assignment-result} within the loop {\em statements}
but is not within the scope of a {\em result-variable-declaration}
for {\tt V} that is also within the {\em loop-assignment-statement},
`{\tt next V}' will be added to the {\em next-variable-declaration}
list of the {\em loop-assignment-statement}.  Therefore the
above example could be written as:
\begin{indpar}\begin{verbatim}
int sum = 0
int i = 1;
next sum = while sum < 4
    next sum = sum + i
    next i = i + 1
\end{verbatim}\end{indpar}
or
\begin{indpar}\begin{verbatim}
int sum = 0
int i = 1;
while sum < 4
    next sum = sum + i
    next i = i + 1
\end{verbatim}\end{indpar}

\subsubsection{Conditional Statements}
\label{CONDITIONAL-STATEMENTS}

A {\em conditional-statement} executes another {\em statement}
or block of {\em statements} according to what a
{\em bool-expression} evaluates to.
{\em Conditional-statements} have the syntax:

\begin{indpar}
\emkey{conditional-statement} ::= \\
\hspace*{0.5in}\begin{tabular}[t]{rl}
        & \ttkey{if} {\em bool-expression} \TT{:} \\
	& ~~~~~ {\em statement}\STAR{} \\
    $|$ & \ttkey{else if} {\em bool-expression} \TT{:} \\
	& ~~~~~ {\em statement}\STAR{} \\
    $|$ & \ttkey{else} \TT{:} \\
	& ~~~~~ {\em statement}\STAR{} \\
    $|$ & \ttkey{if} {\em bool-expression} \TT{:} {\em statement} \\
    $|$ & \ttkey{else if} {\em bool-expression} \TT{:} {\em statement} \\
    $|$ & \ttkey{else} \TT{:} {\em statement} \\
	\end{tabular}
\\[0.5ex]
\emkey{bool-expression} ::= see \pagref{BOOL-EXPRESSION}
\\[1ex]
where
\begin{itemize}
\item An `{\tt else if}' or `{\tt else}' {\em statement} must be immediately
preceded by an `{\tt if}' or `{\tt else if}' {\em statement}.
\end{itemize}
\end{indpar}

An example is:
\begin{indpar}\begin{verbatim}
int x = 5
int y = 6
int z:
    int sum = x + y         // Sets sum = 11
    int product = x * y     // Sets product = 30
    if sum < product:
        z = sum             // Sets z = 11
    else: z = product       // Is NOT executed
// Now z = 11
\end{verbatim}\end{indpar}

\subsubsection{Declarations}
\label{DECLARATIONS}

The following is a complete list of declarations:
\begin{indpar}
\emkey{declaration}\label{DECLARATION}
    \begin{tabular}[t]{@{}rll}
    ::= & {\em result-variable-declaration}
        & [\pagref{RESULT-VARIABLE-DECLARATION}] \\
    $|$ & {\em next-variable-declaration}
        & [\pagref{NEXT-VARIABLE-DECLARATION}] \\
    $|$ & {\em block-variable-declaration}
        & [\pagref{BLOCK-VARIABLE-DECLARATION}] \\
    $|$ & {\em prototype-result-declaration}
        & [\pagref{PROTOTYPE-RESULT-DECLARATION}] \\
    $|$ & {\em prototype-argument-declaration}
        & [\pagref{PROTOTYPE-ARGUMENT-DECLARATION}] \\
    $|$ & {\em declaration-statement} \\
    \end{tabular}
\\[0.5ex]
\emkey{declaration-statement}\label{DECLARATION-STATEMENT}
    \begin{tabular}[t]{@{}rll}
    ::= & {\em type-declaration}
        & [\pagref{TYPE-DECLARATIONS}] \\
    $|$ & {\em pointer-type-declaration}
        & [\pagref{POINTER-TYPE-DECLARATIONS}] \\
    $|$ & {\em inline-function-declaration}
        & [\pagref{INLINE-FUNCTION-DECLARATIONS}] \\
    $|$ & {\em out-of-line-function-declaration}
        & [\pagref{OUT-OF-LINE-FUNCTION-DECLARATIONS}] \\
    \end{tabular}
\end{indpar}


\subsubsubsection{Type Declarations}
\label{TYPE-DECLARATIONS}

The syntax of a type declaration is:

\begin{indpar}
\emkey{type-declaration}\label{TYPE-DECLARATION}
    \begin{tabular}[t]{rl}
    ::= & \ttkey{type} {\em defined-type-name} \TT{:} \\
	& \TT{~~~~~}{\em type-subdeclaration}\STAR{} \\
    $|$ & \ttkey{type} {\em defined-type-name} \TT{:} \ttkey{*DEFERRED*} \\
    \end{tabular} \\
\emkey{defined-type-name} ::= {\em type-name} \\
\emkey{type-name} ::= see \pagref{TYPE-NAME}
\\[2ex]
\emkey{type-subdeclaration}
    \begin{tabular}[t]{@{}rl}
    ::= &  {\em field-declaration} \\
    $|$ &  \ttkey{*EXPANDABLE*} \\
    $|$ &  \ttkey{*EXTERNAL*} \\
    $|$ &  \ttkey{align} {\em alignment}\QMARK{} \\
    $|$ &  \ttkey{pack} \\
    $|$ &  \ttkey{include} {\em defined-type-name} \\
    $|$ &  \ttkey{*LABEL*} {\em origin-label} \\
    $|$ &  \ttkey{*ORIGIN*} {\em origin-label} \\
    \end{tabular}
\\[2ex]
\emkey{field-declaration}
    \begin{tabular}[t]{@{}rl}
    ::= &  {\em field-without-subfields-declaration} \\
    $|$ &  {\em field-with-subfields-declaration} \\
    \end{tabular}
\\[2ex]
\emkey{field-without-subfields-declaration} ::= \\
\hspace*{0.5in}\begin{tabular}{rl}
        & {\em qualifier-name}\STAR{} {\em field-type-name}~
          {\em target-label}~ {\em field-dimension}\STAR{} \\
    $|$ & {\em qualifier-name}\STAR{} {\em pointer-type-name} \\
        & ~~~~~ {\em qualifier-name}\STAR{} {\em field-type-name}~
                {\em pointer-label}~ {\em field-dimension}\STAR{}
	\end{tabular}
\\[2ex]
\emkey{field-with-subfields-declaration} ::= \\
\hspace*{0.5in}
    {\em qualifier-name}\STAR{}
    \TT{std}\QMARK{} {\em number-type-name}~ {\em target-label}\QMARK{}
                {\em field-dimension}\STAR{} \\
\hspace*{0.5in}
    {\em subfield-declaration}\PLUS{}
\\[2ex]
\emkey{field-type-name} ::= \TT{std}\QMARK{} {\em number-type-name}
                        $|$ {\em defined-type-name} \\
\emkey{number-type-name}
    \begin{tabular}[t]{@{}rl}
    ::= &  \ttkey{int} $|$ \ttkey{int8} $|$ \ttkey{int16} $|$ \ttkey{int32}
                       $|$ \ttkey{int64} $|$ \ttkey{int128} \\
    $|$ &  \ttkey{uns} $|$ \ttkey{uns8} $|$ \ttkey{uns16} $|$ \ttkey{uns32}
                       $|$ \ttkey{uns64} $|$ \ttkey{uns128} \\
    $|$ &  \ttkey{flt} $|$ \ttkey{flt16} $|$ \ttkey{flt32} $|$ \ttkey{flt64}
                         $|$ \ttkey{flt128} \\
    \end{tabular}
\\[2ex]
\emkey{field-label}\label{FIELD-LABEL} ::=  {\em data-label} \\
\emkey{pointer-label}\label{POINTER-LABEL} ::=
    {\em field-label} beginning with zero or more `\TT{.}'s followed by
    an `\TT{@}' \\
\emkey{target-label}\label{TARGET-LABEL} ::=
    {\em field-label} that is \underline{not} a {\em pointer-label} \\
\emkey{origin-label}\label{ORIGIN-LABEL} ::=  {\em target-label} \\
\emkey{data-label} ::=  see \pagref{DATA-LABEL}
\\[2ex]
\emkey{field-dimension} ::=  \TT{[} {\em dimension-size} \TT{]} \\
\emkey{dimension-size} ::=  compile-time {\em expression}
			    with non-negative integer value
\\[2ex]
\emkey{subfield-declaration} ::= \\
\hspace*{0.5in}
    {\em bit-range} {\em subfield-type-name} {\em subfield-label}
    		{\em subfield-dimension}\STAR{} \\
\emkey{subfield-type-name}\label{SUBFIELD-TYPE-NAME} ::=
    {\em number-type-name} $|$ \TT{bool} \\
\emkey{subfield-label}\label{SUBFIELD-LABEL} ::=  {\em target-label} \\
\emkey{subfield-dimension} ::=  \TT{[} {\em dimension-size} \TT{]} \\
\\[2ex]
\emkey{bit-range}
    \begin{tabular}[t]{@{}rl}
    ::= &  \TT{[} {\em onlybit} \TT{]} \\
    $|$ &  \TT{[} {\em lowhighbits} \TT{]} \\
    $|$ &  \TT{[} {\em highbit} \TT{-} {\em lowbit} \TT{]}
    \end{tabular} \\
\emkey{onlybit} ::= compile-time {\em expression}
		    with non-negative integer value \\
\emkey{lowhighbits} :::= {\em dit}+ \TT{-} {\em dit}+
           ~~~~~ [this is a single lexeme] \\
\emkey{lowbit} ::= compile-time {\em expression}
		   with non-negative integer value \\
\emkey{highbit} ::= compile-time {\em expression}
		    with non-negative integer value \\
\emkey{dit} ::= see \pagref{DIT}
\\[2ex]
\emkey{alignment} ::= compile-time {\em expression}
		      with power of 2 integer value
\end{indpar}

The {\em type-subdeclarations} are processed in order.  At the
beginning of each, there is a align/pack switch value and an
offset-in-bits integer.  These determine the offset in bits
of the next {\em field-declaration} field encountered
relative to the beginning of each datum of the new data
type being declared.  At the beginning of each {\em type-declaration}
the align/pack switch is set to align and the offset is set to zero.

If the align/pack switch is in the \key{align} position and the
next {\em type-subdeclaration} is a {\em field-declaration}, the
current offset will be incremented before becoming the offset
of the field being declared.  The increment will be just enough
to make the offset an exact multiple of the field's type's alignment.
The alignment of a number type is its size in bits.  The alignment
of a defined type is the least common multiple of the alignment of
any of its fields, which, since all alignments are powers of two,
is the same as the largest alignment of any of the fields.

An `\ttkey{align} $N$' sub-declaration behaves like an unnamed
field of alignment $N$ and zero length,
and in addition sets the align/pack switch to `align'.
An `\ttkey{align}' sub-declaration just sets the
align/pack switch to `align'.

A \ttkey{pack} sub-declaration sets the align/pack switch to `pack'.

A \ttkey{include} sub-declaration copies all the {\em type-subdeclarations}
of the given defined type into the current sequence of
{\em type-subdeclarations}.

If the first sub-declaration of a {\em type-declaration}
is either {\tt *EXPANDABLE*}\label{*EXPANDABLE*}
or {\tt *EXTERNAL*}\label{*EXTERNAL*} there may
be multiple {\em type-declarations} with the same
{\em type-name}, all of which must have the same first
sub-declaration.  All act
to append {\em type-subdeclarations}\label{TYPE-DECLARATION-APPEND}
to the current list of such for the {\em type-name}.
All {\em type-declarations} for a given {\em type-name} but the first
must be within the scope (see \itemref{SCOPE}) of the first
{\em type-declaration}.   All but the first are called
\skey{expansion}s of the first {\em type-declaration}.
Either {\tt *EXPANDABLE*} or {\tt *EXTERNAL*} may be a
sub-declaration of a {\em type-declaration}, but not both.

For a {\em type-declaration} with an \ttkey{*EXPANDABLE*} sub-declaration,
its expansions must be in the same module\pagnote{MODULE-AND-BODY-DECLARATIONS}
as the {\em type-declaration}, or in one of that module's bodies.
For a {\em type-declaration} with an \ttkey{*EXTERNAL*} sub-declaration
there is no such restriction, and the expansion may be in
in any module or body that imports the {\em type-declaration}'s
module.

At the beginning of each expansion the offset is set to zero and
the align/pack switch is set to align.

A \ttkey{*DEFERRED*} {\em type-declaration} is just syntactic
sugar for a {\em type-declaration} with \underline{no} sub-declarations.
Such a {\em type-declaration} is typically used allow the {\em type-name}
to be used as the target type of a pointer.

The {\em type-name} in a {\em type-declaration} is declared before
the {\em type-declaration}'s sub-declarations are processed, so these
sub-declarations may use the {\em type-name} as a pointer target type.

A \ttkey{*LABEL*} sub-declaration assigns the current offset to the
given {\em origin-label} and provides the {\em origin-label}
for use by subsequent {\tt *ORIGIN*} sub-declarations.

An \ttkey{*ORIGIN*} sub-declaration changes the current offset to that
of the given {\em origin-label}.
The {\em origin-label} must be defined by a preceding
{\tt *LABEL*} sub-declaration.

An {\em origin-label} may be re-used.  Its use in an {\tt *ORIGIN*}
sub-declaration refers to its most recent previous use in a {\tt *LABEL*}
statement.

Care must be exercised when using {\tt *LABEL*} and {\tt *ORIGIN*},
as both type-violations and unexpected field allocations can result.
Note that if there are multiple {\em type-declarations}
with the same {\em type-name} in different
modules and bodies,\pagnote{MODULE-AND-BODY-DECLARATIONS}
the order in which these {\em type-declarations} are processed
may not be completely determined.

A field of a value of a user defined type are accessed by prepending
`\TT{.}' to the {\em field-label} to form a {\em member-name} in
a {\em reference-expression} (see \pagref{FIELD-SELECTION}).
An example is:

\begin{indpar}\begin{verbatim}
type my type:
    uns8    kind         // Object Kind
    flt weight

my type X:
    // Within this block X is write-only.
    X.kind = HIPPOPOTAMUS
    X.weight = 152.34
uns8 kind = X.kind
flt weight = X.weight
\end{verbatim}\end{indpar}

If a {\em field-label} is a {\em pointer-label}, an
associated {\em target-label} is declared consisting of the
{\em pointer-label} minus its first `{\tt @}'.  The {\em target-label}
references a virtual field consisting of the target value stored
at the location pointed at by the {\em pointer-label} field's pointer.
An example is:

\begin{indpar}\begin{verbatim}
type list element:
    int value
    ap list element @next

// Make doubly linked circular list.
//
list element @Y =@ local = *DEFERRED*
list element @X =@ local:
    X.value = 1
    X.@next = @Y
list element @Y:
    Y.value = 2
    Y.@next = @X
//
// Now X.value == 1 and X.next.value == 2 and
// similarly Y.value == 2 and Y.next.value == 1,
// while X.@next == @Y and Y.@next == @X are
// pointers to local memory.
\end{verbatim}\end{indpar}

The size and alignment of a defined type with an {\tt *EXPANDABLE*}
or {\tt *EXTERNAL*}
sub-declara\-tion are not known at compile-time.  They are computed
during load-time and used as run-time constants.
Allocators use this size and alignment to allocate memory for a value of
the type and then zero that memory.
A field of
the defined type can only be accessed by code in the scope
of a {\em type-declaration} declaring the field.

An example is:

\begin{indpar}\begin{verbatim}
type my type : *DEFERRED*
ap *READ-WRITE* my type @X =@ local
                    // Legal, my type members need not be declared.
                    // The allocated my type value will be zeroed.
ap ro @Y = @X       // Legal, only ap copied.
my type Z = X       // Legal, Z is allocated as per `local'
                    // and the value at @X is copied to
                    // the location of Z.  However in this
                    // case the value is zero.
type my type:
    *EXPANDABLE*
    *LABEL* origin  // `origin' is set to offset 0
    int I
X.I = 55            // Legal, .I has been declared.

type my type:       // Extension of my type
    *EXPANDABLE*
    int J           // Now X.J == 0
X.J = 66            // Legal, .J has been declared.

type my type:
    *EXPANDABLE*
    *ORIGIN* origin
    int K1
    int K2

// Now X.K1 == X.I == 55; X.K2 == X.J == 66,
// but you must be sure about how packing is
// done to believe this.
\end{verbatim}\end{indpar}

Subfields are parts of the previously declared numeric field.
The bits occupied
by a subfield are given by its {\em bit-range}, where bits are numbered
0, 1, \ldots{} from the low order end of numbers.

A subfield value may have fewer bits than the number-type of the subfield.
For integer types, the value is the low order bits of the integer, with
the high order bits added when the value is read by with adding 0 bits
for unsigned integers or copies of the highest order bit for signed integers.
For floating types, the value is missing low order mantissa bits, which
are added as zeros.  If a value outside the representable range is stored,
it is not an error.  Integer values are truncated, and floating values
have low order mantissa bits dropped (there is no rounding).  However, it is
a compile error to have a floating type whose exponent part plus
1 mantissa bit cannot be stored in the subfield value.

{\em Subfield-labels} and {\em field-labels} have the same standing within
{\em reference-expressions}.
Both have associated {\em member-names} made by adding a single
`\TT{.}' to the beginning of the {\em field-label} or {\em subfield-label}.
For example:

\begin{indpar}\begin{verbatim}
type my type:
    uns8    kind         // Object Kind
    [0] bool animal      // True if Animal
    [1] bool vegetable   // True if Vegetable
    flt weight

my type X:
    // Within this block X is write-only.
    X.kind = HIPPOPOTAMUS
        // Also sets animal and vegetable bits.
    X.weight = 152.34
uns8 kind = X.kind
bool animal = X.animal
bool vegetable = X.vegetable
flt weight = X.weight
\end{verbatim}\end{indpar}

If a {\em field-declaration} with {\em field-label}\, {\tt L} contains 
a single {\em field-dimension} {\tt [$n$]} then $n$ fields are
allocated to ascending offsets, using zero padding
if necessary to align all $n$ fields.  The labels of these
fields are {\tt L[$i$]} for $0\le i<n$.  If there is a subfield
labeled {\tt S} of the field, {\tt S[$i$]} refers to the
subfield in {\tt L[$i$]}.  For example:

\begin{indpar}\begin{verbatim}
type character attributes:
    uns8 [128]
    [0] bool is graphic

character attributes X:
    int i = 0;
    while i < 128:
        X.is graphic[i] = 32 < i && i < 127
        next i = i + 1
bool line feed is graphic = X.is graphic [C#"<LF>"]
bool A is graphic = X.is graphic [C#"A"]
\end{verbatim}\end{indpar}

In a {\em field-declaration}
\underline{two} {\em field-dimensions} {\tt [$n1$][$n2$]} is
treated as syntactic sugar for {\tt [$n1$*$n2$]} with
{\tt L[$i1$][$i2$]} being syntactic sugar for
{\tt L[$i1$*$n2$+$i2$]}.  Similarly
{\tt [$n1$][$n2$][$n3$]} is
syntactic sugar for {\tt [$n1$*$n2$*$n3$]} with
{\tt L[$i1$][$i2$][$i3$]} being syntactic sugar for
{\tt L[$i1$*$n2$*$n3$*+$i2$*$n2$+$i3$]}.  And so forth for any
number of {\em field-dimensions}.

If a {\em subfield-declaration} with {\em subfield-label}\, {\tt S} contains 
{\em subfield-dimension} {\tt [$n$]} then $n$ subfields are
allocated to the containing field, starting with the bits
designated by the {\em subfield-declaration}'s {\em bit-range}
and adding the number of bits in the {\em bit-range} to each integer
in the {\em bit-range} for each successive subfield.
For example:

\begin{indpar}\begin{verbatim}
type hex digits:
    uns32
    [0-3] uns hex digit [8]

hex digits X:
    int i = 0;
    while i < 8:
        X.hex digit[i] = i
        next i = i + 1
// Now X == X#"76543210"
\end{verbatim}\end{indpar}

A {\em subfield-declaration} with more than one {\em subfield-dimension} is
treated in the same manner as a {\em field-declaration} with
more than one {\em field-dimension}.  For example,
{\tt [$n1$][$n2$][$n3$]} is
syntactic sugar for {\tt [$n1$*$n2$*$n3$]} with
{\tt L[$i1$][$i2$][$i3$]} is syntactic sugar for
{\tt L[$i1$*$n2$*$n3$*+\EOL $i2$*$n2$+\EOL $i3$]}.

If a {\em field-declaration} with {\em field-label} {\tt F}
has a {\em field-dimension}
and also a subfield with {\em subfield-label} {\tt L}, then
{\tt L[$i$]} references the subfield in the field value {\tt F[$i$]}.
If in addition the subfield has a {\em subfield-dimension},
{\tt L[$i$][$j$]} references the subfield selected by {\tt [$j$]}
in the field value {\tt F[$i$]}.


\subsubsubsection{Pointer Type Declarations}
\label{POINTER-TYPE-DECLARATIONS}

A pointer type has an
\key{associated data type}\label{POINTER-ASSOCIATE}
specified by a pointer type declaration.  The syntax is:

\begin{indpar}
\emkey{pointer-type-declaration}\label{POINTER-TYPE-DECLARATION} ::= \\
\hspace*{0.5in}\ttkey{pointer type} {\em defined-pointer-type-name}
	       \TT{is} {\em type-name}
\\[0.5ex]
\emkey{pointer-type-name} ::= see \pagref{POINTER-TYPE-NAME}
\\[0.5ex]
\emkey{type-name} ::= see \pagref{TYPE-NAME}
\end{indpar}
An {\tt *UNCHECKED*} conversion is defined from the associated data
type to data with the given pointer type, and an normal conversion
is defined in the other direction.

It is important that there be a 1-1 correspondance between
pointer types and their associated data types.  In particular,
{\tt int} must not be used as the associated data type of
more than one pointer type.  This is why associated data types
are generally user defined types.

For example, the following are builtin:

\begin{indpar}\begin{verbatim}
pointer type dp is data for dp
pointer type ap is data for ap
type data for dp:
    int address
type data for ap:
    dp ro int @base
    int offset

function dp Q$1 T$1 r = *UNCHECKED* ( data for dp dap )
function ap Q$1 T$1 r = *UNCHECKED* ( data for ap dap )
function data for dp r = pointer to data ( dp Q$1 T$1 ptr )
function data for ap r = pointer to data ( ap Q$1 T$1 ptr )
    // These functions just copy the argument value to the
    // result value changing the type of the value.  Here
    // Q$1 is a wild-card that matches any list of qualifier-names,
    // and T$1 is a wild-card that matches any type-name.

// This function enables implicit conversion of `dp ...' to
// `ap ...', where the latter has the constant 0 for a base
// and the dp value for its offset.
// 
function data for ap r = *IMPLIED* *POINTER* *CONVERSION*
        ( data for dp d ):
    dp int @zero = constant int 0
        // constant int 0 allocates an int equal to 0 to co memory
    data for ap dap:
        dap.@base  = @zero
        dap.offset = d.address
    r = dap

// This function enables *UNCHECKED* conversion of `ap ...' to
// `dp ...' where the latter is the sum of the base and offset
// of the ap.
//
function data for dp r = *UNCHECKED* *POINTER* *CONVERSION*
        ( data for ap d ):
    data for dp ddp:
        ddp.address = d.base + d.offset
    r = ddp

// This function enables conversion of `ap ...' to `dp ...'
// when an ap pointer is being used to access a value or
// member or element of a value.  The dp is the sum of the
// base and offset of the ap.
//
function data for dp r = *ACCESS* *POINTER* *CONVERSION*
        ( data for ap d ):
    data for dp ddp:
        ddp.address = d.base + d.offset
    r = ddp
\end{verbatim}\end{indpar}

A {\em pointer-type-declaration} `{\tt pointer type $P$ is $D$}'
implicitly declares the functions:
\begin{indpar} \tt
function $P$ Q\$1 T\$1 r = *UNCHECKED* ( $D$ data ) \\
function $D$ r = pointer to data ( $P$ Q\$1 T\$1 ptr )
\end{indpar}
These just copy values changing type.

Reading and writing values using a pointer of type $P$ and
associated data type $D$ can be accomplished by the functions:

\begin{indpar} \tt
function Q\$1 T\$1 r = *POINTER* *ACCESS* ( $D$ data ) \\
function *POINTER* *ACCESS* ( $D$ data ) = Q\$1 T\$1 r
\end{indpar}

These functions can be defined after $P$ is defined.
They allow the pointer to be used to read a copy of the
value pointed at, or write the value, but do not allow
members or elements of the value to be accessed
(members and elements of the copy may be accessed).

These functions are implicitly called when the target
of a pointer variable is read or written.  For example:
\begin{indpar}\begin{verbatim}
ap int @p = local:
p = 5
  // This translates to:
  //   *POINTER* *ACCESS* ( pointer to data ( p ) ) = 5
int x = p
  // This translates to:
  //   x = *POINTER* *ACCESS* ( pointer to data ( p ) )
\end{verbatim}\end{indpar}

An alternative strategy is to convert a pointer of type $P1$
to a pointer of type $P2$ that allows members and elements
to be accessed.  Suppose we are given:
\begin{indpar} \tt
pointer type $P1$ is $D1$ \\
pointer type $P2$ is $D2$
\end{indpar}

Then we can define a function with the prototype:
\begin{indpar} \tt
function $P2$ Q\$1 T\$1 r = *ACCESS* *CONVERSION* ( $P1$ Q\$1 T\$1 p )
\end{indpar}
which converts a pointer of type $P1$ to a pointer of type $P2$.
Only one such function can be defined for each pointer type $P1$.
This conversion function
is called if a value pointed at by a pointer of type $P1$ is to
be accessed, in preference to calling the {\tt *POINTER* *ACCESS*}
functions.  Then if $P2$ is {\tt dp}, {\tt ap}, {\tt fp}, {\tt av},
or {\tt fv}, the $P2$ pointer can be used to not only read or write
the value, but to also read or write members or elements of the
value.  Note, however, that only one {\tt *ACCESS* *CONVERSION*}
function can be called per access: these functions do not
automatically chain.

Alternatively you can define a function with prototype
\begin{indpar} \tt
function $D2$ r = \ttkey{*ACCESS* *POINTER* *CONVERSION*} ( $D1$ data )
\end{indpar}
which implicitly defines the function:
\begin{indpar} \tt
function $P2$ Q\$1 T\$1 r = \ttkey{*ACCESS* *CONVERSION*}
	( $P1$ Q\$1 T\$1 p1 ): \\
\hspace*{0.3in}$D1$ d1 = pointer to data ( p1 ) \\
\hspace*{0.3in}$D2$ d2 = *ACCESS* *POINTER* *CONVERSION* ( d1 ) \\
\hspace*{0.3in}r = *UNCHECKED* ( d2 )
\end{indpar}

If a pointer of type $P1$ is to be implicitly
convertible to a pointer of type $P2$ when passing the
pointer to a function or storing the pointer in memory,
the above functions are not used.  Instead a function with
the prototype:
\begin{indpar} \tt
function $P2$ Q\$1 T\$1 r = *IMPLIED* *CONVERSION* ( $P1$ Q\$1 T\$1 p )
\end{indpar}
is called.  You can define this, or you can define
\begin{indpar} \tt
function $D2$ r = \ttkey{*IMPLIED* *POINTER* *CONVERSION*} ( $D1$ data )
\end{indpar}
which implicitly defines the function:
\begin{indpar} \tt
function $P2$ Q\$1 T\$1 r = \ttkey{*IMPLIED* *CONVERSION*}
	( $P1$ Q\$1 T\$1 p1 ): \\
\hspace*{0.3in}$D1$ d1 = pointer to data ( p1 ) \\
\hspace*{0.3in}$D2$ dd = *IMPLIED* *POINTER* *CONVERSION* ( d1 ) \\
\hspace*{0.3in}r = *UNCHECKED* ( d2 )
\end{indpar}

You may want the conversion from $P1$ to $P2$ to
be unchecked instead of implied.  This can be achieved by defining:
\begin{indpar} \tt
function $P2$ Q\$1 T\$1 r = *UNCHECKED* ( $P1$ Q\$1 T\$1 p )
\end{indpar}
Alternatively you can define a function with prototype
\begin{indpar} \tt
function $D2$ r = \ttkey{*UNCHECKED* *POINTER* *CONVERSION*} ( $D1$ data )
\end{indpar}
which implicitly defines the function:
\begin{indpar} \tt
function $P2$ Q\$1 T\$1 r = \TT{*UNCHECKED*}
	( $P1$ Q\$1 T\$1 p1 ): \\
\hspace*{0.3in}$D1$ d1 = pointer to data ( p1 ) \\
\hspace*{0.3in}$D2$ dd = *IMPLIED* *POINTER* *CONVERSION* ( d1 ) \\
\hspace*{0.3in}r = *UNCHECKED* ( d2 )
\end{indpar}

The example at the beginning of this section contains
all three kinds of {\tt \ldots{} *POINTER* *CONVERSION*} functions.

An example implementing a new pointer type is:

\begin{indpar}\begin{verbatim}
type file:
    *READ-WRITE* av uns8 name
    . . . . .
av *READ-WRITE* file @files = global [1000];
ap *READ-WRITE* int @next file = global

// Implement a file descriptor (fd) that addresses a file
// in files.  The fd contains an index and addresses
// files[index].

type data for fd:
    int index

pointer type fd is data for fd
function data for ap r = *ACCESS* *POINTER* *CONVERSION*
        ( data for fd d ):
    ap file @f = @files[d.index]
    r = pointer to data ( @f )
        // Qualifiers of @f are ignored by pointer to data.

function fd *READ-WRITE* r = allocate fd:
    data for fd d:
        d.index = next file
    r = *UNCHECKED* ( d )
    next file = next file + 1

fd *READ-WRITE* @f = allocate fd
f.name = ...
. . . . .
av uns8 n = f.name
. . . . .
\end{verbatim}\end{indpar}




\subsubsubsection{Inline Function Declarations}
\label{INLINE-FUNCTION-DECLARATIONS}

The syntax of a function declaration is:

\begin{indpar}[0.1in]
\emkey{function-declaration}\label{FUNCTION-DECLARATION}
    \begin{tabular}[t]{rl}
    ::= &  {\em function-prototype} \TT{:} \\
	& \TT{~~~~~}{\em statement}\PLUS{} \\
    $|$ &  {\em function-prototype}~ \TT{:}~ \ttkey{*DEFERRED*} \\
    \end{tabular}
\\[2ex]
\emkey{function-prototype}\label{FUNCTION-PROTOTYPE} ::= \\
\hspace*{0.25in}
    \begin{tabular}[t]{@{}rl}
        & \ttkey{function}~
          {\em prototype-result-list}~ \TT{=}~
          {\em module-abbreviation}\QMARK{}~
	                {\em prototype-pattern} \\
    $|$ & \ttkey{function}~ {\em module-abbreviation}\QMARK{}~
                           {\em prototype-pattern} \\
    $|$ & \ttkey{function}~ {\em module-abbreviation}\QMARK{}~
                           {\em prototype-pattern}~ \TT{=}~
                           {\em input-variable-list} \\
    \end{tabular}
\\[0.5ex]
\emkey{prototype-result-list}\label{PROTOTYPE-RESULT-LIST} ::= \\
\hspace*{0.5in}
    {\em prototype-result-declaration}
    \{ \TT{,} {\em prototype-result-declaration} \}\STAR{}
\\[0.5ex]
\emkey{prototype-result-declaration}\label{PROTOTYPE-RESULT-DECLARATION} \\
\hspace*{0.5in}\begin{tabular}[t]{rl}
    ::= & {\em result-variable-declaration} \\
    $|$ & {\em next-variable-declaration} \\
    \end{tabular}
\\[0.5ex]
{\em module-abbreviation} ::= see \pagref{MODULE-ABBREVIATION}
\\[0.5ex]
{\em result-variable-declaration} ::= see \pagref{RESULT-VARIABLE-DECLARATION}
\\[0.5ex]
{\em next-variable-declaration} ::= see \pagref{NEXT-VARIABLE-DECLARATION}
\\[0.5ex]
\emkey{input-variable-list} ::= \\
\hspace*{0.5in}{\em prototype-argument-declaration}
                 \{ \TT{,} {\em prototype-argument-declaration} \}\STAR{}
\\[0.5ex]
\emkey{prototype-argument-declaration}\label{PROTOTYPE-ARGUMENT-DECLARATION} \\
\hspace*{0.5in}\begin{tabular}[t]{@{}rl@{}}
    ::= & {\em result-variable-declaration}
          \{ \TT{?=} {\em default-value} \}\QMARK{} \\
    $|$ & \TT{bool} {\em variable-name}
          \TT{??} {\em default-value} \\
    $|$ & {\em result-variable-declaration}
          \TT{==} {\em required-value} \\
    \end{tabular}
\\[0.5ex]
\emkey{default-value} ::= {\em expression}
\\[0.5ex]
\emkey{required-value} ::= compile-time {\em expression}
\\[0.5ex]
{\em expression} ::= see \pagref{EXPRESSION}
\\[0.5ex]
\emkey{prototype-pattern}\label{PROTOTYPE-PATTERN}
    \begin{tabular}[t]{rl}
    ::= & {\em first-pattern-term}~ {\em pattern-term}\STAR{} \\
    $|$ & {\em pattern-argument-list}~ {\em pattern-argument-list}\PLUS{}
    \end{tabular}
\\[0.5ex]
\emkey{first-pattern-term} ::= {\em pattern-argument-list}\STAR{}~
				{\em pattern-term}
\\[0.5ex]
\emkey{pattern-term}
    ::= {\em function-term-name}~ {\em pattern-argument-list}\STAR{}
\\[0.5ex]
\emkey{function-term-name} ::= see \pagref{FUNCTION-TERM-NAME}
\\[0.5ex]
\emkey{function-variable-name}\label{FUNCTION-VARIABLE-NAME} ::= \\
\hspace*{0.5in}
    \begin{tabular}[t]{@{}p{5in}@{}}
    {\em function-term-name} $N$ that appears in a {\em function-prototype}
    of the form `{\tt function $N$ = \ldots}'
    \end{tabular}
\\[0.5ex]
\emkey{pattern-argument-list}\label{PATTERN-ARGUMENT-LIST} \\
\hspace*{0.5in}
    \begin{tabular}[t]{@{}rl}
    ::= & \TT{(} {\em prototype-argument-declaration}~
	     \{ \TT{,} {\em prototype-argument-declaration} \}\STAR{} \TT{)} \\
    $|$ & \TT{[} {\em prototype-argument-declaration}~
	     \{ \TT{,} {\em prototype-argument-declaration} \}\STAR{} \TT{]} \\
    \end{tabular}
\begin{itemize}
\item
A {\em prototype-pattern} or {\em function-call}
must have either a {\em function-term-name}
or at least two {\em argu\-ment-lists}.
\item
A {\em prototype-pattern} {\em function-term-name} must not be
an initial segment of any other {\em function-term-name}
in the same {\em prototype-pattern}.
\item
Result and argument {\em variable-names} and {\em function-variable-names}
in a {\em function-prototype} must not begin with a {\em module-abbreviation}.
\item
For a {\em prototype-result-declaration} of the form `\TT{next} $v$',
$v$ must be the {\em vari\-able-name} in an {\em prototype-argument-declaration}
of the form `\dots{} {\em type-name} $v$', and
any actual argument associated to the {\em prototype-argument-declaration}
must be a {\em variable-name} $w$ for which `\TT{next} $w$' is a legal
{\em assignment-statement} {\em next-variable-declaration}.
\item
Result and argument {\em variable-names}
in a {\em function-prototype} must
be distinct, with an exception for the previous paragraph.
\item
The first {\em prototype-argument-declaration} in an {\em input-variable-list}
must not have a {\em default-value}.
\item
In a {\em pattern-argument-list} or {\em input-variable-list}
an {\em prototype-argument-declaration} with no {\em de\-fault-value} cannot
follow an {\em prototype-argument-declaration} with a {\em default-value}.
\item
A wild-card\pagnote{WILD-CARD} name of the form {\tt T\$\ldots}
is treated in a {\em function-prototype} as a {\em type-name}.
A wild-card name of the form {\tt P\$\ldots} is treated as a
{\em pointer-type-name}.
A wild-card name of the form {\tt Q\$\ldots} is treated as a
{\em qualifier-name} and \underline{must not} be combined with
other {\em qualifier-names} in the same {\em result-variable-declaration}
or {\em prototype-argument-declaration}.

\end{itemize}
\end{indpar}

An example of an inline function declaration and an inline function call is:
\begin{indpar}\begin{verbatim}
function F ( int x ?= 5 ) G ( int y ) H ( int z ?= 7 ) I ( int w ):
    . . . . . . . . . .
F I ( 8 ) G ( 6 )    // Equivalent to F ( 5 ) G ( 6 ) H ( 7 ) I ( 8 )
\end{verbatim}\end{indpar}

The {\em function-term-names} in the declaration are matched to those
in the call, but need not have the same order in the call, except for
the first {\em function-term-name} which must be the same in the
declaration and the call.  Thus the {\em call-terms} of the call
are re-ordered to match the order of the {\em pattern-terms} of the
declaration.  If one of the {\em pattern-terms} is omitted in the
call, but its arguments have {\em default-values}
the {\em pattern-term} with its
{\em default-values} will be inserted into the call
(here {\tt H ( 7 )} is inserted).
Similarly with an {\em argument-list} that is omitted
(here {\tt ( 5 )} is inserted).

An example containing an {\em input-variable-list} is:
\begin{indpar}\begin{verbatim}
function F [ int x ] = int y,  int z ?= 5:
    . . . . . . . . . .
F[10] = 6
\end{verbatim}\end{indpar}
which is treated as if {\tt =} were a {\em function-term-name}
that must be the last such in the call, and the comma separated
values in the call and {\em prototype-argument-declarations} in the prototype
were surrounded by parentheses {\tt (~)}.  Note that for an argument
list in the prototype to match an argument list in the call, both
must be surrounded by the same brackets; either both have {\tt (~)}
or both have {\tt [~]}.

Note that {\em quoted-marks} and {\em quoted-separators}
in {\em function-term-names} may appear with or without quotes in
{\em call-term-names}.\pagnote{CALL-TERM-NAME}  Thus we have the example:
\begin{indpar}\begin{verbatim}
function int z = ( int x ) "@@" ( int y ):
    . . . . . . . . . .
int v = 5 @@ 6       // Legal
int w = 5 "@@" 6     // Legal
\end{verbatim}\end{indpar}

A {\em pattern-term} with the syntax:
\begin{indpar}
\emkey{boolean-pattern-term}\label{BOOLEAN-PATTERN-TERM} ::= \\
\hspace*{1in} {\em function-term-name} \TT{(}
        \TT{bool} {\em variable-name}
	\TT{??} {\em default-value} \TT{)}
\end{indpar}

triggers special syntax in a call that matches the prototype.
In the call:
\begin{center}
\begin{tabular}{rcl}
{\em function-term-name} & is equivalent to
                         & {\em function-term-name} \tt ( true ) \\
\TT{no} {\em function-term-name} & is equivalent to
                         & {\em function-term-name} \tt ( false ) \\
\TT{not} {\em function-term-name} & is equivalent to
                         & {\em function-term-name} \tt ( false ) \\
omitted {\em function-term-name} & is equivalent to
                         & {\em function-term-name}
			   \TT{(} {\em default-value} \TT{)} \\
\end{tabular}
\end{center}
Thus the example:
\begin{indpar}\begin{verbatim}
function F ( int x ) OPTION ( bool y ?? true )
    . . . . . . . . . .
F ( 5 )            // Equivalent to F ( 5 ) OPTION ( true )
F ( 5 ) OPTION     // Equivalent to F ( 5 ) OPTION ( true )
F ( 5 ) no OPTION  // Equivalent to F ( 5 ) OPTION ( false )
\end{verbatim}\end{indpar}

If a {\em required-value} is given in a prototype, the call must
have an equal compile-time actual argument value
in order for the call to match the prototype.
Note that the argument variable type need not be compile-time,
as compile-time values can be converted to run-time values.
Matches to prototypes with more {\em required-values}
are preferred over matches to prototypes with less {\em required-values}.
Thus the example:
\begin{indpar}\begin{verbatim}
function F ( int x ) G ( int y == 5 ):  // First F declaration
    . . . . . . . . . .
function F ( int x ) G ( int y ?= 5 ):  // Second F declaration
    . . . . . . . . . .
int z = 5
F ( 8 )            // Matches only second F declaration
F ( 8 ) G ( 5 )    // Matches preferred first F declaration
F ( 8 ) G ( 6 )    // Matches only second F declaration
F ( 8 ) G ( z )    // Matches only second F declaration
                   // (z is not compile-time).
\end{verbatim}\end{indpar}

A `{\tt *DEFERRED*}' {\em function-declaration} permits
inline functions defined between it and a later
non-{\tt *DEFERRED*} companion {\em function-declaration} to call the
function.  An example is:
\begin{indpar}\begin{verbatim}
function F2 ( const i): deferred
function F1 ( const i):
    if i != 0:
        <do F1 thing>
        F2 ( i - 1 )

F1 ( 1 )   // Compile Error: Call F2(0) cannot be expanded.

function F2 ( const i )
    if i != 0:
        <do F2 thing>
        F1 ( i - 1 )

F1 ( 5 )   // Legal, expands to:
           //    <do F1 thing>
           //    <do F2 thing>
           //    <do F1 thing>
           //    <do F2 thing>
           //    <do F1 thing>
           // Would not be legal if the deferred
           // function declaration were omitted,
           // as then no F2 declaration would be
           // visible to the statements of F1.
\end{verbatim}\end{indpar}
Here the statements of {\tt F1} compile in the context
of the declaration of {\tt F1} and need the {\tt *DEFERRED*}
declaration of {\tt F2} in that context to enable these
statements to call {\tt F2}.  Given that a call is enabled,
the situation where the statements of {\tt F2} are provided later
is permitted.

A {\tt *DEFERRED*} declaration and its companion non-{\tt *DEFERRED*}
declaration must have identical prototypes, except:
\label{COMPANION-DECLARATION}
\begin{itemize}
\item Default values must appear only in the {\tt *DEFERRED*} declaration
and are omitted in the companion.
\item Required values need not have the same computing expressions
in the two declarations, but these expressions must evaluate to the
same values.  Note that the two expressions are each evaluated where
their prototype is declared, and therefore are evaluated in
two different contexts.
\end{itemize}

A {\tt *DEFERRED*} inline {\em function-declaration} may have at
most one companion.

The prototype of an inline {\em function-declaration} is visible
to the {\em statements} of that same declaration, and therefore
an inline function can call itself without having any {\tt *DEFERRED*}
companion.

Recursion in inline function calls must be limited by compile-time
variables such as the counter {\tt i}, for if it is not, there
will be a compile error when the compiler decides the inline nesting
is too deep or the code generated by one statement is too much.

\subsubsubsection{Inline Call-Prototype Matching}
\label{INLINE-CALL-PROTOTYPE-MATCHING}

Function calls are matched to function prototypes.  It is
a compile error if a function call fails to match any
prototype.  If the call matches more than one prototype, the
matches are ranked and if there is just one with the maximum
rank, that match is used; otherwise it is a compile error.

Call-prototype matching is done as follows:

\begin{enumerate}
\item If the call begins with a {\em module-abbreviation}
and the {\em prototype-pattern}
either does not begin with a {\em module-abbreviation},
or begins with one that names a different module from that of the call,
the call-prototype match fails.

If the {\em prototype-pattern} begins with a {\em module-abbreviation}
and the call does not, the match is marked as
\key{module deficient}\label{MODULE-DEFICIENT}.

\item The {\em function-term-names} in the prototype are matched to
{\em call-term-names} in the call.  To match, the names must be identical,
except that quotes in prototype
{\em quoted-marks} and {\em quoted-separators} may be (but need not be)
removed in the call
(thus prototype {\tt "+"} matches call {\tt +} and also call {\tt "+"}).

The match is made by scanning the call from left-to-right
while identifying sequences of lexemes that match
{\em function-term-names} in the prototype.  After identifying
a name, the scan skips to just after the name.  If several
names match at the same position, the longest is chosen.
The scan may match a single prototype name to several points in the
call, but if this happens, the call-prototype match fails.
If the first prototype name fails to match the first call name,
the call-prototype match fails, but otherwise names may be matched
in any order.

\item
The {\em function-term-names} found in the call are used to determine
the extent of {\em call-terms} in the call.  For starters, each
{\em call-term} consists of its {\em call-term-name} and everything
following up to the next {\em call-term-name} or end of call.
If the prototype begins
with {\em pattern-argument-lists}, the situation is treated as
if both prototype and call began with identical virtual
{\em term-names}.

Then if a {\em call-term-name} is matched to a {\em boolean-pattern-term}
{\em function-term-name} and if its {\em call-term} has no
{\em call-argument-lists}, then if the preceding {\em call-term}
ends in `\TT{no}' or `\TT{not}', this last is removed from the
preceding {\em call-term} and `{\tt (false)}' is appended to the
current {\em call-term}, while otherwise `{\tt (true)}' is appended to the
current {\em call-term}.

A {\em call-term}
must match its corresponding prototype {\em pattern-term} according
the rules that follow.  Failure of any call-prototype term match
causes the prototype-call match to fail.

\item For a {\em call-term} to match its corresponding {\em pattern-term},
both must have the same number of {\em argument-lists}, the same
brackets (either {\tt (~)} or {\tt [~]}) for corresponding
{\em argument-lists}, and the same number of
arguments in corresponding {\em argument-lists}, \underline{after}
the {\em call-term} has been \key{adjusted}.  The following are
permitted adjustments.

For every {\em pattern-term} that has no corresponding {\em call-term}
(because its {\em function-term-name} was not found in the call),
a {\em call-term} consisting of just the {\em pattern-term}'s
{\em function-term-name} is appended to the {\em function-call}.
After this the {\em call-terms} are re-ordered so their order
matches that of their associated {\em pattern-terms}.

If in a left-to-right scan of a {\em call-term},
a {\em call-argument-list} with {\tt (~)} is expected but no {\tt (}
is found, and instead a {\em constant} or {\em reference-expression}
is found, {\tt (~)} parentheses are placed around the
{\em constant} or {\em reference-expression}.  This cannot be
done twice in succession.  Note that {\em constants} and
{\em refererence-expressions} can have neither {\tt ()}'s nor operators
outside {\tt []} brackets.

If in a left-to-right scan of a {\em call-term},
a {\em call-argument-list} with {\tt (~)} is expected but no {\tt (}
is found, and instead a {\em call-argument-list} with {\tt [~]}
or the end of the {\em call-term} is found,
the empty list {\tt ()} is inserted.

Note that {\em argument-lists} with {\tt [~]} brackets cannot
be omitted or have their {\tt [~]} brackets omitted.

If a {\em call-argument-list} is shorter than the
corresponding {\em pattern-argument-list}, and all omitted
arguments in the {\em call-argument-list} have {\em default-values}
in the {\em pattern-argument-list}, the {\em default-values} corresponding
to the omitted arguments are inserted into
the {\em call-argument-list}.

At this point the {\em pattern-argument-lists} in the prototype
must match in order all the {\em call-argument-lists} in the call, both in
type of brackets (either `{\tt (~)}' or `{\tt [~]}') and in number
of arguments, else the call-prototype match fails.

\item If all the above is successful, then {\em actual-arguments}
in the call are matched to corresponding {\em prototype-argument-declarations}
in the prototype according to the rules that follow.
Failure of any of these matches causes
the call-prototype match to fail.

\item If an {\em prototype-argument-declaration} has a {\em required-value},
its matching {\em actual-argument} must be compile-time with
a value equal to the {\em required-value}, else the call-prototype
match fails.

\item If the {\em function-call} is the right side (part after {\tt =})
in a {\em call-assigment-statement},
the number of {\em assignment-results} in the {\em call-assigment-statement}
must not be greater than the number of
{\em prototype-result-variable-declarations}, else the call-prototype
match fails.

The {\em assignment-results} are matched to the
{\em prototype-result-declarations} going from left to right
according to the rules that follow.
Any unmatched {\em prototype-result-declarations}
are ignored.  

\item If an {\em argument-result} $AR$ matches a
{\em prototype-result-declaration} $RD$, the statement `$AR$ = $RD$'
must successfully compile
when the {\em variable-name} in $RD$ is replaced by a unique virtual
{\em variable-name}, else the call-prototype match fails.

The statements `$AR$ = $RD$' are processed in left to right order of
{\em prototype-result-declarations}.
and any unassigned wild-cards\pagnote{WILD-CARD}
in $RD$ are assigned the corresponding
values in $AR$ (e.g., `{\tt int x = T\$1 y}' would assign `{\tt int}'
to {\tt T\$1} if {\tt T\$1} were unassigned).

\item If an {\em prototype-argument-declaration} $AD$ matches
an {\em actual-argument}
$AA$, the statement `$AD$ = $AA$' must successfully compile
when the {\em variable-name} in $AD$ is replaced by a unique virtual
{\em variable-name}, else the call-prototype match fails.

The statements `$AD$ = $AA$' are processed in left to right order
of prototype {\em prototype-argument-declarations},
and any unassigned wild-cards\pagnote{WILD-CARD}
in $AD$ are assigned the corresponding
values in $AA$ (e.g., `{\tt T\$1 x = int y}' would assign `{\tt int}'
to {\tt T\$1} if {\tt T\$1} were unassigned).

\item A {\em function-call} that is \underline{not}
the right side (part after {\tt =}) of a {\em call-assigment-statement}
must be compile-time\pagnote{COMPILE-TIME} else the
call-prototype match fails.
The prototype of such a call must
have at least one {\em prototype-result-declaration} (which
will take on the value of the {\em expression} that consists of
just the {\em function-call}), else the
call-prototype match fails.

Compile-time calls are processed inside-out within a {\em statement},
and upon being processed each call is replaced by its value computed
at compile-time.

\end{enumerate}

If after applying these rules each match is assigned a rank
equal to the number of required arguments the match has
plus a very large number if the match is not module deficient.
Then if there is a single match with maximum rank, that match
is accepted, and otherwise all matches fail and there is
a compile error.

\subsubsubsection{Out-of-Line Function Declarations}
\label{OUT-OF-LINE-FUNCTION-DECLARATIONS}

An out-of-line function prototype is a limited subset of
an inline function prototype which ensures that there is
a single ordered list of arguments.  To obtain a more
flexible interface, an out-of-line function call should
be embedded in an inline function that pre-processes the
arguments.

The syntax of an out-of-line function declaration is:

\begin{indpar}
\emkey{out-of-line-function-declaration}%
	\label{OUT-OF-LINE-FUNCTION-DECLARATION} ::= \\
\hspace*{0.5in}
    \begin{tabular}[t]{rl}
        &  {\em out-of-line-function-prototype} \TT{:} \\
	& \TT{~~~~~}{\em statement}\PLUS{} \\
    $|$ &  {\em out-of-line-function-prototype} \TT{:} \ttkey{*DEFERRED*} \\
    \end{tabular}
\\[2ex]
\emkey{out-of-line-function-prototype}%
	\label{OUT-OF-LINE-FUNCTION-PROTOTYPE} ::= \\
\hspace*{0.25in} \ttkey{out-of-line function}~
          \{ {\em prototype-result-list}~ \TT{=}~ \}\QMARK{} \\
\hspace*{0.5in}{\em out-of-line-function-name}~
	      {\em pattern-argument-list}\QMARK{}
\\[0.5ex]
\emkey{out-of-line-function-name} ::= \\
\hspace*{0.25in}
    {\em module-abbreviation}\QMARK{} {\em basic-name}
    $|$ {\em foreign-function-name}
\\[0.5ex]
{\em foreign-function-name} ::= {\em quoted-string}
\\[0.5ex]
{\em prototype-result-list} ::= see \pagref{PROTOTYPE-RESULT-LIST}
\\[0.5ex]
{\em module-abbreviation} ::= see \pagref{MODULE-ABBREVIATION}
\\[0.5ex]
{\em basic-name} ::= see \pagref{BASIC-NAME}
\\[0.5ex]
{\em pattern-argument-list} ::= see \pagref{PATTERN-ARGUMENT-LIST}

\begin{itemize}
\item
The rules for inline {\em function-declarations} on
\pagref{FUNCTION-DECLARATION} must be followed where applicable.
\item
`{\tt ??}' {\tt bool} defaults are not allowed.
\item
Wild-cards are not allowed.
\item
The rules for inline `{\tt *DEFERRED*}' {\em function-declarations} and
their companions on \pagref{COMPANION-DECLARATION}
must be followed for {\tt *DEFERRED*} {\tt out-of-line-function-declarations}
and their companions.
\end{itemize}
\end{indpar}

An out-of-line function with a {\em quoted-string} as its
{\em out-of-line-function-name} is \key{foreign}.

A non-foreign out-of-line function can be called with a normal
{\em function-call}.\pagnote{FUNCTION-CALL}  A foreign
out-of-line function must be called with an:
\begin{indpar}
\emkey{out-of-line-function-call}%
	\label{OUT-OF-LINE-FUNCTION-CALL} ::= \\
\hspace*{0.25in}
	\ttkey{call} {\em foreign-function-name}
	     {\em call-argument-list}\QMARK{}
\\[0.5ex]
{\em call-argument-list} ::= see \pagref{CALL-ARGUMENT-LIST}
\end{indpar}

Unlike inline functions, an out-of-line function can
be called from a statement for which only a {\tt *DEFERRED*} declaration
of the out-of-line function is visible.  A missing companion
declaration is not a compile-time error, but will be a
run-time error if the function is actually called at run-time.

Like inline functions, a {\tt *DEFERRED*} {\em out-of-line-function-declaration}
can have only one companion.  It is common for the {\tt *DEFERRED*}
declaration to be in a module and its companion to be in a body of
that module.

If\label{OUT-OF-LINE-EXTERNAL-COMPANION}
a {\tt *DEFERRED*} {\em out-of-line-function-declaration}
is external,\pagnote{EXTERNAL-FUNCTION}
its companion may be anywhere in the scope of the declaration,
including in another module or another module's body that imports
the declaration's module.
This allows a module to call out-of-line functions defined by
a companion in another module that imports the first module.

A function type whose values are pointers to out-of-line
functions may be declared by:

\begin{indpar}
\emkey{function-type-declaration}\label{FUNCTION-TYPE-DECLARATION} ::= \\
\hspace*{0.5in}
    \ttkey{type} {\tt function-type-name} \TT{is}
                 {\em function-type-prototype}
\\[0.5ex]
\emkey{function-type-name} ::= {\em target-name}
\\[0.5ex]
\emkey{function-type-prototype}%
	\label{FUNCTION-TYPE-PROTOTYPE} ::= \\
\hspace*{0.25in} \ttkey{function}~
        \{ {\em prototype-result-list}~ \TT{=} \}\QMARK{}~
	\TT{()}~ {\em pattern-argument-list}\QMARK{}
\end{indpar}

Here the {\em function-type-prototype} is just like an
{\em out-of-line-function-prototype} except that the
{\em out-of-line-function-name} is replaced by {\tt ()} and
the word `{\tt out-of-line}' is omitted as being superfluous.

The only operations defined on function type values are copying them and
calling them.  A call to such a value has the form:
\begin{indpar}
\emkey{function-value-call}\label{FUNCTION-VALUE-CALL} ::=
	\TT{(} {\em expression} \TT{)}
	     {\em call-argument-list}\QMARK{} \\
\\[0.5ex]
{\em expression} ::= see \pagref{EXPRESSION}
\\[0.5ex]
{\em call-argument-list} ::= see \pagref{CALL-ARGUMENT-LIST}
\\[1ex]
where
\begin{itemize}
\item The first {\em expression} evaluates to a function type value.
\item The \TT{()} parentheses around the first {\em expression} may be
omitted if the first {\em expression} is an
{\em unparenthesized-actual-argument}:
see \pagref{UNPARENTHESIZED-ACTUAL-ARGUMENT}.
\end{itemize}
\end{indpar}

A function constant can be declared by:
\begin{indpar}
\emkey{function-constant-declaration}%
    \label{FUNCTION-CONSTANT-DECLARATION} ::= \\
\hspace*{0.5in}
    \begin{tabular}[t]{rl}
        &  {\em function-type-name} {\em function-constant-name} \TT{:} \\
	& \TT{~~~~~}{\em statement}\PLUS{} \\
    \end{tabular} \\
\emkey{function-constant-name} ::=
    {\em module-abbreviation}\QMARK{} {\em basic-name}
\end{indpar}

Here the first line behaves like an {\em out-of-line-function-prototype}
made by taking the {\em function-type-prototype} specified by the
{\em function-type-name} and replacing the {\tt ()}
{\em out-of-line-function-name} by the {\em function-constant-name}
while adding `{\tt out-of-line}' to its beginning.  In addition
the {\em function-constant-name} is declared as a constant whose
value has the type named by the {\em function-type-name}.
Internally this constant is a run-time pointer to the out-of-line function.



\subsubsubsection{Module and Body Declarations}
\label{MODULE-AND-BODY-DECLARATIONS}

A \key{module} is a file whose first statement is a {\em module-declaration}:

\begin{indpar}
\emkey{module-declaration}\label{MODULE-DECLARATION}
    \begin{tabular}[t]{rl}
    ::= & {\em simple-module-declaration} \\
    $|$ & {\em simple-module-declaration}\TT{:} \\
	& \TT{~~~~}{\em import-clause}\STAR{} \\
    \end{tabular} \\
\emkey{simple-module-declaration} ::= \TT{module} {\em module-name}
        \TT{as} {\em module-abbreviation} \\
\emkey{module-name}\label{MODULE-NAME} ::= {\em quoted-string} \\
{\em module-abbreviation} ::= see \pagref{MODULE-ABBREVIATION} \\
\emkey{import-clause}\label{IMPORT-CLAUSE}
    ::= \ttkey{import} {\em module-name} \TT{as} {\em module-abbreviation}

\begin{itemize}

\item
A {\em module-declaration} may only appear as the first statement
of a module file.

\item
In a {\em module-declaration} all {\em module-abbreviations} must be
distinct, and all {\em module-names} must be distinct.
\end{itemize}
\end{indpar}

A {\em module-name} is a POSIX file name.
The {\em module-name} of a {\em module-declaration} must match the
name of the file containing the
{\em module-declaration}, relative to one of several directories
specified separately to the compiler.

The {\em module-abbreviation} associated with a {\em module-name}
may differ in different files.  Specifically, the {\em module-abbreviation}
for a module used in the module's own module file need not be the same
as the {\em module-abbreviations} used for the module in files
that import the module.

The module \TT{"standard"}\index{standard@\TT{"standard"}} with
module abbreviation \ttkey{std} is builtin and contains the builtin types and
functions.  The {\em import-clause}
\begin{center}
{\tt import }\TT{"standard"}{\tt{} as \ttkey{std}}
\end{center}
is implied in every {\em module-declaration} and
{\em body-declaration}.

A \key{body} is a file whose first statement is a {\em body-declaration}:

\begin{indpar}
\emkey{body-declaration}\label{BODY-DECLARATION} ::=
    \begin{tabular}[t]{l}
    \TT{body }{\em body-name}\TT{ of }{\em module-name}\TT{:} \\
    \TT{~~~~}{\em body-clause}\STAR{} \\
    \end{tabular}
\\[0.5ex]
\emkey{body-name} ::= {\em quoted-string}
\\[0.5ex]
{\em module-name} ::= see \pagref{MODULE-NAME}
\\[0.5ex]
\emkey{body-clause} ::= {\em import-clause} $|$ {\em after-clause}
\\[0.5ex]
{\em import-clause} ::= see \pagref{IMPORT-CLAUSE}
\\[0.5ex]
\emkey{after-clause} ::= \ttkey{initialize after }{\em body-name}

\begin{itemize}

\item
A {\em body-declaration} may only appear as the first statement
of a body file.

\item
In a {\em body-declaration} the {\em module-abbreviations} of imported
modules must be distinct and must be different from the
{\em module-abbreviation} used by the body's module,
and all {\em module-names} and {\em body-names} must be distinct.
\end{itemize}

\end{indpar}

A {\em body-name} is a POSIX file name.
The {\em body-name} of a {\em body-declaration} must match the
name of the file containing the
{\em body-declaration}, relative to one of several directories
specified separately to the compiler.

A \key{body} is an extension of the module named in the first
line of the {\em body-declaration}.

A body implicitly imports the module it extends.  Within the
body that module has the same {\em module-abbreviation} that it
had in the module's own file.  The other modules imported in the
module's own file are \underline{not} implicitly imported
to the body.  The body must import whatever other modules it uses
explicitly.

The {\em after-clauses} name other bodies, not necessarily in
the same module,
and determine the order in which bodies are initialized:
see \itemref{PROGRAM-INITIALIZATION}.

\subsubsubsection{Program Initialization}
\label{PROGRAM-INITIALIZATION}

A module is initialized by executing its top level {\em statements}
in the order in which they appear in the module.  Similarly
a body is initialized by executing its top level {\em statements}
in the order in which they appear in the body.

The order in which modules and bodies are initialized is determined
by the following rules.
\begin{enumerate}
\item If a module or body imports another module, the imported module
is initialized before the module or body.
\item A module is initialized before any of its bodies.
\item If a module or body contains an {\em after-clause}, the module
or body is initialized after the body named in the {\em after-clause}.
\end{enumerate}

The conceptual directed graph whose nodes are modules and bodies
and whose arrows connect each module or body to the modules and
bodies it must be initialized after is called
the `\key{initialization graph}'\label{INITIALIZATION-GRAPH}
and \underline{must be acyclic}.

\subsubsection{Include Statements}
\label{INCLUDE-STATEMENTS}

Any inline function call can set the \ttkey{*CODE*} variable
to a list of parsed statements which will be prepended to
the list of statements remaining to be compiled once the statement
containing the function call is compiled.  It is an error
if there is more than one function call doing this in
the statement that sets the
{\tt *CODE*} variable.

It is not necessary to include certain annotations
in {\tt *CODE*} statements or expressions.

Specifically, it is \underline{not} necessary to
include the {\tt .position} or
the following {\tt .initiator}s or {\tt .terminator}s:

\begin{center} \tt
{\rm \bf Unnecessary Annotations}
\\[1ex]
\begin{tabular}{l@{~~~~~~~~~~}l}
.initiator & .terminator
\\[1ex]
*LOGICAL-LINE* & "<LF>" \\
"(" & ")" \\
\end{tabular}
\end{center}

because the {\tt .position} of the function call will be added
if no {\tt .position} is given,
logical lines can be identified from context, and
{\tt ()} bracketted subexpressions are equivalent to
subexpressions with implied brackets (i.e., with no
{\tt .initiator} or {\tt .terminator}).

However, any {\tt .separator} and the following must be included:

\begin{center} \tt
{\rm \bf Necessary Annotations}
\\[1ex]
\begin{tabular}{l@{~~~~~~~~~~}l}
.initiator & .terminator
\\[1ex]
":" & *INDENTED-PARAGRAPH* \\
"[" & "]" \\
\end{tabular}
\end{center}


The {\em include-statement} can be used to parse statements
and append them to the end of the list which is the value of
of a variable:

\begin{indpar}
\emkey{include-statement}\label{INCLUDE-STATEMENT} ::= \\
\hspace*{0.3in}
    \begin{tabular}[t]{l}
    \TT{include} {\em include-variable}\QMARK{}
    	{\em include-argument-list}\QMARK{} \TT{:} \\
    \TT{~~~~}{\em statement}\STAR{} \\
    \TT{include}  {\em include-variable}\QMARK{}
    	{\em include-argument-list}\QMARK{} \TT{:}
	{\em statement} \\
    \end{tabular}
\\[0.5ex]
\emkey{include-variable} ::= {\em target-label}
	~~~~~ [see \pagref{TARGET-LABEL}]
\\[0.5ex]
\emkey{include-argument-list} ::= \TT{( )} $|$
	\TT{(} {\em include-argument}
	\{ \TT{,} {\em include-argument} \}\STAR{} \TT{)}
\\[0.5ex]
\emkey{include-argument} ::= {\em word} beginning with a {\em letter} or
	with `\TT{\#}' followed by a {\em letter}

\end{indpar}

An {\em include-statement} is executed at compile time;
its {\em statements} are parsed and the parser output is
appended to the list designated by the {\em include-variable},
which must be a {\tt const} variable.  The {\em include-variable}
defaults to {\tt *CODE*}, and in this special case, does not
have to be declared in advance of use: it will be automatically
declared at the level of the smallest containing inline
{\em function-declaration} when needed.

Each {\em include-argument} must be a {\tt const} variable assigned
a value before the {\em include-state\-ment}.  Everywhere this variable
appears in the parsed {\em statements} of the {\em include-statement},
the value of the variable is substituted for the variable name.

Substitution for {\em include-arguments} obeys the following rules:
\begin{itemize}
\item If the {\em include-argument} begins with {\tt \#}, if its
value is a list, and if the
instance being substituted is an element of a list,
the {\em include-argument} list is spliced into the instance containing
list.
Thus if {\tt \#X = \{"A", "B"\}} then \\
\hspace*{2em}{ \tt
"Y", "=", \{ "\#X", 1 \} {\rm becomes} "Y", "=", \{ "A", "B", 1 \}
} \\
The {\em include-argument} value list may be empty.
If {\tt \#X = \{\}} then \\
\hspace*{2em}{ \tt
"Y", "=", \{ "\#X", 1 \} {\rm becomes} "Y", "=", \{ 1 \}
}

\item Otherwise the value of the {\em include-argument} replaces the
instance in the parsed {\em statement}.
Thus if {\tt X = \{ "A", "+", "B"\}} then \\
\hspace*{2em}{\tt
"Y", "=", \{ "X", "*", 2 \}
{\rm becomes}
\\\hspace*{2em}%
"Y", "=", \{ \{ "A", "+", "B" \}, "*", 2 \}
}
\end{itemize}

\subsubsection{Parser Output}
\label{PARSER-OUTPUT}

The output produced by the parser when it parses code is as
follows.  In the following \ttkey{*LOGICAL-LINE*} and
\ttkey{*INDENTED-PARAGRAPH*} name special values.

Recall that the input is a sequence of logical lines.

For a logical line, the parser produces a list with the
annotations: \\
\hspace*{0.5in}{\tt .initiator => *LOGICAL-LINE*, .terminator => "<LF>"} \\
The list elements are strings and numbers representing lexemes, and
lists representing subexpressions.

Recall that an indented paragraph may appear at the end of a logical line.

For an indented paragraph the parser produces a list
which has the annotations: \\
\hspace*{0.5in}{\tt .initiator => ":", .terminator => *INDENTED-PARAGRAPH*} \\
The list elements are logical lines.

For an explicitly bracketed subexpression the parser produces a list which has
the annotations:
\hspace*{0.5in}{\tt .initiator => "(", .terminator => ")"} \\
or \\
\hspace*{0.5in}{\tt .initiator => "[", .terminator => "]"} \\
The list elements are strings and numbers representing lexemes, and
lists representing subexpressions.

For an implicitly bracketed subexpression the parser produces a list which has
\underline{no} {\tt .initiator} and {\tt .terminator} annotations.
The list elements are strings and numbers representing lexemes, and
lists representing subexpressions.

Operators that are separators, such as `\TT{,}', are not included as elements
of a list, but become a \ttkey{.separator} annotation of the list.

Lists that have a single element and have
\underline{no} {\tt .initiator}, {\tt .separator},
or {\tt .initiator} annotations are \underline{not} generated
by the parser.  What would be their single element is output in
their place.  In other words, there are no implied parentheses
around a single string, number, or subexpression.

An example is:

\begin{indpar}[1em]
Parser Input:
\begin{indpar}[1em]\begin{verbatim}
if X < Y:
    X = Y
    Y = Y + 5 * Z
    A 1, B = B, A 1
\end{verbatim}\end{indpar}

\medskip

Parser Output:
\begin{indpar}[1em]\begin{verbatim}
{ "if",
  { "X", "<", "Y" },
  { { "X", "=", "Y",
      .initiator => *LOGICAL-LINE*, .terminator => "<LF>" },
    { "Y", "=",
      { "Y", "+", { 5, "*", "Z" } },
      .initiator => *LOGICAL-LINE*, .terminator => "<LF>" },
    { { { "A", 1 }, "B", .separator => "," }
      "=",
      { "B", { "A", 1 }, .separator => "," },
      .initiator => *LOGICAL-LINE*, .terminator => "<LF>" },
    .initiator => ":", .terminator => *INDENTED-PARAGRAPH*
  }

\end{verbatim}\end{indpar}
\end{indpar}

\subsection{Scope}
\label{SCOPE}

A {\em declaration} has a \key{scope},
that is the set of statements in which any
names or prototypes defined by the {\em declaration}
are recognized.

Generally the scope of a {\em declaration} includes the {\em statements}
in any {\em block} at the end of the {\em statement}
containing the {\em declaration} (recall that a {\em statement} is a
logical line that can end in a {\em block}), and
all {\em statements} following the {\em statement} containing
the {\em declaration} up to the end of the {\em block} or file
containing this {\em statement}.

The scope of a sub-declaration of a {\em type-declaration} is
the same as the scope of the particular {\em type-declaration}
in which the sub-declaration occurs.

A \key{top-level} {\em declaration} is a {\em declaration} that is
\underline{not} in a {\em statement} inside any {\em block}.
The scope of top-level {\em declarations} in a module file is extended
to each body file of the module.

Some {\em declarations} are \key{external}\label{EXTERNAL}.
These must be top-level declarations in a module.
The scope of an external
{\em declaration} is extended to include all modules and bodies that
import the module containing the {\em declaration}.

A deferred external declaration may have a companion in a body of its module,
but not in modules or bodies that import the declaration's module.
As an exception, a deferred
{\em out-of-line-function-declaration} may have a companion
anywhere within the scope of the original declaration.

A {\em result-variable-declaration}
is external if the {variable-name} declared begins with a
{\em module-abbreviation}.

A {\em next-variable-declaration} may not be external, and its
{variable-name} may not begin with a {\em module-abbreviation}.

A {\em type-declaration} or {\em pointer-type-declaration}
is external if the {type-name} or {\em pointer-type-name}
declared begins with a
{\em module-abbreviation}.

A {\em inline-function-declaration} or {\em out-of-line-function-declaration}
is external\label{EXTERNAL-FUNCTION}
if the {\em prototype-pattern} in the {\em declaration}
is immediately preceded by a {\em module-abbreviation}.

{\em Prototype-result-declaration} and {\em prototype-argument-declaration}
{\em variable-names} cannot begin with a {\em module-abbreviation},
and therefore these {\em declarations} can never be external.

A {\em module-abbreviation} that makes a {\em declaration} external
must abbreviate the module in which the {\em declaration} occurs,
with the exception of expansions of
{\tt *EXTERNAL} {\em type-declar\-ations}\pagnote{*EXTERNAL*}
and companions of deferred
{\em out-of-line-function-declarations}.\pagnote{OUT-OF-LINE-EXTERNAL-COMPANION}

If two different {\em result-variable-declarations},
{\em pointer-type-declarations}, or {\em function-type-de\-clar\-a\-tions}
of the same {\em name} have overlapping
scope, one of these scopes must include the other,
and the declaration with the smaller scope is said to 
`\key{hide}'\label{HIDE} the other declaration.
Hiding of this kind is a compile error.

A {\em next-variable-declaration} is allowed
within the scope of a previous {\em result-variable-de\-clar\-a\-tion}
or {\em next-variable-declaration} of the same {\em variable-name}
if it is not within a smaller block than the previous declaration.
Note that a {\em next-variable-declaration} has
the same syntax as a {\em reference-expression}, and its use
as an implicitly {\tt *WRITE-ONLY*} {\em reference-expression}
is allowed within smaller blocks.

{\em Type-declarations} \underline{cannot} hide each other.  The second
declaration appends sub-declarations
to the first.\pagnote{TYPE-DECLARATION-APPEND}

Prototypes \underline{cannot} hide each other.  If the
current scope contains two declarations whose prototypes
both match a call, the call is ambiguous and in error,
even if the scope of one declaration is within
a subblock of the scope of the other.

{\em Statement-labels}, that is {\em block-labels},
{\em exit-labels}, and {\em loop-labels}, have as their scope
the block in which they are defined.  {\em Statement-labels}
\underline{cannot} hide each other.

The \key{context}\label{CONTEXT} of a statement is the set of declarations
whose scope the statement is in.

When a {\em function-call} to an inline function is expanded,
the context of the compilation is \underline{not} the current context but
rather the context of the inline {\em function-declaration}
that provided the {\em statements} executed by the call.
Also the context in which any {\em default-value} expression
provided by a declaration
is compiled is the \underline{not} the current context but
rather the context of that declaration.

Code produced by {\em include-statements} executed during a call to a
compile-time function
\underline{is} compiled in the context of the call.
See Include Statements (\pagref{INCLUDE-STATEMENTS}).

An example is:
\begin{indpar}\begin{verbatim}
module "my_own_module" as mom:
    // `import "standard" as std' is implied
    import "George's_own_module" as gom
    // gom contains:
    //    function int32 z = gom ( int32 x ) "+" ( int32 y )

int32 mom my external constant = ...
int32 my internal constant = ...

function int32 y = mom my external function ( int32 x ):
    ... function body omitted ...
function int32 y = my internal function ( int32 x ):
    ... function body omitted ...

function int32 z = my inline function ( int32 x, int32 y ):
    int32 z1 = gom ( x + y )
        // Uses gom's + operator.
        // Compiles as as `gom (x) "+" (y)'.
    int32 z2 = std ( x + y )
        // Uses builtin std's + operator.
        // Compiles as as `std (x) "+" (y)'.
    z  = z1 + z2 
        // Compiles as `z = ( (x) "+" (y) )'.
        // Compile error, ambiguous: both std + operator
        // and gom's + operator match the call to "+".
\end{verbatim}\end{indpar}\label{EXTERNAL-INTERNAL-EXAMPLE}

More specifically,
when a function declaration is used, the {\em module-abbreviation}
beginning the function call may be omitted if the function declaration is
the only function declaration within scope that matches the usage,
according to the module deficiency rules of
section~\itemref{INLINE-CALL-PROTOTYPE-MATCHING}.
Thus in the context of the above example the lines:
\begin{indpar}\begin{verbatim}
int32 y = mom my external function ( x )
int32 y = my external function ( x )
\end{verbatim}\end{indpar}
are equivalent if no {\em function-prototype}
\begin{center}
\tt function int32 r = $ma$\QMARK{} my external function ( int32 v )
\end{center}
is in scope, where $ma$ is a module abbreviation other than `{\tt mom}'.

\section{Compile Time Functions}

Compile-time is defined in \itemref{COMPILE-TIME}.
Compile time data are just the constants decribed in \itemref{CONSTANTS}.
Compile time data all have {\tt const} type and one of
5 subtypes: integers, rationals, strings,
special values, and maps.

The functions described in the following sections are builtin.

If an argument is of the wrong type for a function, all the
function results will be the {\tt UNDEF} special value, and
a compiler error message will be produced.  Unless stated
otherwise, other errors in arguments (e.g., malformed
regular expressions given to {\tt compile re}) are treated
similarly.

\subsection{Compile Time General Functions}

{\tt const r =} (const v1) \ttkey{"=="} {\tt ( const v2 )} \\
{\tt const r =} (const v1) \ttkey{"!="} {\tt ( const v2 )}
\begin{indpar}
Comparisons of {\tt const} values of different types treat
the values as unequal.
\end{indpar}

{\tt const r =} \ttkey{type} {\tt ( const v1 )}
\begin{indpar}
Returns the type of {\tt v1} as one of the strings: \\
\hspace*{0.5in}{\tt
"special" ~  "integer" ~ "rational" ~ "string" ~ \tt "map"}
\end{indpar}


\subsection{Compile Time Number Functions}

{\tt const r =} \ttkey{"+"} {\tt ( const n1 )} \\
{\tt const r =} \ttkey{"-"} {\tt ( const n1 )} \\
{\tt const r =} (const n1) \ttkey{"+"} {\tt ( const n2 )} \\
{\tt const r =} (const n1) \ttkey{"-"} {\tt ( const n2 )} \\
{\tt const r =} (const n1) \ttkey{"*"} {\tt ( const n2 )} \\
{\tt const r =} (const n1) \ttkey{"/"} {\tt ( const n2 )}
\begin{indpar}
Standard arithmetic operators on numbers {\tt n1} and {\tt n2},
done using integer or rational arithmetic.  Dividing by {\tt 0},
adding {\tt +Inf} to {\tt -Inf}, a {\tt NaN} argument, etc.~return
{\tt NaN} and \underline{no} compiler error message.
\end{indpar}

{\tt const r =} (const i1) \ttkey{"\&"} {\tt ( const i2 )} \\
{\tt const r =} (const i1) \ttkey{"|"} {\tt ( const i2 )} \\
{\tt const r =} (const i1) \ttkey{"\textasciicircum"} {\tt ( const i2 )} \\
{\tt const r =} (const i1) \ttkey{"<{}<"} {\tt ( const i2 )} \\
{\tt const r =} (const i1) \ttkey{">{}>"} {\tt ( const i2 )}
\begin{indpar}
Standard bitwise operators on integers {\tt i1} and {\tt i2}
that are treated as two's complement.
\end{indpar}

{\tt const r =} (const n1) \ttkey{"=="} {\tt ( const n2 )} \\
{\tt const r =} (const n1) \ttkey{"!="} {\tt ( const n2 )} \\
{\tt const r =} (const n1) \ttkey{"<"} {\tt ( const n2 )} \\
{\tt const r =} (const n1) \ttkey{"<="} {\tt ( const n2 )} \\
{\tt const r =} (const n1) \ttkey{">"} {\tt ( const n2 )} \\
{\tt const r =} (const n1) \ttkey{">="} {\tt ( const n2 )}
\begin{indpar}
Standard comparison operators on numbers {\tt n1} and {\tt n2}.
Infinities are treated as actual numbers with absolute value
larger than any real number: e.g., `{\tt x <= +Inf}' is always
true and `{\tt x == +Inf}' is true iff {\tt x} is {\tt +Inf}.
If an argument is a {\tt NaN}, all comparisons return false
except {\tt !=} which returns true.
\end{indpar}

{\tt const r =} \ttkey{numerator} {\tt ( const number )} \\
{\tt const r =} \ttkey{denominator} {\tt ( const number )}
\begin{indpar}
These functions return the numerator and denominator of a number.
Both numerator and denominator are integers.
The denominator is {\tt 1} for integer numbers, and {\tt >= 2}
for rational numbers.
\end{indpar}

\subsection{Compile Time String Functions}

{\tt const r =} \ttkey{"\#"} {\tt ( const s )}
\begin{indpar}
Returns the length of string {\tt s} as a non-negative integer.
\end{indpar}

{\tt const r =} (const s1) \ttkey{"+"} {\tt ( const s2 )}
\begin{indpar}
Returns the concatenation of string {\tt s1}
and string {\tt s2}.
\end{indpar}

{\tt const r =} (const s1) \ttkey{"=="} {\tt ( const s2 )} \\
{\tt const r =} (const s1) \ttkey{"!="} {\tt ( const s2 )} \\
{\tt const r =} (const s1) \ttkey{"<"} {\tt ( const s2 )} \\
{\tt const r =} (const s1) \ttkey{"<="} {\tt ( const s2 )} \\
{\tt const r =} (const s1) \ttkey{">"} {\tt ( const s2 )} \\
{\tt const r =} (const s1) \ttkey{">="} {\tt ( const s2 )}
\begin{indpar}
Standard lexigraphic comparison operators on strings {\tt s1} and {\tt s2}.
Characters are compared by comparing their UNICODE codes as unsigned
32-bit integers.
\end{indpar}

{\tt const r =} \ttkey{explode} {\tt ( const s )}
\begin{indpar}
Returns a map that is a vector whose elements are unsigned integers equal
to the UNICODE codes of the characters of string {\tt s}.
\end{indpar}

{\tt const r =} \ttkey{implode} {\tt ( const m )}
\begin{indpar}
Given a map {\tt m} that is a vector whose elements are unsigned integers
that are UNICODE codes of characters, return the string whose characters
are those specified by the map elements in the order specified by the map.
\end{indpar}

{\tt const r =} \ttkey{compile re} ( const s )
\begin{indpar}
Compile the regular expression represented by the string {\tt s}
and return an integer that references the compiled expression.

Regular expressions are those recognized by the {\tt pcre32}
subroutine library for linux: see {\tt pcrepattern[3]} in
the linux documentation.  The only line ends recognized
by {\tt \textbackslash R} and {\tt \$} are LF, CR, and CRLF (no other
{\tt pcre32} options are used).  By default {\tt \textasciicircum}
matches the beginning of {\tt s} and {\tt \$} matches the end.
This can be changed by the {\tt (?i)} option setter in the
regular expression.
\end{indpar}

\ttkey{free re} ( const i )
\begin{indpar}
Free the memory used by the compiled regular expression
referenced by the integer {\tt i}.  Does nothing if {\tt i}
does not reference a compiled regular expression.
\end{indpar}

{\tt const r =} \ttkey{match re} ( const i, const s  )
\begin{indpar}
Matches the string {\tt s} to the compiled regular expression
referenced by the integer {\tt i}.
Returns a map {\tt r} that is a vector of substrings matched.
If there is no match this is an empty list.  If there is
a match, {\tt r[0]} is the string matched.  If there are
subpattern matches, {\tt r[i]} is the string matched by the
{\tt i}'th subpattern.

During matching {\tt s} is stored as an exploded vector of
unsigned 32-bit unicode values.  Substrings matched are
subvectors which are imploded to make {\tt const} string values.
\end{indpar}

{\tt const r =} \ttkey{scan} ( const s  )
\begin{indpar}
Scan the string {\tt s} and return a map that is a vector
containing the list of lexemes in {\tt s}.  Brackets and
operators are not specially recognized and are returned
as strings.  Quoted strings inside {\tt s} are returned
as vector elements that are maps of the form: \\
\hspace*{1in}{\tt \{ {\rm \em represented-string}, .type => "<Q>" \}}

Syntax errors produce compiler error messages and are
otherwise `fixed up' more or less, instead of returning {\tt UNDEF}.
\end{indpar}

\subsection{Compile Time Map Functions}

A {\tt const} map value is actually a pointer to the map,
and not the whole map itself.
A {\em map-constant} creates a new map, distinct from every
other map (so you can have multiple different empty maps).

A string {\em const} value represents a {\em dictionary-label}
if when parsed it is a {\em dictionary-label}.  This means it must
consist of one or more {\em name-items} each surrounded by whitespace,
the {\em name-items} must not be {\em quoted-marks} or {\em quoted-separators},
and only the first {\em name-item} may contain a `\TT{.}'
(see {\em dictionary-label} on \pagref{DICTIONARY-LABEL}).

A map may be read-write or read-only.\label{READ-ONLY-MAP}
Read-only maps cannot
be modified.  Each {\em map-constant} makes a separate read-only
map that can be made read-write permanently or temporarily by
the following:

{\tt const r =} \ttkey{read-write} {\tt ( const m )} \\
{\tt const r =} \ttkey{read-only} {\tt ( const m )}
\begin{indpar}
Makes the map {\tt m} read-write or read-only and returns {\tt m}.

When the map is created by a {\em map-constant}, it is made read-only.
\end{indpar}

Each map {\em dictionary-entry} can be separately made read-write or
read-only.  When created, the entry is read-write.  This can be
changed by the following:

{\tt const r =} \ttkey{read-write} {\tt ( const m, const s )} \\
{\tt const r =} \ttkey{read-only} {\tt ( const m, const s )} %
\label{READ-ONLY-DICTIONARY-FUNCTION}
\begin{indpar}
Makes the map label {\tt s} (a string) of the map {\tt m}
read-write or read-only, and returns {\tt m}.  The map
itself must be read-write.

When a value is first written at a label, the label is created
for the map and set to read-write.

It is a compile error is {\tt s} does not represent a
{\em dictionary-label}.
\end{indpar}

If {\tt M} is a {\tt const} valued variable whose value is a map,
and if {\tt S} is a {\tt const} valued variable, then {\tt M[S]}
may be used to reference a vector elemement or dictionary entry of
the value of {\tt M} as follows:
\begin{enumerate}
\item If the value of {\tt S} is an integer, the {\tt S}+1'st element
of the vector of {\tt M} is referenced.  If this is being read and
it does not exist, {\tt NONE} is returned and there is no compile-time
error; this always happens if {\tt S} is a negative integer.
If the element is being written but does not exist, or the map
is read-only, a compile-time error results; otherwise the element
value is changed.
\item If the value of {\tt S} is a string representing a
{\em dictionary-label}, the dictionary entry
of {\tt M} with label {\tt S} is referenced.  If this is being read and
it does not exist, {\tt NONE} is returned.  If it is being written and
it does not exist, it is created and made read-write.  If it exists and is
read-only, a compile-time error results.  If it exists and is read-write,
its value is changed.
\item Otherwise if {\tt S} is neither an integer or a string representing
a {\em dictionary-label}, a compile-error results.
\end{enumerate}

{\tt const r =} \ttkey{copy} {\tt ( const m )} \\
{\tt const r =} \ttkey{copy top} {\tt ( const m )} %
\label{MAP-COPY}
\begin{indpar}
Returns a new map whose contents is a copy of the contents of
map {\tt m}.  The new map is read-only if and only if {\tt m} is,
and the labels in the new map are read-only if and only if the
corresponding labels in {\tt m} are.

If any vector or dictionary element values are maps, they are
copied recursively by {\tt copy}, but not by
{\tt copy top}, which copies pointers to the maps.

Changing the values of elements of the new map will \underline{not} change
the contents of {\tt m}.  For {\tt copy} modifying the element values
themselves will not change {\tt m}, but for {\tt copy top},
modifying the element values will change the elements of {\tt m}.

\end{indpar}

{\tt const r =} \ttkey{duplicate} {\tt ( const m )} \\
{\tt const r =} \ttkey{duplicate top} {\tt ( const m )}
\begin{indpar}
Ditto, but if any read-only map is to be copied, the pointer
to the map is copied and no new map is made.
\end{indpar}

{\tt const r =} \ttkey{slice} {\tt ( const m, const i, const n )}
\begin{indpar}
Returns a new map consisting of just a vector of the
elements {\tt m[i]}, {\tt m[i+1]}, \ldots, {\tt m[i+n-1]}.  
If any of these elements do not exist, they are omitted (e.g.,
if {\tt i >= m..length}, {\tt i + n <= 0}, or {\tt n <= 0},
the empty map is returned).
\end{indpar}

{\tt const r =} \ttkey{splice} {\tt ( const m, const i, const n, const v )}
\begin{indpar}
Edits {\tt m} by replacing the vector element sequence
{\tt m[i]}, {\tt m[i+1]}, \ldots, {\tt m[i+n-1]} by the
vector elements of {\tt v}.  Dictionary elements of {\tt v} are ignored;
dictionary elements of {\tt m} are unchanged.
It is an error is any of the elements to be replaced do not exist
(e.g., if {\tt i < 0} or {\tt i >= m..length}).
The edited map {\tt m} is returned.
\end{indpar}

{\tt const r =} \ttkey{truncate} {\tt ( const m, const i )}
\begin{indpar}
An optimized version of {\tt splice} that removes the elements
{\tt m[i]}, {\tt m[i+1]}, \ldots, from the end of the vector of {\tt v}.
The edited map {\tt m} is returned.  It is not an error if no elements
are removed.
\end{indpar}

{\tt const r =} \ttkey{push} {\tt ( const m, const v )}
\begin{indpar}
Appends {\tt v} to the vector of {\tt m} and returns {\tt m}.
\end{indpar}

{\tt const r =} \ttkey{push} {\tt ( const m, const v, const i )}
\begin{indpar}
Executes {\tt push(m,v)} {\tt i} times.  It is an error if {\em i}
is a negative integer.
\end{indpar}

{\tt const r =} \ttkey{append} {\tt ( const m1, const m2 )}
\begin{indpar}
Appends the vector elements of the map {\tt m2} to the vector of {\tt m1}
and returns {\tt m1}.
\end{indpar}

{\tt const r =} \ttkey{pull} {\tt ( const m )}
\begin{indpar}
Deletes the last vector element of {\tt m} and returns it.
It is an error if {\tt m} is empty.
\end{indpar}

{\tt const r =} \ttkey{pull} {\tt ( const m, const i )}
\begin{indpar}
Deletes the last {\tt i} vector elements of {\tt m} and returns a map
containing them.  It is an error if there are not {\tt i} elements
in {\tt m}.
\end{indpar}

\printindex

\end{document}
